*gui.txt*       For Vim バージョン 7.4.  Last change: 2014 Mar 08


		  VIMリファレンスマニュアル    by Bram Moolenaar


Vimのグラフィカルユーザーインタフェース			*gui* *GUI*

1. GUIの開始			|gui-start|
2. スクロールバー		|gui-scrollbars|
3. マウス制御			|gui-mouse|
4. GUI選択の作成		|gui-selections|
5. メニュー			|menus|
6. 付記				|gui-extras|
7. シェルコマンド		|gui-shell|

他のGUIドキュメント:
|gui_x11.txt|	X11 GUIに特有の項目について。
|gui_w32.txt|	Win32 GUIに特有の項目について。

{Vi にはこれらのコマンドはない}

==============================================================================
1. GUIの開始					*gui-start* *E229* *E233*

まずはVimがGUIに対応したバージョンであるか確認する必要がある。それは ":version"
コマンドで調べることができる。その出力が "with xxx GUI" または "MS-Windows 32
bit GUI version" を含んでいれば問題ない。ここで "xxx" は X11-Motif,
X11-Athena, Photon, GTK, GTK2, などである。

どのようにGUIで起動するかは使用しているシステムに依存する。たいていはこのよう
にしてGUI版のVimを実行できる:
    gvim [options] [files...]

VimのX11バージョンはGUIとGUIでないモードの両方で実行することができる。
|gui-x11-start| を参照。

			*gui-init* *gvimrc* *.gvimrc* *_gvimrc* *$MYGVIMRC*
gvimrc は GUI 固有の初期化コマンドを書くためのファイルである。gvimrc は常に
ファイル |vimrc| の後に読み込まれる。環境変数 $MYGVIMRC があると、その値が
gvimrc の代わりに使われる。

GUIの初期化は次の順序で行われる:
- オプション 'term' が "builgin_gui" に設定され、端末の設定がGUI用の初期値に設
  定される。|terminal-options|
- システムのメニューファイルがあればそれが読み込まれる。このファイルの名前は通
  常 "$VIMRUNTIME/menu.vim" である。":version" でこれを確認できる。
  |$VIMRUNTIME|も参照。システムのメニューの読み込みを省略するには 'guioptions'
  に 'M' を含める。
					*buffers-menu* *no_buffers_menu*
  システムのメニューファイルはメニュー項目 "Buffers" (バッファ)の定義も含んで
  いる。これを必要としないなら、ユーザーの.vimrc (.gvimrcではない!)で
  "no_buffers_menu" を設定する: >
	:let no_buffers_menu = 1
< NOTE: 構文強調表示を有効にするとメニューファイルも読み込まれるため、メニュー
  項目Buffers(バッファ)を無効にするのは ":syntax on" の前にする。
  メニューに表示されるバッファの名前は35文字で切り詰められる。違う長さで切り詰
  めるなら、例えば50文字にするなら、次のようにする: >
	:let bmenu_max_pathlen = 50
- Vimを起動するときのコマンドライン引数に "-U {gvimrc}" が指定されると、
  {gvimrc}ファイルが初期化のために読み込まれ、以下の初期化処理は省略される。
  {gvimrc}が "NONE" の場合は、どの初期化ファイルも読み込まれない。
- UnixとMS-Windowsでは、システムのgvimrcが存在するなら、それが読み込まれる。こ
  のファイルの名前は通常 "$VIM/gvimrc" である。":version" でこれを確認できる。
  |$VIM|も参照。
- 次のものを試して、最初に見つかったものが使用される:
  - GVIMINIT環境変数が存在し空でないなら、それがExコマンドとして実行される。
  - ユーザーのgvimrcファイルが存在するなら、それが読み込まれる。このファイル
    の名前は通常 "$HOME/.gvimrc" である。":version" でこれを確認できる。
  - Win32では、$HOMEが設定されていないときは、"$VIM\_gvimrc" が読み込まれる。
  - "_gvimrc" ファイルが見つからないときには、".gvimrc" も試される。逆のときも
    同様である。
  $MYGVIMRC が設定されていないならば、$MYGVIMRC に最初に見つかったファイルの名
  前が代入される。
- 'exrc' オプションが設定されていて(これは標準設定ではない)、./.gvimrcファイル
  が存在し、それがシステム、あるいはユーザーのgvimrcファイルではないなら、それ
  が読み込まれる。このファイルがユーザーの所有しているものでないなら、いくつか
  のセキュリティ上の制限が適用される。".gvimrc" が見つからないときには、
  "_gvimrc" も試される。MacintoshとDOS/Win32では、"_gvimrc" が最初に試される。

NOTE: Vimを起動するときに、"-U" 引数を指定せずに "-u NONE" を指定するか、ある
いは "-U NONE" を指定して起動すると、最初のもの以外は全て実行されない。

これらは全て、ユーザーの.vimrcファイルを読み込む、というような、通常のVimの初
期化の後に実行される。|initialization|を参照。
しかし、GUIウィンドウは全ての初期化が実行された後に開かれる。
GUIウィンドウを開いた直後にいくつかのコマンドを実行したいなら、オートコマンド
の|GUIEnter|イベントを使用する。例えば: >
	:autocmd GUIEnter * winpos 100 50

カスタマイズしたメニュー(|:menu|を参照)をセットアップしたり、CUI版とは異なった
初期化をするために、gvimrcファイルを使用することができる。

ユーザーの個人的なGUI初期化ファイルを置くのに推奨される場所:
	Unix		    $HOME/.gvimrc、$HOME/.vim/gvimrc
	OS/2		    $HOME/.gvimrc、$HOME/vimfiles/gvimrc、$VIM/.gvimrc
	MS-DOSとWin32       $HOME/_gvimrc、$HOME/vimfiles/gvimrc、$VIM/_gvimrc
	Amiga		    s:.gvimrc、home:.gvimrc、home:vimfiles:gvimrc、
			    $VIM/.gvimrc

個人的な初期化ファイルは上記の順に検索され、最初に見つかったものだけが読み込ま
れる。

GUI版のVimでだけ意味を持つオプションがある。'guicursor'、'guifont'、'guipty'、
'guioptions' である。それらは他の全てのオプションと共に|options.txt|で説明され
ている。

GUIのMotifかAthenaバージョン(GTK+やWin32バージョンではない)を使用しているなら
ば、多くのXのリソースが有効である。|gui-resources|を参照。


端末の設定をする以外に文字の色を設定する方法はハイライトを設定することである。
ハイライトの "Normal" グループは背景色と前景色を設定するために用いられる。(ナ
イスな)例: >

	:highlight Normal guibg=grey90

"guibg" と "guifg" の設定は通常の背景と前景の設定よりも優先される。ハイライト
のNormalグループに対するその他の設定は使用されない。フォントを設定するには
'guifont' を使用する。

モード別にカーソルの色を設定するには、'guicursor' オプションを参照。

Vimは起動時に、スクリーンに合わせてウィンドウの位置を調整しようとする。これは
ウィンドウの一部が隠れてしまわないようにするためである。X Window Systemでは、
これは少し憶測を必要とする。'guiheadroom' オプションでウィンドウタイトルとタス
クバーに用いられる高さを変更することができる。

						*:winp* *:winpos* *E188*
:winp[os]
		GUI vimウィンドウの左上隅の現在の位置をピクセルで表示する。全
		てのバージョンで機能する訳ではない。
		|getwinposx()| と |getwinposy()| も参照のこと。

:winp[os] {X} {Y}							*E466*
		与えられた{X}と{Y}の座標にGUI vimウィンドウを移動する。座標は
		ウィンドウの左上隅の位置をピクセル単位で指定する。全てのバー
		ジョンで機能する訳ではない。(新しい)xtermで機能する
		|xterm-color|。
		GUIウィンドウがまだ開いていないとき、この値はウィンドウが開か
		れるまで保留される。位置はスクリーンに合うように調整される(可
		能なら)。

						    *:win* *:winsize* *E465*
:win[size] {width} {height}
		{width}(幅)と{height}(高さ)を指定してウィンドウの大きさを設定
		する。このコマンドは古いコマンド(Obsolate)なので、
		":set lines=11 columns=22" を使用するようにすること。
		期待したよりも高さが低くなるなら、'guiheadroom' オプションを確
		認すること。

X Window Systemでは、これらのコマンドでVimのウィンドウの情報を得られる: >
	:!xwininfo -id $WINDOWID
	:!xprop -id $WINDOWID
	:execute '!xwininfo -id ' . v:windowid
	:execute '!xprop -id ' . v:windowid
<
							*gui-IME* *iBus*
X で各国の文字を入力するためのインプットメソッドで XIM フレームワークに依るも
の、特に iBus は、gVim で使用すると不具合が起こることが知られている。スペース
を入力できなかったり、キーを押してからそれがアプリケーションに届くまで大きな遅
延が発生したりする。

対処療法としては gvim の起動引数に |-f| を付けてフォークをしないようにすると症
状は出なくなる。理由は不明だが。
==============================================================================
2. スクロールバー					*gui-scrollbars*

垂直スクロールバーと水平スクロールバーがある。'guioptions' オプションでどれが
表示されるかを設定することができる。

このような外観になっている(設定が ":set guioptions=mlrb" のとき):

		       +------------------------------+ `
		       | ファイル 編集	       ヘルプ | <- メニューバー(m) `
		       +-+--------------------------+-+ `
		       |^|			    |^| `
		       |#| テキストエリア	    |#| `
		       | |			    | | `
		       |v|__________________________|v| `
 Vimウィンドウ間の  -> |-+ File.c	       5,2  +-| `
 通常のステータス行    |^|""""""""""""""""""""""""""|^| `
		       | |			    | | `
		       | | 別のファイルバッファ     | | `
		       | |			    | | `
		       |#|			    |#| `
 左スクロールバー(l)-> |#|			    |#| <- 右 `
		       |#|			    |#|    スクロールバー(r) `
		       | |			    | | `
		       |v|			    |v| `
		       +-+--------------------------+-+ `
		       | |< ####		   >| | <- 下 `
		       +-+--------------------------+-+    スクロールバー(b) `

スクロールバーやメニューバーは 'guioptions' から対応する文字を取り除くことで無
効にできる。下スクロールバーは 'nowrap' が設定されているときだけ有用である。


垂直スクロールバー					*gui-vert-scroll*

各Vimウィンドウはとなりにスクロールバーを持っていて、上下にスクロールしてその
バッファ内のテキストの表示を移動できる。スクロールバーのつまみのサイズはウィン
ドウに見えているバッファの割合を示している。スクロールバーがずっと下方にドラッ
グされると、ファイルの最後の行はウィンドウの最上部に表示される。

ウィンドウが(他のウィンドウの拡大によって)高さゼロに縮小されると、そのスク
ロールバーは表示されなくなる。それはウィンドウが復元されるときに再び表示され
る。

ウィンドウを縦分割しているとき、カレントウィンドウだけがスクロールバーを利用で
きる。そして、複数のウィンドウの真ん中のウィンドウを操作しているときは、スク
ロールバーは間のウィンドウを飛び越えて作用する。
両側にスクロールバーがあるときに、複数のウィンドウの真ん中のカレントウィンドウ
が左半分に面していると、右側のスクロールバーは右端のウィンドウに影響する。左右
が逆でも同様。


水平スクロールバー					*gui-horiz-scroll*

(Vim GUIの最下段の)水平スクロールバーは、'wrap' オプションがオフのときに、テキ
ストを横にスクロールするために使用する。スクロールバーのつまみのサイズは、左右
にスクロールして一番長い行のテキストを全て表示できるくらいである。必要に応じて
カーソルが移動するとき、カーソルは表示されている文字の上にとどまる
('virtualedit' が設定されていなければ)。

一番長い行を計算するのは多少の処理時間を必要とする。そしてそれは何かが変更され
るときに毎回行われる。その時間が多すぎるようだったり、他の行へのカーソルジャン
プを好まないなら、'guioptions' に 'h' を含めると、スクロールはカーソルのある行
の長さに制限される。

							*athena-intellimouse*
インテリマウスを持っていて、Xサーバーがホイールをサポートしているなら、gvimで
テキストを上下にスクロールするのにホイールを使うことができる。これはXFree86
4.0以降のバージョンで機能する。古いバージョンでもパッチを当てれば利用可能にな
る。|scroll-mouse-wheel|を参照。

古いバージョンのXFree86ではXサーバーにパッチを当てなくてはならない。以下のペー
ジにはパッチとXサーバーのバイナリへのリンクに加えて、Linux上でインテリマウスを
使用することについて多少の情報がある(けれども必要とするものはないかもしれない):
    http://www.inria.fr/koala/colas/mouse-wheel-scroll/

==============================================================================
3. マウス制御						*gui-mouse*

マウスは、'mouse' オプションに適切なフラグが設定されている場合にだけ機能する。
GUIに切り替わるときに、'mouse' がまだ設定されていなければ、'mouse' オプション
は自動的に "a" に設定され、|hit-enter|プロンプトを除いて全てのモードで有効にな
る。これを望まないならば、"gvimrc" ファイルで 'mouse' オプションを変更する。

関連する他のオプション:
'mousefocus'	マウスポインタが乗っているウィンドウをカレントウィンドウにする
		|gui-mouse-focus|
'mousemodel'	マウスのボタンがどのような動作をするか
'mousehide'	テキストを入力している間マウスポインタを隠す
'selectmode'	選択時に選択モードとビジュアルモードのどちらを使うか

素早くこれらを設定するには ":behave" コマンドで行う。
							*:behave* *:be*
:be[have] {model}	マウスと選択の動作を設定する。有効な引数は:
			   mswin	MS-Windowsの動作
			   xterm	Xtermの動作

			":behave" を使用するとこれらのオプションが変更される:
			option		mswin			xterm	~
			'selectmode'	"mouse,key"		""
			'mousemodel'	"popup"			"extend"
			'keymodel'	"startsel,stopsel"	""
			'selection'	"exclusive"		"inclusive"

$VIMRUNTIMEディレクトリの中に、MS-Windowsにあるようなcut/copy/paste機能のため
のキーマッピングを設定する|mswin.vim|と呼ばれるスクリプトがある。これは、
CTRL-V、CTRL-X、CTRL-Cキーを用いるので、標準の操作と互換性がなくなってしまう。
それでも構わないなら、このコマンドで使用する: >
	:so $VIMRUNTIME/mswin.vim

マウスのホイールでスクロールするには、|scroll-mouse-wheel|を参照。


3.1 マウスによるカーソルの移動				*gui-mouse-move*

カーソルを持って行きたいテキストバッファのどこかでマウスの左ボタンをクリックす
ると、カーソルはそこに行く!
動作するモード		'mouse'が以下を含んでいるとき ~
ノーマルモード		'n' or 'a'
ビジュアルモード	'v' or 'a'
挿入モード		'i' or 'a'

選択モードはビジュアルモードのように扱われる。

現在のカーソル位置からマウスで指示する位置までのテキストを削除するために 'd'
のようなオペレータと共にこれを使用してもよい。つまり、'd' を入力してからどこか
をマウスでクリックする。

							*gui-mouse-focus*
'mousefocus' オプションを設定してキーボードフォーカスがマウスポインタに追従す
るようにできる。これはマウスポインタが乗っているウィンドウがアクティブウィンド
ウになることを意味する。警告: メニューをうまく利用できなくなる。メニューを使用
したときに、そのメニューに設定されたコマンドは常に一番上のウィンドウに適用され
てしまうだろう。

('mouse' が 'c'、'a'、'A' のどれかを含んでいるなら)コマンドラインモードや検索
モード中にマウスの左ボタンか右ボタンをクリックすることで、コマンドラインの行の
クリックした位置にカーソルを移動できる。

どのような状況でも、マウスの中ボタンをクリックして、現在の選択を貼り付けること
ができる。


3.2 マウスによる選択					*gui-mouse-select*

マウスを使って選択を開始できる。どのように使用するかは 'mousemodel' オプション
に依存する:
'mousemodel' が "extend" である: マウスの右ボタンを使用する。
'mousemodel' が "popup" である: Shiftキーを押しながら、マウスの左ボタンを使用
する。

選択を開始するときには、カーソルの位置からマウスで指示した位置までが選択され
る。すでに選択されている状態で選択の操作をすると、選択範囲が拡張される。

'selectmode' が "mouse" を含んでいるなら、選択モードが使用される。これは選択中
に入力した文字で選択範囲が置き換えられることを意味する。
|Select-mode|を参照。そうでなければ、ビジュアルモードが使用される。

ダブルクリックで単語の選択、トリプルクリックで行の選択、クワドルプルクリック
(4回クリック)で矩形ブロックを選択することができる。

どのように選択が用いられるかに関しては|gui-selections|を参照。


3.3 マウスによる他のテキスト選択		*gui-mouse-modeless*
						*modeless-selection*
次のときには異なる選択方法が使われる:
- コマンドラインモード
- コマンドラインウィンドウを使用中に他のウィンドウを指したとき
- |hit-enter|プロンプト
- 現在のモードが 'mouse' オプションで指定されていないときはいつでも
- GUIでCTRLキーとSHIFTキーを同時に押しているとき

テキストが選択されていても、選択されていないかのように、あるいは、選択に関連し
たモードが存在しないかのように、Vimが通常の動作を継続するので、これはモードレ
ス選択と呼ばれる。Vimウィンドウの中のどんなテキストでも選択することができる。
開始点でマウスの左ボタンを押すことでテキストを選択し、終点までドラッグして離
す。選択を延長するには、'mousemodel' が "extend" のときにはマウスの右ボタンを
使用し、'mousemodel' が "popup" のときにはシフトキーを押しながらマウスの左ボタ
ンを使用する。
選択したテキストが変更されると、選択は解除される。

コマンドラインでは CTRL-Y で選択範囲をクリップボードにコピーできる。挿入モード
中にコピーするには CTRL-O を使い CTRL-Y <CR> とする。'guioptions' に a か A が
含まれるとき (X11 では既定でそうなっている) は、選択範囲が自動的にレジスタ "*
にコピーされる。

マウス中ボタンでテキストを貼り付けられる。X11 以外のシステムでは CTRL-R + を
使えば貼り付けられる。


3.4 ステータス行でのマウスの使用			*gui-mouse-status*

Vimウィンドウの下のステータス行でマウスの左ボタンか右のボタンをクリックするこ
とでそのウィンドウがカレントウィンドウになる。これはボタンを放したときに起こる
(クリックとドラッグの操作を区別するため)。

左ボタンを使ってステータス行を上下にドラッグすると、ウィンドウのサイズを上下に
変更できる。この操作ではそのウィンドウはカレントウィンドウにならない。

ウィンドウの垂直の区切りも同様に機能する。クリックした区切りの左のウィンドウが
カレントウィンドウになる。左右にドラッグするとウィンドウの幅を変更できる。


3.5 様々なマウスクリック				*gui-mouse-various*

    <S-LeftMouse>	マウスクリックで単語を前方検索する。'mousemodel' が
			"popup" のときには、これは選択を開始するか、あるいは延
			長する。
    <S-RightMouse>	マウスクリックで単語を後方検索する。
    <C-LeftMouse>	マウスクリックでタグ名へジャンプする。
    <C-RightMouse>	直前のタグジャンプの前の位置に戻る("CTRL-T" と同じ)。


3.6 マウスマッピング					*gui-mouse-mapping*

修飾キー付きのマウスイベントをマッピングすることもできる。例えば: >
   :map <S-LeftMouse>     <RightMouse>
   :map <S-LeftDrag>      <RightDrag>
   :map <S-LeftRelease>   <RightRelease>
   :map <2-S-LeftMouse>   <2-RightMouse>
   :map <2-S-LeftDrag>    <2-RightDrag>
   :map <2-S-LeftRelease> <2-RightRelease>
   :map <3-S-LeftMouse>   <3-RightMouse>
   :map <3-S-LeftDrag>    <3-RightDrag>
   :map <3-S-LeftRelease> <3-RightRelease>
   :map <4-S-LeftMouse>   <4-RightMouse>
   :map <4-S-LeftDrag>    <4-RightDrag>
   :map <4-S-LeftRelease> <4-RightRelease>
これらのマッピングは、Motifアプリケーションの作法にしたがって、選択領域を拡張
するために、マウスの右ボタンを使わずに、Shiftキーを押しながら左ボタンを押す方
法を設定している。

修飾キーを使ったマウス操作のマッピングはモードレス選択では機能しない。


3.7 ドラッグ&ドロップ						*drag-n-drop*

Vimウィンドウに1つ、あるいは複数のファイルをドラッグ&ドロップすることができ
る。ファイルは|:drop|コマンドを使ったときのように開かれる。

Shiftキーを同時に押していると、Vimはカレントディレクトリをドロップされた最初の
ファイルがあるディレクトリに変更する。Ctrlキーを同時に押していると、ファイルを
開くためにウィンドウを分割する。押してなければカレントバッファが変更されていな
いときだけファイルは開かれる。

ディレクトリをVimにドロップすることもできる。この操作はexplorerプラグインでそ
のディレクトリを開く(それが利用可能だと想定している。無理ならエラーが表示され
るだろう)。Shiftキーを同時に押していれば、ディレクトリを開かずに、カレントディ
レクトリをそのディレクトリに変更する。

コマンドラインを編集中なら、ドロップされたファイルやディレクトリの名前がカーソ
ル位置に挿入される。これはExコマンドでそれらの名前を使うのに便利である。特別な
文字(スペース、タブ、ダブルクォート、'|'、MS-Windows以外ではバックスラッシュ
も)はエスケープされる。

==============================================================================
4. GUI選択の作成					*gui-selections*

							*quotestar*
マウス(|gui-mouse-select|を参照)か、あるいはVimのビジュアルモード(|v|を参照)を
使用して、選択を作成できる。'guioptions' に 'a' が指定されているなら、いつ選択
(ビジュアルモードや選択モード)が開始されるとしても、あるいは選択が変更されると
しても、Vimがウィンドウシステムの主要な選択の所有者になる(MS-Windowsで
は|gui-clipboard|が用いられる。X11では|x11-selection|が用いられる。ここの説明
は両方に共通している)。

							*clipboard*
選択を保存するための特別なレジスタがある。それは "* レジスタである。どのテキス
トが選択されているかという情報が(例えばマウスの左ボタンをクリックするなどして)
変更されるか、あるいは他のアプリケーションが選択されたテキストを貼り付けようと
しない限りここには何も書き出されない。使用されるときにはテキストは "* レジスタ
に書き出される。例えば、行を切り取って、それを現在の選択にして、クリップボード
にそれを書き出すためには次のようにする: >

	"*dd

同様に、例えば、マウスの中ボタンをクリックするなどして、他のアプリケーションか
ら選択を貼り付けるときには、選択は始めに "* レジスタに書き出され、それから他の
レジスタと同じように挿入される。例えば、選択(クリップボードの内容)を貼り付ける
には: >

	"*p

X11でこのレジスタを使うには、|x11-selection|も参照。これは深く関連した "+ レジ
スタについても説明している。

あるVimから他の独立したVimにテキストを貼り付けたいときには、選択のタイプ(文
字、行あるいは矩形)もコピーされることに注意する。他のアプリケーションについて
は、タイプは常に文字である。|x11-cut-buffer|を介して得たテキストでも、その選択
のタイプは常に失われる。

'clipboard' オプションに "unnamed" 文字列が含まれているときには、無名レジスタ
は "* レジスタと同じである。したがってコマンドの前に "* を付けずに選択をコピー
し貼り付けることができる。

==============================================================================
5. メニュー						*menus*

まずはユーザーマニュアルの|usr_42.txt|を御覧ください。

5.1 メニューの使用					*using-menus*

基本的には、メニューは単にマッピングのように使用することができる。自分のメ
ニューを好きなだけたくさん定義することができる。
長い間Vimユーザーはメニューを十分に使用してこなかった。しかし自分のメニューや
メニュー項目を追加することは大きな力を秘めている。ある一連のキー操作を覚えられ
ないようなときに最も便利である。

別の言語用にメニューを作成するには、|:menutrans|を参照。

							*menu.vim*
標準のメニューは "$VIMRUNTIME/menu.vim" ファイルから読み込まれる。パスがどこを
指すかについては|$VIMRUNTIME|を参照。ユーザーは自分のメニューを設定することが
できる。その際に標準のメニューを利用するのはいい考えである。メニューに項目を追
加したり、あるいは、標準のメニューが気に入らなければ、全てのメニューを取り除く
ことができる|:unmenu-all|。.vimrcファイル(.gvimrcファイルではない!)にこの行を
追加することで標準のメニューが読み込まれないようにすることもできる: >
	:let did_install_default_menus = 1
メニュー項目のSyntax(シンタックス)も無効にしたいなら: >
	:let did_install_syntax_menu = 1
メニュー項目のSyntax(シンタックス)は欲しいが、利用可能なシンタックスファイルの
一覧はいらないなら(これを読み込むのは多少の時間を必要とするので): >
	:let skip_syntax_sel_menu = 1
Syntax メニューの最初の項目{訳注:「対応形式をメニューに表示」}を使うと、利用可
能な全てのファイルタイプをメニューに表示できる(読み込みに少し時間がかかるかも
しれない)。起動時に全てのファイルタイプが表示されているようにしたければ次の行
を加える: >
	:let do_syntax_sel_menu = 1

<
							*console-menus*
このドキュメントはGUIの項目であるけれども、CUI版のVimでも実際にメニューを使用
することができる。そのときには明示的に|menu.vim|を読み込まなければならないだろ
う。それは標準では設定されない。ほぼ実際のメニューシステムのようにメニューの項
目にアクセスするために 'wildmenu' を設定して|:emenu|コマンドの使用時にコマンド
ライン補完を使用することができる。これをするには、.vimrcファイルに次のコマンド
を付加しておく: >
	:source $VIMRUNTIME/menu.vim
	:set wildmenu
	:set cpo-=<
	:set wcm=<C-Z>
	:map <F4> :emenu <C-Z>
メニューを開始するには<F4>を押す。そのときにはメニューのエントリを選択するため
にカーソルキーを使用することができる。それを実行するには<Enter>を入力する。
キャンセルするには<Esc>を入力する。これはコンパイル時に|+menu|機能を有効にする
必要がある。

							*tear-off-menus*
GTK+とMotifは切取りメニュー(Tear-offメニュー)をサポートする。これは少し変わっ
たメニューで、ポップアップメニューが常に表示されるようなものである。メニューの
ウィンドウのサイズの変更が正確に機能しないなら、これはリソースに "Vim*geometry"
のように設定していることが原因かもしれない。もしそうなら代わりに "Vim.geometry"
を使用する。

Win32 GUIバージョンはMotifの切取りメニューをエミュレートする。Motifユーザーな
ら簡単に違いを確認できるだろうが、同じように便利に使えると思う。|:tearoff|コマ
ンドと|hidden-menus|を利用して、メインのメニューバーに項目を作らずに切取りメ
ニューを作ることができる。


5.2 新しいメニューの作成				*creating-menus*

				*:me*  *:menu*  *:noreme*  *:noremenu*
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
新しいメニュー項目を作るには、":menu" コマンドを使用する。これはほとんど ":map"
のコマンド群と同じだが最初の引数はメニュー項目の名前であり、'.' で区切ったメ
ニューとサブメニューのパスとして与えられる。例えば: >

   :menu File.Save  :w<CR>
   :inoremenu File.Save  <C-O>:w<CR>
   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>

この最後の1つはメニューバーに "Edit" という新しい項目を作る、そしてその上でマ
ウスのボタンを押すと "Big Changes" という項目を含んだメニューが表示されるだろ
う。"Big Changes" は "Delete All Spaces" という項目を含むサブメニューを持って
いて、その項目を選択すると操作が実行される。

メニュー名での特殊文字:
	&	この文字の次の文字はショートカットキーである。どのショートカッ
		トキーも(サブ)メニューの中で1度だけしか使用されていないことを
		確認すること。メニュー名に "&" を入れるには "&&" とする。
	<Tab>	メニューの名前をそこで区切って以降を右詰めにする。実行する操作
		をそろえて表示するのに便利である。使いやすいように文字として
		"<Tab>" をそのまま書けばいいようになっている。本当のTab文字を
		使用するなら、その前にバックスラッシュを付けること!
例: >

   :amenu &File.&Open<Tab>:e  :browse e<CR>

[文字通りタイプする]
(<Alt>キーと同時に)ショートカットキーの "F" を押し、それから "O" を押すと、こ
のメニューを使用できる。Openの項目は "Open     :e" のように表示される。":e" は
右詰めされ、"O" にはショートカットであることを示すために下線が引かれる。

":amenu" コマンドは全てのモードで使えるメニューの項目を1度に定義することができ
る。コマンドを正確に機能させるために、いくつかのモード用に自動的に文字が付加さ
れる:
	モード			前に付加	後ろに付加	~
	ノーマルモード		なし		なし
	ビジュアルモード	<C-C>		<C-\><C-G>
	挿入モード		<C-\><C-O>
	コマンドラインモード	<C-C>		<C-\><C-G>
	演算子未解決モード	<C-C>		<C-\><C-G>

後ろに付加されるCTRL-\ CTRL-Gは 'insertmode' が設定されているときには挿入モー
ドに戻る。|CTRL-\_CTRL-G|を参照。

例: >

   :amenu File.Next	:next^M

は以下と同じである: >

   :nmenu File.Next	:next^M
   :vmenu File.Next	^C:next^M^\^G
   :imenu File.Next	^\^O:next^M
   :cmenu File.Next	^C:next^M^\^G
   :omenu File.Next	^C:next^M^\^G

注意: 挿入モードでは1つのノーマルモードのコマンドに対してだけ機能する。これは
CTRL-Oの仕様による。2つ以上のコマンドを使うには、":imenu" コマンドを使用する必
要がある。どのモードでもテキストを挿入するために式レジスタ('=' レジスタ)を使用
することができる: >

   :amenu Insert.foobar   "='foobar'<CR>P

Note: 'cpoptions' の中の '<' フラグと 'k' フラグが適用される(含まれていたとき
には、<>による特殊キーの書式や生のキーコードは認識されない)。

Note: コマンドラインモードでの<Esc>はマッピングで使用されたときと同様に(入力を
キャンセルするのではなく)コマンドを実行する。これはVi互換である。コマンドライ
ンモードを終了するにはCTRL-Cを使用する。
{訳注: |c_<Esc>|を参照}

						*:menu-<silent>* *:menu-silent*
実行したコマンドをコマンドラインに表示しないようなメニューを定義するには、最初
の引数に "<silent>" を加える。例: >
	:menu <silent> Settings.Ignore\ case  :set ic<CR>
これでこのメニューを使っても ":set ic" はコマンドラインに表示されない。それで
も実行したコマンドの出力は表示される。それを表示しないようにするには、
":silent" を付けてコマンドを実行する: >
	:menu <silent> Search.Header :exe ":silent normal /Header\r"<CR>
"<silent>" は "<special>" や "<script>" の直後に書いてもよい。

					*:menu-<special>* *:menu-special*
'cpoptions' にフラグ "<" が含まれているときでも、メニューを定義する際には <>
記法で特殊なキーを表すことができる。これは 'cpoptions' の副作用が望ましくない
場合に便利である。例: >
	:menu <special> Search.Header /Header<CR>
"<special>" はコマンド :menu の引数の一番最初か、"<silent>" や "<script>" の直
後に書かねばならない。

						*:menu-<script>* *:menu-script*
メニューに指定されたコマンドにはマッピングが適用される。適用しないようにするに
は、":noremenu" コマンド(とそれに類するモード別のコマンド)を使う。スクリプト
ローカルなマッピングを使うには ":menu" コマンドの最初の引数、あるいは
"<silent>" の次に "<script>" と書く。
{訳注: これは<SID>で指定した部分だけがマッピングされる。例:
         nnoremenu <script> AAA.BBB :echo "<SID>LM" "LM"<CR>
         cnoremap <SID>LM 'This is script-local mapping'
         cnoremap LM 'This is not used'
       スクリプトファイルでこのように設定し、メニューのAAA.BBBを実行すると
         'This is script-local mapping' LM
       と表示される。"<SID>LM" はマッピングされ、"LM" はマッピングされていな
       い。}

							*menu-priority*
メニューに優先度を与えることができる。より高い優先度を与えられたメニューほど右
に配置される。優先度は ":menu" コマンドの前の数字で与えれられる。
例: >
	:80menu Buffer.next :bn<CR>

標準のメニューはこれらの優先度を持つ:
	File		10
	Edit		20
	Tools		40
	Syntax		50
	Buffers		60
	Window		70
	Help		9999

優先度を指定しない、あるいはゼロを指定すると、500が用いられる。
ポップアップメニューに対しては優先度は意味を持たない。

メニューの「Help」の項目は、それをサポートしているシステム(MotifとGTK+)では、
メニューバーの右端に寄せて置かれる。GTK+ 2では、メニューのHelpを右端に寄せるの
は今のところユーザーインターフェースデザインの妨げになっているので、もはやサ
ポートされない。

ヘルプメニューの後ろに置くために、9999より高い優先度を使用することができるが、
それは非標準であり、推奨しない。優先度の取り得る値は最高で約32000である。最低
は1である。

							*sub-menu-priority*
同様にサブメニューも配置を指定できる。優先度は、メニュー名の前に、ドット区切り
の優先度のリストとして指定する: >
	:menu 80.500 Buffer.next :bn<CR>
サブメニューの優先度を与える必要があるのは、項目を配置する位置を指定したいとき
だけである。例えば、他の項目の前にサブメニューを置くには: >
	:menu 80.100 Buffer.first :brew<CR>
あるいは他の項目の後にサブメニューを置いて、標準設定の優先度を持つ項目がその前
に置かれるようにするには: >
	:menu 80.900 Buffer.last :blast<CR>
数字が抜けているときには、標準設定の500が用いられる: >
	:menu .900 myMenu.test :echo "text"<CR>
メニューの優先度はメニューを新しく生成するときだけ用いられる。すでにあるとき、
例えば、別のモードで定義されていたときには、優先度は変更されない。したがって、
優先度はメニューを最初に定義するときだけ与える必要がある。
例外はポップアップメニューである。各モード(ノーマルモード、演算子未解決モー
ド、ビジュアルモード、挿入モード、コマンドラインモード)に別々のメニューがあ
る。これらのメニューは順序が異なってもよい。これはメニューバーのメニューとは異
なる。メニューバーのメニューは全てのモードで同じ順序である。
NOTE: サブメニューの優先度は現在全てのGUIのバージョンで機能する訳ではない。

							*menu-separator* *E332*
メニューの各項目は特殊なメニュー項目を使って区切ることができる。それはシステム
によるが、線や点線として表示される。そのような項目の名前は '-' で始めて '-' で
終わるように定義する。間には一意な名前を挟むことができる。普通のメニュー項目と
同様に優先度を設定することもできる。
例: >
	:menu Example.item1	:do something
	:menu Example.-Sep-	:
	:menu Example.item2	:do something different
Note: 区切りの定義にはコマンドの指定が必要である。そのメニュー項目は選択するこ
とができないので、内容はなんでも構わない。ただ単にコロン(:)を1つ書いておくだけ
でいい。

							*gui-toolbar*
ツールバーは今のところWin32、Athena、Motif、GTK+ (X11)、Photon GUIで利用可能で
ある。いずれは他のGUIでも使えるようになるだろう。標準のツールバーはmenu.vimで
定義されている。
ツールバーの表示は 'guioptions' の文字 'T' によって制御される。したがって、メ
ニューとツールバーを同時に、あるいはどちらかだけを表示することもできるし、両方
とも非表示にすることもできる。
表示方法は 'toolbar' オプションで変更できる。画像かテキスト、もしくは両方を表
示するかを選択できる。

							*toolbar-icon*
ツールバーは、1つのレベルだけを持つToolBarと呼ばれる特別なメニューとして定義さ
れている。Vimはこのメニューの項目を以下のように解釈する:
1)  "icon=" 引数が与えられたときは、そのファイルが使われる。ファイル名にはフル
    パスか、ファイル名のみを指定する。後者の場合には、そのファイルは3)の場合と
    同じように 'runtimepath' の "bitmaps" ディレクトリから検索される。例: >
	:amenu icon=/usr/local/pixmaps/foo_icon.xpm ToolBar.Foo :echo "Foo"<CR>
	:amenu icon=FooIcon ToolBar.Foo :echo "Foo"<CR>
<   Note: 最初の例では拡張子も含めている。2番目の例では拡張子は省略されてい
    る。
    ファイルが開けなければ2)を試す。
    ファイル名に空白を含めるにはバックスラッシュでエスケープする。
    メニューの優先度はiconの引数の後に指定する: >
	:amenu icon=foo 1.42 ToolBar.Foo :echo "42!"<CR>
2)  'BuiltIn##' (##は数字である) という名前の項目はVimで利用可能な組み込みの
    ビットマップの番号##を使用するとみなされる。今のところ、0から30までの31個
    の一般的な編集操作のものが用意されている|builtin-tools|: >
	:amenu ToolBar.BuiltIn22 :call SearchNext("back")<CR>
3)  2)以外の名前を持つ項目は最初に 'runtimepath' の "bitmaps" ディレクトリから
    検索される。もしあればそのビットマップファイルがツールバーボタンのイメージ
    として用いられる。正確なファイル名はOS特有であることに注意する。例えば、
    Win32でのコマンド >
	:amenu ToolBar.Hello :echo "hello"<CR>
<   は、'hello.bmp' ファイルを検索するだろう。GTK+/X11では 'Hello.xpm' である。
    GTK+ 2では 'Hello.png'、'Hello.xpm'、'Hello.bmp' がチェックされ、最初に見
    つかったものが使われる。
    MS-WindowsとGTK+ 2ではビットマップはボタンの大きさに合わせて拡大縮小され
    る。MS-Windowsでは縦18横18のサイズがちょうどいいだろう。
    MS-Windowsではビットマップは16色の標準パレットを使った物である。明るい灰色
    はウィンドウのフレームの色に変更され、暗い灰色はウィンドウの影の色に変更さ
    れる。システムに依存するが、16色よりも色が多くても問題ないだろう。
4)  ビットマップがまだ見つからないならば、Vimは組み込みの名前のリス
    トに対して同等のものを探す。どの組み込みのボタンイメージも名前を持ってい
    る。だから、コマンド >
	:amenu ToolBar.Open :e
<   は、open.bmpが存在しなければ、組み込みの "open a file" ボタンイメージを表
    示するだろう。全ての組み込みの名前はmenu.vimで用いられているので確認できる。
5)  全てが失敗すると、空白だが、ちゃんと機能する、ボタンが表示される。

							*builtin-tools*
番号  名前		通常の動作  ~
00    New		新しいウィンドウを開く
01    Open		現在のウィンドウで開くためにファイルをブラウズする
02    Save		バッファをファイルに保存する
03    Undo		最後の変更を取り消す
04    Redo		最後の取り消した変更をやり直す
05    Cut		選択されたテキストを削除しクリップボードへ送る
06    Copy		選択されたテキストをクリップボードにコピーする
07    Paste		クリップボードからテキストをペーストする
08    Print		現在のバッファを印刷する
09    Help		Vimの組み込みのヘルプでバッファを開く
10    Find		検索コマンドを開始する
11    SaveAll		全ての修正されたバッファをファイルに保存する
12    SaveSesn		現在の状態をセッションファイルに保存する
13    NewSesn		新しいセッションファイルに保存する
14    LoadSesn		セッションファイルを読み込む
15    RunScript		Vimスクリプトとして実行するためにファイルをブラウズ
			する
16    Replace		置換コマンドのためのプロンプト
17    WinClose		現在のウィンドウを閉じる
18    WinMax		現在のウィンドウに使用する行数を最大にする
19    WinMin		現在のウィンドウに使用する行数を最小にする
20    WinSplit		現在のウィンドウを分割する
21    Shell		シェルを開始する
22    FindPrev		後方に再検索する
23    FindNext		前方に再検索する
24    FindHelp		ヘルプを検索する単語のためのプロンプト
25    Make		makeを実行し最初のエラーにジャンプする
26    TagJump		カーソルの下のtagにジャンプする
27    RunCtags		現在のディレクトリのファイルに対してtagsを作成する
28    WinVSplit		現在のウィンドウを縦分割する
29    WinMaxWidth	現在のウィンドウの幅を最大化する
30    WinMinWidth	現在のウィンドウの幅を最小化する

					*hidden-menus* *win32-hidden-menus*
Win32とGTK+ GUIでは、']' で始まるメニュー名はメインのメニューバーから除外され
る。それを表示するには|:popup|か|:tearoff|コマンドを使用しなければならない。

							*popup-menu*
Win32、GTK+、Motif、Athena、Photon GUIでは、特別なメニュー "PopUp" を定義する
ことができる。これは、'mousemodel' がpopupあるいはpopup_setposに設定されている
ときに、マウスの右ボタンが押されると表示されるメニューである。


5.3 メニューの定義を表示する				*showing-menus*

メニューがどのように定義されているかを確認するには、(":map" コマンドでするのと
全く同様に)menuコマンドの後にたった1つの引数を指定するだけである。指定されたメ
ニューがサブメニューならば、その階層の下の全てのメニューが表示される。:menuの
後に引数を与えなければ、適切なモードに対する全てのメニュー項目が表示される(例
えば、コマンドラインモードに対して:cmenu)。

メニュー項目の一覧には、指定されたコマンドの前に特別な文字が表示される:
*	そのメニュー項目は再マッピングを避けるために "nore" を付けて定義された
&	そのメニュー項目は再マッピングをスクリプトローカルに限定するために
	"<script>" を付けて定義された
-	そのメニュー項目は非表示である

NOTE: menuコマンドでメニューの名前を入力しているときに<Tab>を打つと名前が補完
される(設定による)。


5.4 メニューの実行					*execute-menus*

						*:em*  *:emenu* *E334* *E335*
:[range]em[enu] {menu}		コマンドラインから{menu}を実行する。
				通常はノーマルモードのメニューを実行する。実行
				範囲が与えられたときは、ビジュアルモードのメ
				ニューを実行する。
				<c-o>から実行されたときは、挿入モードのメ
				ニューを実行する。例: >
	:emenu File.Exit

CUI版のvimをWANT_MENUを定義してコンパイルしたなら、:emenuを使ってGUIのときと同
じように便利なメニューを使用できる。その際に 'wildmenu' を設定しておくと便利で
ある。使用例は|console-menus|を参照。

範囲を指定するとき、'<,'> と指定すると、最後にビジュアル選択した範囲に対して実
行される。


5.5 メニューの削除					*delete-menus*

						*:unme*  *:unmenu*
						*:aun*   *:aunmenu*
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
メニュー項目やサブメニュー全体を削除するには、unmapコマンドによく似たunmenuコ
マンドを使用する。例えば: >
    :unmenu! Edit.Paste

これは挿入モードとコマンドラインモードでの操作をEditメニューの項目Pasteから取
り除く。

NOTE: umenuコマンドでメニューの名前を入力しているときに<Tab>を打つと名前が補完
される(設定による)。

全てのメニューを取り除くには次のようにする:	 *:unmenu-all*  >
	:unmenu *	" ノーマルモードとビジュアルモードの全てのメニューを取
			" り除く
	:unmenu! *	" 挿入モードとコマンドラインモードの全てのメニューを取
			" り除く
	:aunmenu *	" 全てのモードの全てのメニューを取り除く

メニューバーを非表示にするには: >
	:set guioptions-=m


5.6 メニューを無効にする				*disable-menus*

						*:menu-disable* *:menu-enable*
メニューを削除するのではなくて、一時的に無効にしたいときは、":menu" コマンドに
"disable" キーワードを指定する。有効にするには "enable" キーワードを指定する。
例: >
	:menu disable &File.&Open\.\.\.
	:amenu enable *
	:amenu disable &Tools.*

このコマンドはmenuコマンド群が影響する各モードに適用される。"&" は翻訳された名
前にも適用するために必要である。
引数に "*" を使うと、全てのメニューに作用する。そうでなければ、指定したメニュー
項目とそのサブメニューに作用する。


5.7 メニューの例					*menu-examples*

これはメニューを使ってメニュー項目を追加する方法の例である! カーソルの下のキー
ワードをメニュー項目に追加することができる。作業用にレジスタ "z" を使用してい
る。 >

  :nmenu Words.Add\ Var		wb"zye:menu! Words.<C-R>z <C-R>z<CR>
  :nmenu Words.Remove\ Var	wb"zye:unmenu! Words.<C-R>z<CR>
  :vmenu Words.Add\ Var		"zy:menu! Words.<C-R>z <C-R>z <CR>
  :vmenu Words.Remove\ Var	"zy:unmenu! Words.<C-R>z<CR>
  :imenu Words.Add\ Var		<Esc>wb"zye:menu! Words.<C-R>z <C-R>z<CR>a
  :imenu Words.Remove\ Var	<Esc>wb"zye:unmenu! Words.<C-R>z<CR>a

(指定するコマンドには<>記法を使える。このテキストをそのままコピー/ペーストして
試してみたり、gvimrcに書き加えることができる。"<C-R>" は CTRL-R であり、"<CR>"
は <CR> キーである。|<>|)


5.8 ツールチップとメニューチップ

ユーザーマニュアルの|42.4|を参照すること。

							*:tmenu* *:tm*
:tm[enu] {menupath} {rhs}	メニューやツールバーにチップを定義する。
				{X11とWin32 GUIのみ}

:tm[enu] [menupath]		メニューチップを一覧表示する。
				{X11とWin32 GUIのみ}

							*:tunmenu* *:tu*
:tu[nmenu] {menupath}		メニューやツールバーのチップを削除する。
				{X11とWin32 GUIのみ}

メニューの項目にチップが定義されていて、マウスがその項目の上にあるとき、その
チップがコマンドラインに表示される。それはWindows標準でステータスバーに表示さ
れるメニューヒントに似ている(Vimがコマンドラインモードのときは除く、そのときは
もちろん何も表示されない)。
ツールバーの項目にチップが定義されているときは、慣習にしたがって、マウスがその
ボタンの上で止まったときにツールチップが表示される。その表示に使う色を変更する
にはハイライトグループの|hl-Tooltip|を設定する。

チップはメニューの各項目に定義できる。例えば、次のようにメニュー項目を定義した
とき: >
	:amenu MyMenu.Hello :echo "Hello"<CR>
次のようにチップを定義する: >
	:tmenu MyMenu.Hello Displays a greeting.
そして次のように削除する: >
	:tunmenu MyMenu.Hello

ツールチップは今のところX11とWin32 GUIでサポートされている。近い内に他のGUI環
境でもサポートされるだろう。

":tmenu" コマンドは他のmenuコマンド群と同じように機能し、同じ引数をとる。
":tunmenu" は他のunmenuコマンド群と同じようにメニューチップを削除する。

メニュー項目が無効になる(例えば、全てのモードでその動作が削除される)ときには、
Vimはメニューチップ(と項目)を削除する。つまり:aunmenuでメニュー項目を削除する
ときには、:tunmenuする必要はないということである。


5.9 ポップアップメニュー

Win32とGTK+ GUIでは、カーソルの位置にメニューをポップアップ表示することができ
る。これは「PopUp」メニューと同じように動作し、どんなメニューでも表示すること
ができる。

このコマンドは後方互換性のために残されていて、使用することは推奨されない。なぜ
ならこのコマンドのふるまいは好ましくないからである。

							*:popup* *:popu*
:popu[p] {name}			メニュー項目{name}をポップアップ表示する。その
				メニューは少なくとも1つ以上の項目を持っている
				必要がある。メニューバーに表示されている必要は
				ない。

:popu[p]! {name}		上記と同様だが、カーソル位置でなくマウスポイン
				タの位置にメニューを表示する。

例: >
	:popup File
とすると "File" メニューを(もしあれば)カーソル位置に表示させる。! が使われたと
きはマウスポインタの位置に表示させる。 >

	:amenu ]Toolbar.Make	:make<CR>
	:popup ]Toolbar
これはメインのメニューバーにメニュー項目を作らずにポップアップメニューを作成す
る。

Note: ']' で始まるメニュー項目はメニューバーに表示されない。

==============================================================================
6. 付記							*gui-extras*

このセクションではGUIに関連したその他の特徴を説明する。

- GUIでは、キーコードは<Esc>で始まらないため、エスケープを入力した後に1秒待た
  なくてよい。

- GUIでCTRL-Vに続いて特殊なキーを入力すると "<Key>" のように入力される。そのよ
  うな特殊なキーは内部で意味を持たないためである。修飾キーを同時に押して
  "<Modifiers-Key>" を得ることもできる。
{訳注: 例えば、挿入モードでCTRL-Vに続いてDelキーを押すと "<Del>" (見た通り5文
       字)が入力される。Alt(META)キーを押しながらDelキーを押すと "<M-Del>" が
       入力される。Shiftキーなら "<S-Del>"。}

- GUIでは、修飾キーのSHIFT、CTRL、ALT(META)は特殊キーやマウスイベントのマッピ
  ングで使用できる。例えば、:map <M-LeftDrag> <LeftDrag>

- GUIでは、いくつかの普通のキーにマッピング等で修飾キーを付けて使用できる。そ
  のようなキーは<Space>、<Tab>、<NL>、<CR>、<Esc>である。

- GUIが使われているかどうかをVimスクリプト内で調べるには次のようにする: >

	if has("gui_running")
	   echo "yes, we have a GUI"
	else
	   echo "Boring old console"
	endif

<							*setting-guifont*
- さまざまなシステム上で同一の vimrc ファイルを使うときは、次のようにして各
  GUI に対する固有のオプションを設定することができる: >

	if has("gui_running")
	    if has("gui_gtk2")
		:set guifont=Luxi\ Mono\ 12
	    elseif has("x11")
		" Also for GTK 1
		:set guifont=*-lucidatypewriter-medium-r-normal-*-*-180-*-*-m-*-*
	    elseif has("gui_win32")
		:set guifont=Luxi_Mono:h12:cANSI
	    endif
	endif

推奨される日本語フォントは MS Mincho である。MS Mincho についての情報はここで
みつかる:
http://www.lexikan.com/mincho.htm

==============================================================================
7. シェルコマンド					*gui-shell*

X11 GUIでは外部プログラムはgvimウィンドウの中で実行される。
|gui-pty|を参照。

警告: X11 GUIで外部プログラムを実行することは常にうまく動作するとは限らない。
"ls"、"grep"、"make" のような一般的なプログラムはたいていうまく機能する。"less"
や "ispell" のように高度なターミナルを要求するプログラムはうまく機能しないだろ
う。あるものはハングさえするかもしれないし、他のターミナルからkillする必要があ
るかもしれない。だから気を付けて!

Win32 GUIでは外部プログラムは別のウィンドウで実行される。
|gui-shell-win32|を参照。

 vim:tw=78:sw=4:ts=8:ft=help:norl:
