*usr_28.txt*	For Vim バージョン 7.4.  Last change: 2008 Jun 14

		     VIM USER MANUAL - by Bram Moolenaar

				   折り畳み


構造化されたテキストはいくつかのセクションから構成され、セクションはさらにサブ
セクションに分かれています。折り畳みを使うとセクションを一行で表示できます。折
り畳まれた行にはセクションの概要が表示されます。この章では折り畳みの使い方を説
明します。

|28.1|	折り畳みとは
|28.2|	手動で折り畳む
|28.3|	折り畳みを使って作業する
|28.4|	折り畳みの保存と復元
|28.5|	インデントで折り畳む
|28.6|	マーカーで折り畳む
|28.7|	構文で折り畳む
|28.8|	スクリプトで折り畳む
|28.9|	変更のない行を折り畳む
|28.10|	どれを使えばいいの?

次章: |usr_29.txt|  プログラムの中を移動する
前章: |usr_27.txt|  検索コマンドと正規表現
目次: |usr_toc.txt|

==============================================================================
*28.1*	折り畳みとは

折り畳みとは、バッファ中の複数の行を画面上で一行に表示するための機能です。紙を
折り畳んで短くするような感じです。

	+------------------------+
	| line 1		 |
	| line 2		 |
	| line 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / folded lines		  /
	/________________________/
	| line 12		 |
	| line 13		 |
	| line 14		 |
	+------------------------+

バッファ内のテキストが消えるわけではありません。折り畳みが影響するのは画面の表
示だけです。

折り畳みを使うと文章構成を把握するのが簡単になります。折り畳まれたセクションは
一行で表示され、その行にはセクションの概要が表示されます。

==============================================================================
*28.2*	手動で折り畳む

実際に試してみましょう。どこかの段落にカーソルを動かして次のように入力します:
>
	zfap

段落が、ハイライトされた一行に置き換わります。それが折り畳みです。|zf| はオペ
レータです。|ap| はテキストオブジェクトによる範囲指定です。|zf| はどのカーソル
移動コマンドとも組み合わせることができます。カーソルが移動した範囲が折り畳みの
対象になります。|zf| はビジュアルモードでも使えます。

再びテキストを表示するには、次のコマンドで折り畳みを開きます: >

	zo

次のコマンドで折り畳みを閉じることができます: >

	zc

折り畳み関連のコマンドはすべて "z" で始まります。この文字は、紙を折り畳んで横
から見た図に見えますよね。"z" の後ろにはコマンドが連想しやすいような文字が割り
当てられています。

	zf	折り畳む (Fold)
	zo	折り畳みを開く (Open)
	zc	折り畳みを閉じる (Close)

折り畳みは入れ子にできます。折り畳まれた行を含んだ範囲をさらに折り畳むことがで
きます。例えば、このセクションの段落をそれぞれ折り畳み、そして、この章のセク
ション全体を折り畳むということができます。実際に試してください。折り畳みを開い
たとき、その中にある折り畳みは、閉じたときと同じ開閉状態のままになっています。

いくつかの折り畳みを作ったときに、すべての折り畳みを開きたくなった場合、それぞ
れの折り畳みを "zo" で開いていくこともできますが、次のコマンドでもっと簡単にで
きます: >

	zr

折り畳みが減少 (Reduce) します。その逆は "zm" です: >

	zm

折り畳みが増加 (More) します。"zr" と "zm" は入れ子になった折り畳みを一階層ず
つ開閉できます。

入れ子になった折り畳みをいっぺんに開きたい場合は次のコマンドを使います: >

	zR

すべての折り畳みが開くまで、折り畳みが減少 (Reduce) します。すべての折り畳みを
閉じるには: >

	zM

折り畳みが次々と (More and More) 閉じます。

|zn| コマンドで折り畳みを無効にできます。無効になった折り畳みは |zN| で元に戻
ります。|zi| で無効と有効を交互に切り替えられます。次のように使うと便利です:
- ファイルの構造を確認するために折り畳みを作成する
- 作業したい場所に移動する
- |zi| で折り畳みを無効にして編集作業をする
- |zi| で折り畳みを有効にして別の場所に移動する

手作業で折り畳みを作成するための詳しい説明はリファレンスマニュアルを参照してく
ださい: |fold-manual|

==============================================================================
*28.3*	折り畳みを使って作業する

折り畳みが閉じているとき、"j" や "k" などのコマンドでその上を移動できます。閉
じた折り畳みは一行の空行のように扱われます。つまり折り畳まれたテキストの上を素
早く移動できます。

折り畳まれたテキストは、それが一つの行であるかのように、ヤンクしたり削除したり
できます。これは例えばプログラムの関数を並べ替えたりするときに便利です。まず
'foldmethod' を正しく設定し、それぞれの関数が適切に折り畳まれるようにします。
そして、"dd" で関数を削除し、カーソルを移動して、"p" でプットします。関数の一
部が折り畳みからはみ出している場合はビジュアルモードを使います:
- 移動させたい範囲の最初の行に移動
- "V" でビジュアルモードを開始
- 移動させたい範囲の最後の行に移動
- "d" で選択範囲を削除
- カーソルを移動して、"p" でテキストをプットする

折り畳みを設定した場所 (つまり |zo| コマンドが機能する場所) を覚えておくのは大
変です。次のコマンドで折り畳みの場所を確認できます: >

	:set foldcolumn=4

ウィンドウの左側に折り畳みの場所が表示されます。閉じた折り畳みは "+" で表示さ
れます。開いた折り畳みは、一行目が "-" で表示され、それ以降は "|" で表示されま
す。

マウスで "+" の部分をクリックすると折り畳みが開きます。"-" や "|" の部分をク
リックすると折り畳みが閉じます。

現在行の折り畳みをすべて開くには |zO| を使います。
現在行の折り畳みをすべて閉じるには |zC| を使います。
現在行の折り畳みを削除するには |zd| を使います。
現在行の折り畳みをすべて削除するには |zD| を使います。

挿入モードでは現在行の折り畳みは絶対に閉じません。入力した文字は必ず表示されま
す。

カーソルをジャンプさせたり左右に動かしたりしたとき、折り畳みは自動的に開きま
す。例えば "0" コマンドを使うと現在行の折り畳みが開きます ('foldopen' に "hor"
が含まれている場合のみ。初期設定では含まれています)。どのコマンドを使うと折り
畳みが開くかは 'foldopen' オプションで設定できます。カーソルが乗っている行の折
り畳みを常に開いておきたい場合は次のように設定します: >

	:set foldopen=all

警告: 閉じた折り畳みの上に移動することはできなくなります。この設定を一時的に使
い、元に戻したくなったら次のようにします: >

	:set foldopen&

折り畳みを自動的に閉じたい場合は次のようにします: >

	:set foldclose=all

カーソルが乗っていないすべての折り畳みに 'foldlevel' が適用されます。このよう
な動作は好き嫌いがあるので実際に試してみてください。折り畳みを増加させたい場合
は |zm| を、減少させたい場合は |zr| を使ってください。

折り畳みはウィンドウローカルな設定です。同じファイルを二つのウィンドウで表示し
て、片方では折り畳みを使い、もう片方では普通に表示するということができます。あ
るいは、片方ですべての折り畳みを閉じ、もう片方ですべての折り畳みを開くこともで
きます。

==============================================================================
*28.4*	折り畳みの保存と復元

ファイルを破棄すると折り畳みの情報は失われてしまいます。後で同じファイルを開い
たとき、折り畳みの開閉状態は初期状態に戻っています。手動で作成した折り畳みは失
われます。折り畳みを保存するには |:mkview| コマンドを使います: >

	:mkview

ファイルの表示に関する設定が保存されます。保存される情報の種類は 'viewoptions'
オプションで設定できます。
後で同じファイルを開いたときに保存したビューを復元できます: >

	:loadview

一つのファイルにつき 10 個までのビューを保存できます。例えば、現在の設定を 3
番に保存して 2 番の設定をロードするには次のようにします: >

	:mkview 3
	:loadview 2

Note: 行を挿入したり削除したりすると保存していたビューが使えなくなるかもしれま
せん。ビューの保存場所は 'viewdir' オプションで決まります。必要な場合は自分で
ビューを削除してください。

==============================================================================
*28.5*	インデントで折り畳む

|zf| を使って折り畳みを定義するのは大変です。テキストが階層的にインデントされ
ている場合は、それを使って折り畳むことができます。インデントの深さにしたがって
折り畳みが作成され、大きくインデントされた部分は折り畳みが入れ子になります。こ
の方法は多くのプログラミング言語で使うことができます。

'foldmethod' オプションを次のように設定してください: >

	:set foldmethod=indent

|zm| や |zr| を使って折り畳みを増減できるようになりました。以下の例文を使うと
簡単に確認できます:

この行はインデントされていない
	この行は一段インデントされている
		この行は二段インデントされている
		この行は二段インデントされている
	この行は一段インデントされている
この行はインデントされていない
	この行は一段インデントされている
	この行は一段インデントされている

Note: インデントの量と折り畳みの深さの対応は 'shiftwidth' オプションで決まりま
す。'shiftwidth' の幅を単位としてインデントが深くなると折り畳みが深くなります。
これを折り畳みレベルと呼びます。

|zr| や |zm| コマンドを使ったとき、実際には 'foldlevel' の値を増減させているの
です。自分で設定することもできます: >

	:set foldlevel=3

'shiftwidth' の幅を単位として、インデントが三段より深い階層の折り畳みが閉じま
す。設定した値より深い階層の折り畳みが閉じる仕組みです。'foldlevel' を 0 に設
定するとすべての折り畳みが閉じます。|zM| を使うと 'foldlevel' が 0 に設定され
ます。|zR| を使うと 'foldlevel' がファイル内の最も深い折り畳みレベルに設定され
ます。

つまり、折り畳みを開閉する方法は二つあります
(A) 折り畳みレベルを設定する方法。
    この方法は、テキストを "ズームアウト" して文章の構成を眺め、カーソルを動か
    し、テキストに "ズームイン" するような使い方ができます。

(B) |zo| や |zc| を使って個々の折り畳みを開閉する方法。
    他の折り畳みは閉じたままで、必要な折り畳みだけを開くことができます。

二つの方法を組み合わせることもできます。|zm| で全体的に折り畳みを閉じてから
|zo| で特定の折り畳みだけを開く。あるいは、|zR| ですべての折り畳みを開いてから
|zc| で特定の折り畳みを閉じるなど。

'foldmethod' が "indent" に設定されている場合は手動で折り畳みを定義できません。
インデントと折り畳みレベルの関係を保つためです。

インデントによる折り畳みの詳しい説明はリファレンスマニュアルを参照してくださ
い: |fold-indent|

==============================================================================
*28.6*	マーカーで折り畳む

テキストにマーカーを書いて、折り畳みの始点と終点を指定できます。この方法を使う
と折り畳みの範囲を明示的に指定できます。ただし、テキストに変更を加える必要があ
ります。

次のように設定してください: >

	:set foldmethod=marker

C 言語を使った例文:

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

マーカーの直前に書かれたテキストが折り畳まれた行に表示されるので、折り畳まれた
テキストがどのような内容なのかを知ることができます。

テキストを移動したときなどにマーカーの対応がずれてしまうと面倒です。番号付き
マーカーを使うと手間が省けます。例:

	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

番号付きマーカーを書いた場所から指定レベルの折り畳みが開始します。指定レベルよ
り高いレベルの折り畳みをその場所で区切るという効果もあります。番号付きマーカー
は開始マーカーを指定するだけで折り畳みを定義できます。折り畳みを明示的に止めた
い場合は終了マーカーを設定する必要があります。

マーカーによる折り畳みの詳しい説明はリファレンスマニュアルを参照してください:
|fold-marker|

==============================================================================
*28.7*	構文で折り畳む

ファイルを表示するとき、ファイルの種類に応じた構文ファイルが使われます。構文
ファイルにはファイルをカラー表示するための定義が書かれています。例えばこのヘル
プファイルは "help" 構文ファイルを使ってカラー表示されています (カラー端末を
使っているなら)。
構文ファイルで構文を定義するときに "fold" 属性を指定して折り畳み領域を定義する
ことができます。構文ファイルを書くのは大変ですが、一度作ってしまえば、後は自動
的に折り畳みが作成されるようになります。
自分で構文ファイルを作成することはほとんどないと思うので、詳しい説明は省きま
す。折り畳みを開いたり閉じたりする方法は他と変わりません。ファイルを開くと自動
的に折り畳みが作成されます。

構文による折り畳みの詳しい説明はリファレンスマニュアルを参照してください:
|fold-syntax|

==============================================================================
*28.8*	スクリプトで折り畳む

これはインデントによる折り畳みと似ていますが、インデントではなくユーザーが定義
した関数を使って折り畳みレベルを計算します。テキストの内容から折り畳みレベルを
判断するようなことができます。例えば、メールでは引用したテキストの前に ">" を
付けます。それを折り畳むには次のようにします: >

	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

次のようなテキストが折り畳まれます。試してみてください:

> 相手が書いた文章
> 相手が書いた文章
> > 相手が引用した私の文章
> > 相手が引用した私の文章

上記の 'foldexpr' の設定を説明します (呼び出しの深い順番):
   getline(v:lnum)			現在行を取得
   substitute(...,'\\s','','g')		行から空白を削除
   substitute(...,'[^>].*','','')	先頭の '>' 以降を全て削除
   strlen(...)				文字の長さ('>' の数)を数える

Note: ":set" コマンドでは、空白とダブルクォートとバックスラッシュのすべてに対
してバックスラッシュを前置する必要があります。よくわからないときは: >

	:set foldexpr

このコマンドで実際に設定された値を確認してください。複雑な式を書いていてそれを
修正したい場合は、コマンドライン補完を使ってください: >

	:set foldexpr=<Tab>
<
<Tab> は実際の Tab キーです。現在の設定値が入力されるので、それを編集できます。

複雑な式を使いたい場合はその処理を関数にして、'foldexpr' からはその関数を呼ぶ
ように設定してください。

スクリプトにより折り畳みの詳しい説明はリファレンスマニュアルを参照してください:
|fold-expr|

==============================================================================
*28.9*	変更のない行を折り畳む

'diff' オプションと合わせて使うと便利です。|vimdiff| コマンドを使ったときもこ
の設定が適用されます。例: >

	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

同じファイルの別バージョンを表示しているすべてのウィンドウでこの設定を実行して
ください。同じ部分は折り畳まれ、違いのある行だけが表示されるようになります。

詳細は |fold-diff| 参照。

==============================================================================
*28.10* どれを使えばいいの?

いろんな方法があるのでどれを使えばいいか悩んでしまいますね。残念ながら完璧な答
えはありません。いくつかヒントを示します。

編集したい言語の構文ファイルが折り畳みに対応している場合は、それを使うのがおそ
らくベストです。あるいは自分で書いてみるのもいいかもしれません。構文ファイルの
作成には検索パターンの詳しい知識が必要です。簡単な仕事ではありませんが、それが
動作するようになれば、手動で折り畳みを定義する必要がなくなります。

テキストのフォーマットが不定な場合は手動で折り畳みを定義してください。
|:mkview| を使えば折り畳みを保存したり復元したりできます。

マーカーを使う方法はファイルにマーカーを書き込む必要があります。他の人とファイ
ルを共有したり、社内のコーディング規約に従う必要がある場合は使えないかもしれま
せん。
マーカーの利点は折り畳みを明示的に設置できることです。折り畳みをカット&ペース
トしたときに前後の不要な行が変更されたりしません。折り畳まれた行に表示されるコ
メントを指定することもできます。

インデントによる折り畳みはたいていのファイルで機能しますが、うまく機能しない場
合もあります。他の方法が使えない場合に使ってください。しかしアウトラインを表示
する方法としては非常に便利です。'shiftwidth' の幅ずつインデントを付けて折り畳
みレベルを指定します。

スクリプトを使った方法はほとんどの構造化されたテキストを折り畳むことができま
す。設定方法もシンプルです。折り畳みの開始と終了を認識するのが容易な場合は特に
簡単です。
この方法で折り畳みを定義したときに思ったとおりの折り畳みが作成されなかった場合
は "manual" に切り替えてみてください。設定を変更しても折り畳みは削除されないの
で、そのまま手動で折り畳みを削除したり追加したりできます。

==============================================================================

次章: |usr_29.txt|  プログラムの中を移動する

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
