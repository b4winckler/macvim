*eval.txt*	For Vim バージョン 7.3.  Last change: 2013 May 21


		VIMリファレンスマニュアル    by Bram Moolenaar


Vimスクリプト				*expression* *expr* *E15* *eval*

Vimスクリプトの利用についてはユーザマニュアルの41章|usr_41.txt|でも解説されて
いる。

注意:Vimスクリプトはコンパイル時に無効化できる。もしそうなっているとこのドキュ
メントに書かれている事は有効ではない。|+eval|と|no-eval-feature|を参照。

1.  変数		|variables|
    1.1 変数の型
    1.2 関数への参照			|Funcref|
    1.3 リスト				|Lists|
    1.4 辞書				|Dictionaries|
    1.5 変数について補足		|more-variables|
2.  式の文法		|expression-syntax|
3.  内部変数		|internal-variables|
4.  組み込み関数	|functions|
5.  関数定義		|user-functions|
6.  波括弧{}変数	|curly-braces-names|
7.  コマンド		|expression-commands|
8.  例外処理		|exception-handling|
9.  例			|eval-examples|
10. +eval機能が無効	|no-eval-feature|
11. サンドボックス	|eval-sandbox|
12. テキストロック	|textlock|

{Vi にはこれらのコマンドはない}

==============================================================================
1. 変数							*variables*

1.1 変数の型 ~
							*E712*
変数には6種類の型がある:

数値		32ビットまたは64ビットの符号有整数。|expr-number| *Number*
		例: -123 0x10 0177

浮動小数点数	浮動小数点数。|floating-point-format| *Float*
		{|+float| 機能つきでコンパイルされたときのみ}
		例: 123.456  1.15e-6  -1.1e3

文字列		終端がNUL文字である8ビットの符号無し文字(バイト)。
		|expr-string| 例: "ab\txx\"--"  'x-z''a,c'

Funcref		関数への参照 |Funcref|。
		例: function("strlen")

リスト		要素の順序つきの列 |List|。
		例: [1, 2, ['a', 'b']]

辞書		順序を持たない連想配列: 各要素はキーと値を持つ。|Dictionary|
		例: {'blue': "#0000ff", 'red': "#ff0000"}

数値と文字列は文脈に応じて相互に変換される。

数値から文字列への変換は数字のASCII表現によって行われる。例:
	数値 123	-->	文字列 "123" ~
	数値 0		-->	文字列 "0" ~
	数値 -1		-->	文字列 "-1" ~
							*octal*
文字列から数値への変換は最初の数字を用いて数値に変換する。16進表記 "0xf9" や
8進表記 "017" も認識される。文字列が数字で始まらない場合結果は0となる。例:
	文字列 "456"	-->	数値 456 ~
	文字列 "6bar"	-->	数値 6 ~
	文字列 "foo"	-->	数値 0 ~
	文字列 "0xf1"	-->	数値 241 ~
	文字列 "0100"	-->	数値 64 ~
	文字列 "-8"	-->	数値 -8 ~
	文字列 "+8"	-->	数値 0 ~

文字列を強制的に数値に変換するには0を足す: >
	:echo "0100" + 0
<	64 ~

先頭の0によって8進数とみなされるのを防いだり、異なる基数を使うには|str2nr()|を
使う。

ブール(真理値)演算には数値が使われる。0は偽を意味し、非0は真を表す。

Note 次のコマンドをみると >
	:if "foo"
"foo" は0に変換され、それは偽を意味する。文字列が空ではないか調べるためには
empty()を使用して次のようにする。 >
	:if !empty("foo")
<				*E745* *E728* *E703* *E729* *E730* *E731*
リスト、辞書、Funcrefは自動的に変換されない。

							*E805* *E806* *E808*
数値と浮動小数点数をまぜると浮動小数点数になる。それ以外には浮動小数点数への自
動的な変換は存在しない。文字列から浮動小数点数へは str2float() を使い、浮動小
数点数から文字列へは printf() を、浮動小数点数から数値へは float2nr() を使う。

						*E706* *sticky-type-checking*
変数の型を変えようとするとエラーになる。このエラーを避けるには、まず|:unlet|す
る必要がある。しかし文字列と数値は同値であると見なされる。同じく、浮動小数点数
と数値も同値であるとみなされる。例: >
	:let l = "string"
	:let l = 44		" 型が文字列から数値に変わる
	:let l = [1, 2, 3]	" エラー! l はまだ数値である
	:let l = 4.4		" 型が数値から浮動小数点数に変わる
	:let l = "string"	" エラー!


1.2 関数への参照 ~
					*Funcref* *E695* *E718*
関数|function()|は関数への参照を返す。関数への参照は、式の中で関数名が要求され
る場所で使うと参照先の関数を呼び出す。例: >

	:let Fn = function("MyFunc")
	:echo Fn()
<							*E704* *E705* *E707*
関数参照の変数名は、大文字、"s:"、"w:"、"t:"、"b:" のいずれかで始めなければな
らない。関数参照と参照先の関数の名前を同じにすることはできない。

関数を定義して、それへの参照を直接辞書に入れるための特別な形式がある。例: >
	:function dict.init() dict
	:   let self.val = 0
	:endfunction

この辞書のキーは小文字で始めなければならない。実際の関数名はここでは使われない。
|numbered-function|も参照。

|:call|コマンドでも関数参照を使うことができる: >
	:call Fn()
	:call dict.init()

参照先の関数名は|string()|で得られる。 >
	:let func = string(Fn)

関数参照を呼び出すには|call()|を使い、引数にはリスト型の変数を使う: >
	:let r = call(Fn, mylist)


1.3 リスト ~
							*List* *Lists* *E686*
リストとは順序を保つ要素の列である。要素はどんな型でもよい。要素へはインデック
ス番号を使ってアクセスする。列の任意の位置に要素を追加したり削除することができ
る。


リストの作成 ~
							*E696* *E697*
リストを作るには、[]の中にコンマで区切って要素を書く。
例: >
	:let mylist = [1, two, 3, "four"]
	:let emptylist = []

要素はどんな式でもよい。要素としてリストを指定すると、リストのリストができる:
>
	:let nestlist = [[11, 12], [21, 22], [31, 32]]

最後の要素の後に余分なコンマがあると無視される。


リストのインデックス ~
							*list-index* *E684*
リストの要素にアクセスするには、リスト名の後に[]を書き、その中にインデックスを
書く。インデックスは0基点(つまり最初の要素のインデックスは0)である。 >
	:let item = mylist[0]		" 最初の要素(1)を取得
	:let item = mylist[2]		" 3番目の要素(3)を取得

取得した要素がリストならば、さらに続けてインデックスを書くことができる: >
	:let item = nestlist[0][1]	" 最初のリストの2番目の要素(12)を取得
<
負のインデックスを指定すると、リストの末尾から数えられる。インデックス-1は最後
の要素を示し、-2は最後から2番目を指す >
	:let last = mylist[-1]		" 最後の要素("four")を取得

無効なインデックスによるエラーを回避するには関数|get()|を使う。するとインデッ
クスが無効な場合は、0かまたは自分で指定した既定値が返る: >
	:echo get(mylist, idx)
	:echo get(mylist, idx, "NONE")


リストの連結 ~

2つのリストを連結するには演算子 "+" を使う: >
	:let longlist = mylist + [5, 6]
	:let mylist += [7, 8]

1個の要素を先頭または末尾に付け加えるには、[]で囲んでリストにして連結する。リ
ストの特定の要素を変更するには後述の|list-modification|を参照。


部分リスト ~

リストの一部分を取り出すには、[]の中に始点と終点のインデックスを書き、コロンで
区切る: >
	:let shortlist = mylist[2:-1]	" リスト[3, "four"]を得る

始点のインデックスを省略すると0となる。終点のインデックスを省略すると-1となる >
	:let endlist = mylist[2:]	" 2番目から最後まで: [3, "four"]
	:let shortlist = mylist[2:2]	" 1個の要素からなるリスト: [3]
	:let otherlist = mylist[:]	" リストのコピーを作る

終点のインデックスが始点のインデックスよりも前になってしまった場合は空リストと
なる。エラーメッセージは表示されない。

終点のインデックスがリストの長さより大きい場合は、長さ-1を指定したときと同じに
なる: >
	:let mylist = [0, 1, 2, 3]
	:echo mylist[2:8]		" 結果: [2, 3]

NOTE: mylist[s:e]と書くと変数 "s:e" をインデックスとして使ったと解釈される。
":" の前に1文字の変数を使うときは十分注意すること。必要ならこのようにスペース
を入れるとよい: mylist[s : e].


リストの同一性 ~
							*list-identity*
変数 "aa" がリストであり、それを別の変数 "bb" に代入したとすると、両方とも同じ
変数を参照するようになる。よってリスト "aa" を変更すると "bb" も変更される: >
	:let aa = [1, 2, 3]
	:let bb = aa
	:call add(aa, 4)
	:echo bb
<	[1, 2, 3, 4]

リストのコピーを作るには関数|copy()|を使う。前述の通り[:]を使ってもできる。こ
れは浅いコピーである。つまりリストの要素であるリストに変更を加えると、コピーさ
れたリスト内の同じ要素も変更される: >
	:let aa = [[1, 'a'], 2, 3]
	:let bb = copy(aa)
	:call add(aa, 4)
	:let aa[0][1] = 'aaa'
	:echo aa
<	[[1, aaa], 2, 3, 4] >
	:echo bb
<	[[1, aaa], 2, 3]

完全に独立したコピーを作るには|deepcopy()|を使う。これは再帰的にリストの要素の
コピーを作る。ただし深さは100レベルまでである。

2つの変数が同じリストを指しているかは演算子 "is" で判定できる。"isnot" はその
逆である。一方、"==" は2つのリストが同じ値を持っているかを判定する。 >
	:let alist = [1, 2, 3]
	:let blist = [1, 2, 3]
	:echo alist is blist
<	0 >
	:echo alist == blist
<	1

Note リストの比較について注意: 2つのリストは、同じ長さを持ち、全要素が "==" の
意味で等しいとき、等しいとみなされる。ただ、1つ例外がある: 数値と文字列を比較
するとそれらは異なるとみなされる。変数に対して "==" で比較したときに行われるよ
うな自動的な型変換は行われない。例: >
	echo 4 == "4"
<	1 >
	echo [4] == ["4"]
<	0

つまり、リストの比較は数値や文字列の比較よりも厳格である。単純な値もリストに入
れることによりこの方法で比較することができる: >

	:let a = 5
	:let b = "5"
	:echo a == b
<	1 >
	:echo [a] == [b]
<	0


リストのアンパック ~

リストの要素を個々の変数としてアンパックするには、[]の中に変数を書く: >
	:let [var1, var2] = mylist

変数の個数とリストの要素数が一致しないときはエラーになる。リストにある余分な要
素をまとめて受け取るには、";" と受け取る変数名を書いておく: >
	:let [var1, var2; rest] = mylist

上の例は次とほぼ同じである: >
	:let var1 = mylist[0]
	:let var2 = mylist[1]
	:let rest = mylist[2:]

要素が 2 つしかないときでもエラーにはならない。"rest" は空リストになる。


リストの変更 ~
							*list-modification*
リストの中の特定の要素を変更するには次のように|:let|を使う: >
	:let list[4] = "four"
	:let listlist[0][3] = item

始点と終点を指定してリストの一部分を変更することができる。代入する値は、少なく
とも削除する範囲の要素数と同じ数だけ必要である: >
	:let list[3:5] = [3, 4, 5]

リストに要素を追加したり削除するには関数を使う。いくつか例を示す: >
	:call insert(list, 'a')		" 先頭に要素 'a' を挿入する
	:call insert(list, 'a', 3)	" 要素 'a' をlist[3]の前に挿入する
	:call add(list, "new")		" 文字列の要素を最後に追加する
	:call add(list, [1, 2])		" 1個の要素としてリストを追加する
	:call extend(list, [1, 2])	" 2個の要素からなるリストを連結する
	:let i = remove(list, 3)	" 要素3を削除する
	:unlet list[3]			" 同上
	:let l = remove(list, 3, -1)	" 要素3から最後までを削除する
	:unlet list[3 : ]		" 同上
	:call filter(list, 'v:val !~ "x"')  " 要素 'x' を削除

要素の順番を変更する: >
	:call sort(list)		" リストをアルファベット順にソート
	:call reverse(list)		" 要素の順序を反転させる


for ループ ~

|:for|ループは、1つの変数に対してリストの各要素を順番に代入し、コマンドを実行
していく。例: >
	:for item in mylist
	:   call Doit(item)
	:endfor

上の例は次と同じ: >
	:let index = 0
	:while index < len(mylist)
	:   let item = mylist[index]
	:   :call Doit(item)
	:   let index = index + 1
	:endwhile

Note リストの全要素が同じ型でなければならない。そうでないとエラー|E706|にな
る。ループの最後でループ変数を|:unlet|すれば、異なる型でも扱える。

やりたいことがリストの各要素を変更するだけなら、forループを使うより関数|map()|
を使った方がよりシンプルになる。

|:let|コマンドと同じように、|:for|は変数のリストをループ変数にすることができる。
この場合、引数はリストのリストでなければならない。 >
	:for [lnum, col] in [[1, 3], [2, 8], [3, 0]]
	:   call Doit(lnum, col)
	:endfor

これはリストの各要素に対して|:let|コマンドを実行するかのように実行される。また
この場合も引数の型は全て同じでないとエラーになる。

引数の残りを1個のリスト変数に代入することもできる: >
	:for [i, j; rest] in listlist
	:   call Doit(i, j)
	:   if !empty(rest)
	:      echo "remainder: " . string(rest)
	:   endif
	:endfor


リスト操作関数 ~
						*E714*
以下はリスト操作に使える関数である: >
	:let r = call(funcname, list)	" 引数リストをつけて関数を呼び出す
	:if empty(list)			" リストが空かどうか判定する
	:let l = len(list)		" リストの要素数
	:let big = max(list)		" リスト中の最大値
	:let small = min(list)		" リスト中の最小値
	:let xs = count(list, 'x')	" 'x' の出現回数を数える
	:let i = index(list, 'x')	" 最初に 'x' が現れる位置のインデックス
	:let lines = getline(1, 10)	" バッファから10行を取得
	:call append('$', lines)	" バッファに行を追加する
	:let list = split("a b c")	" 文字列を分割してリストにする
	:let string = join(list, ', ')	" リストの要素を連結して文字列にする
	:let s = string(list)		" リストの文字列表現
	:call map(list, '">> " . v:val')  " 各要素の前に ">> " をつける

機能を組み合わせると、処理を単純に記述できることを覚えておくとよい。例えば、リ
スト中の全ての数値の和を求める例: >
	:exe 'let sum = ' . join(nrlist, '+')


1.4 辞書 ~
						*Dictionaries* *Dictionary*
辞書とは連想配列である。各要素はキーと値を持つ。要素はキーによって特定できる。
要素は特に順序を持たずに保持される。


辞書の作成 ~
						*E720* *E721* *E722* *E723*
辞書を作るには、{}の中にコンマで区切って要素を書く。各要素のキーと値はコロンで
区切る。それぞれのキーは1度しか現れてはならない。例: >
	:let mydict = {1: 'one', 2: 'two', 3: 'three'}
	:let emptydict = {}
<							*E713* *E716* *E717*
キーは必ず文字列である。数値を使うこともできるが、自動的に文字列に変換される。
よって文字列 '4' のキーと数値4のキーは同一の要素を参照する。
Note 文字列 '04' と数値04は異なることに注意。なぜなら数値04は文字列 '4' に変換
されるからである。

値はどんな式でもよい。辞書を値にすると、ネストした辞書ができる: >
	:let nestdict = {1: {11: 'a', 12: 'b'}, 2: {21: 'c'}}

最後の要素の後に余分なコンマがあると無視される。


要素にアクセスする ~

通常、要素にアクセスするには[]の中にキーを書く: >
	:let val = mydict["one"]
	:let mydict["four"] = 4

また、この書き方で既存の辞書に要素を追加できる。この点はリストと異なる。

キー名がアルファベット、数字、アンダースコアだけからなる場合は、以下の形式が使
える|expr-entry|: >
	:let val = mydict.one
	:let mydict.four = 4

要素はリストや辞書を含むどんな型でもよいため、インデックス参照とキー参照を続け
て書くことができる: >
	:echo dict.key[idx].key


辞書からリストへの変換 ~

辞書の全要素に対してループを行いたい場合がある。そのためには辞書をリストに変換
し、そのリストに対して|:for|ループを行う。

多くの場合はキーに対してループを行う。これには関数|keys()|を使う: >
	:for key in keys(mydict)
	:   echo key . ': ' . mydict[key]
	:endfor

このキーのリストはソートされていない。ソートさせるには関数|sort()|を使う: >
	:for key in sort(keys(mydict))

値に対してループを行うには関数|values()|を使う: >
	:for v in values(mydict)
	:   echo "value: " . v
	:endfor

キーと値両方を得るには関数|items()|を使う。この関数は、キーと値の2個の要素から
なるリストのリストを返す: >
	:for [key, value] in items(mydict)
	:   echo key . ': ' . value
	:endfor


辞書の同一性 ~
							*dict-identity*
辞書のコピーを作るにはリストと同様に|copy()|と|deepcopy()|を使う必要がある。そ
うでなく代入を行うと同一の辞書を参照するようになる: >
	:let onedict = {'a': 1, 'b': 2}
	:let adict = onedict
	:let adict['a'] = 11
	:echo onedict['a']
	11

2つの辞書は、全てのキー・値のペアが等しいとき等しいとみなされる。より詳しくは
|list-identity|を参照。


辞書の変更 ~
							*dict-modification*
辞書の要素を変更したり、新しい要素を追加するには|:let|を使う: >
	:let dict[4] = "four"
	:let dict['one'] = item

辞書から要素を取り除くには|remove()|か|:unlet|を使う。以下のように辞書からキー
"aaa" を取り除くには3つの方法がある: >
	:let i = remove(dict, 'aaa')
	:unlet dict.aaa
	:unlet dict['aaa']

2つの辞書を併合させるには|extend()|を使う: >
	:call extend(adict, bdict)
上のコマンドはbdictの全ての要素をadictに追加する。キーが重複した要素はbdictの
要素により上書きされる。この動作は3番目の引数により変更できる。
Note 辞書の要素間に順序は定まっていない。そのため ":echo adict" としたとき、も
ともとadictにあった要素が先に、bdictから追加された要素が後に表示されると考えて
はならない。

辞書から条件を指定して要素を取り除くには|filter()|が使える: >
	:call filter(dict, 'v:val =~ "x"')
このコマンドは "dict" から 'x' にマッチしない要素を全て取り除く。


関数を辞書に入れる ~
				*Dictionary-function* *self* *E725* *E862*
関数が "dict" 属性つきで定義されると、特殊な方法で呼び出すことができる。例: >
	:function Mylen() dict
	:   return len(self.data)
	:endfunction
	:let mydict = {'data': [0, 1, 2, 3], 'len': function("Mylen")}
	:echo mydict.len()

これはオブジェクト指向プログラミングのメソッドに似ている。この辞書の要素は
|Funcref|である。暗黙に定義されるローカル変数 "self" は、この関数を呼び出した
辞書を参照している。

"dict" 属性をつけないでFuncrefを辞書に入れることもできる。しかしその場合、変
数 "self" は定義されない。

				*numbered-function* *anonymous-function*
関数に名前をつける必要をなくすために、関数を定義して直接辞書に代入することがで
きる: >
	:let mydict = {'data': [0, 1, 2, 3]}
	:function mydict.len() dict
	:   return len(self.data)
	:endfunction
	:echo mydict.len()

こうすると関数に番号がふられ、dict.lenがこの関数を参照する|Funcref|となる。こ
の関数は|Funcref|を通してのみ呼び出せる。参照している|Funcref|がなくなると、こ
の関数は自動的に削除される。

番号付き関数には "dict" 属性を付ける必要はない。

番号付き関数でエラーが発生したときは、あるトリックを使うことで発生源を確認でき
る。例えば 42 という関数なら次のようにする: >
	:function {42}


辞書操作関数 ~
							*E715*
以下は辞書操作に使える関数である: >
	:if has_key(dict, 'foo')	" 辞書がキー "foo" の要素を持つなら真
	:if empty(dict)			" 辞書が空なら真
	:let l = len(dict)		" 辞書の要素数
	:let big = max(dict)		" 辞書中の最大値
	:let small = min(dict)		" 辞書中の最小値
	:let xs = count(dict, 'x')	" 'x' の出現回数を数える
	:let s = string(dict)		" 辞書の文字列表現
	:call map(dict, '">> " . v:val')  " 各要素の前に ">> " をつける


1.5 変数について補足 ~
							*more-variables*

変数や式の結果の型を知りたいのならば、関数|type()|を使う。

オプション 'viminfo' にフラグ '!' が含まれるならば、大文字で始まり小文字を含ま
ない名前のグローバル変数は、viminfoファイル|viminfo-file|に格納される。

オプション 'sessionoptions' が "global" を含むなら、大文字で始まり少なくとも一
文字以上の小文字を含む名前のグローバル変数は、sessionファイル|session-file|に
格納される。

変数名			何処に保存されるか ~
my_var_6		されない
My_Var_6		sessionファイル
MY_VAR_6		viminfoファイル


波括弧を使って変数名を構成できる。詳細は|curly-braces-names|を参照。

==============================================================================
2. 式の文法						*expression-syntax*

式文法一覧、優先順位の低いものから高い順に:

|expr1| expr2 ? expr1 : expr1	if-then-else 条件式

|expr2|	expr3 || expr3 ..	論理和

|expr3|	expr4 && expr4 ..	論理積

|expr4|	expr5 == expr5		等しい
	expr5 != expr5		等しくない
	expr5 >	 expr5		より大きい
	expr5 >= expr5		大きいか等しい
	expr5 <	 expr5		より小さい
	expr5 <= expr5		小さいか等しい
	expr5 =~ expr5		正規表現にマッチする
	expr5 !~ expr5		正規表現にマッチしない

	expr5 ==? expr5		文字列として等しい(大文字/小文字区別無し)
	expr5 ==# expr5		文字列として等しい(大文字/小文字区別有り)
	etc.			上記の各式は大小文字の区別を、?を付加すると行
				わず、#を付加すると行う

	expr5 is expr5		同一の |List| のインスタンス
	expr5 isnot expr5	異なる |List| のインスタンス

|expr5|	expr6 +	 expr6 ..	足し算またはリストの連結
	expr6 -	 expr6 ..	引き算
	expr6 .	 expr6 ..	文字列の連結

|expr6|	expr7 *	 expr7 ..	掛け算
	expr7 /	 expr7 ..	割り算
	expr7 %	 expr7 ..	剰余(割った余り)

|expr7|	! expr7			論理否定
	- expr7			単項のマイナス {訳注: -1等}
	+ expr7			単項のプラス

|expr8|	expr8[expr1]		文字列のバイト、またはリストの要素
	expr8[expr1 : expr1]	文字列の部分文字列、またはリストの部分リスト
	expr8.name		辞書 |Dictionary| の要素
	expr8(expr1, ...)	|Funcref| 変数による関数呼び出し

|expr9|	number			数定数
	"string"		文字列定数。バックスラッシュは特別な意味を持つ
	'string'		リテラル文字列定数。'を含めるには2重にする
	[expr1, ...]		リスト |List|
	{expr1: expr1, ...}	辞書 |Dictionary|
	&option			オプション変数
	(expr1)			式の入れ子
	variable		内部変数
	va{ria}ble		波括弧付きの内部変数
	$VAR			環境変数
	@r			レジスタ 'r' の値
	function(expr1, ...)	関数呼出し
	func{ti}on(expr1, ...)	波括弧付きの内部変数

".." はその演算が、その後に他の演算を続ける事が出来ることを示している。
例: >
	&nu || &list && &shell == "csh"

一つのレベルにある全ての式は左から右に解釈される。


expr1							*expr1* *E109*
-----

expr2 ? expr1 : expr1

'?' より前の式は数値として評価される。その結果が非0であった場合、'?' と ':' に
挟まれた式の値がこの式全体の値となり、逆に0であった場合は ':' 以降の式の値が全
体の値となる。
例: >
	:echo lnum == 1 ? "先頭" : lnum

始めの式が "expr2" であるから、そこに別の?:を含むことはできない。残り二つの式
については以下のように再帰的な?:の利用が許される。
例: >
	:echo lnum == 1 ? "top" : lnum == 1000 ? "last" : lnum

読み易くするために、行継続|line-continuation|を利用することが推奨される: >
	:echo lnum == 1
	:\	? "top"
	:\	: lnum == 1000
	:\		? "last"
	:\		: lnum

':' の前には必ずスペースを入れること。そうでないと "a:1" のような変数の使用と
間違えてしまう可能性がある。


expr2 and expr3						*expr2* *expr3*
---------------

						*expr-barbar* *expr-&&*
演算子 "||" と "&&" は左右に一つずつ引数を取る。引数は数値に変換される。結果は:

	  入力				   出力		    ~
n1		n2		n1 || n2	n1 && n2    ~
零		零		零		零
零		非零		非零		零
非零		零		非零		零
非零		非零		非零		非零

演算子は続けて書く事ができる。例: >

	&nu || &list && &shell == "csh"

Note "&&" は "||" よりも高い優先順位を持っている。これは次の事を意味する: >

	&nu || (&list && &shell == "csh")

結果が確定した時点で残りの式は省略され、解釈されない。これはC言語で行われるこ
とに似ている。例: >

	let a = 1
	echo a || b

これはaが非零で戻り値は絶対に非零であるから、変数bが宣言されていなくても有効で
ある。次のも同様に: >

	echo exists("b") && b == "yes"

これもbが宣言されているいないに関わらず有効である。後半の項はbが定義されている
時にだけ評価される。


expr4							*expr4*
-----

expr5 {cmp} expr5

2つの式expr5を比較し、結果が偽なら0を、真なら1を返す。

			*expr-==*  *expr-!=*  *expr->*   *expr->=*
			*expr-<*   *expr-<=*  *expr-=~*  *expr-!~*
			*expr-==#* *expr-!=#* *expr->#*  *expr->=#*
			*expr-<#*  *expr-<=#* *expr-=~#* *expr-!~#*
			*expr-==?* *expr-!=?* *expr->?*  *expr->=?*
			*expr-<?*  *expr-<=?* *expr-=~?* *expr-!~?*
			*expr-is* *expr-isnot* *expr-is#* *expr-isnot#*
			*expr-is?* *expr-isnot?*
		'ignorecase'次第   大小文字考慮    大小文字無視 ~
等しい			==		==#		==?
等しくない		!=		!=#		!=?
より大きい		>		>#		>?
より大きいか等しい	>=		>=#		>=?
より小さい		<		<#		<?
より小さいか等しい	<=		<=#		<=?
正規表現マッチ		=~		=~#		=~?
正規表現非マッチ	!~		!~#		!~?
同一のインスタンス	is		is#		is?
異なるインスタンス	isnot		isnot#		isnot?

例:
"abc" ==# "Abc"	  0と評価される
"abc" ==? "Abc"	  1と評価される
"abc" == "Abc"	  'ignorecase' が設定されていれば1と、でなければ0と評価

							*E691* *E692*
リスト|List|はリストとだけ比較可能で、==系、!=系、is、isnotのみ利用できる。
これらはそれぞれのリストの値を再帰的に比較する。大文字小文字無視にすると要素を
比較するときに大文字小文字を無視する。

							*E735* *E736*
辞書|Dictionary|は辞書とだけ比較可能で、==系、!=系、is、isnotのみ利用できる。
これらは辞書のキー/値を再帰的に比較する。大文字小文字無視にすると要素を
比較するときに大文字小文字を無視する。

							*E693* *E694*
|Funcref|は|Funcref|とだけ比較可能で、"equal" と "not equal" のみ利用できる。
大文字小文字は常に区別される。

リスト (|List|) や 辞書 (|Dictionary|) に対して "is" や "isnot" を使うと、それ
らの式が同じリストのインスタンスを参照しているか判定される。リストのコピーと元
のリストは異なると判定される。リスト以外に対して "is" は "equal" と同じで、
"isnot" は "not equal" と同じである。ただし "is"、"isnot" は型が異なると値が等
しくない点が "==" とは異なる。"4 == '4'" は真、"4 is '4'" は偽、"0 is []" は偽
でエラーにはならない、"is#"/"isnot#" と "is?"/"isnot?" は大文字小文字を区別す
るかどうかが違う。

文字列と数値を比較した場合、文字列が数値に変換され、数値として比較される。これ
は "0 == 'x'" が、'x' が数値としては0であることから、真となることを意味する。

文字列同士を比較した場合、strcmp()やstricmp()によって比較される。これは数値的
に(バイトの値で)比較されるのであって、必ずしも言語に基づく文字種の違いではな
い。

'#' を付けた演算子を使うか、省略形かつ 'ignorecase' が設定されていない場合、比
較はstrcmp()で行われる。大文字・小文字は区別される。

'?' を付けた演算子を使うか、省略形かつ 'ignorecase' が設定されている場合、比較
はstricmp()で行われる。大文字・小文字は区別されない。

'smartcase' は適用されない。

"=~" と "!~" 演算子は右側の引数を正規表現のパターンとして、左側の引数に対して
マッチを試みる。正規表現のパターンに関しては|pattern|を参照。このマッチは
'magic' が設定され 'cpoptions' が空であるように振舞い、実際の 'magic' や
'cpoptions' に何が設定されているには依存しない。これがスクリプトをポータブルに
してくれる。正規表現中のバックスラッシュが重複してしまうのを避けるには、シング
ルクォーテーションの文字列を使用する。詳細は|literal-string|を参照。
文字列は単一行として扱われるので、複数行のパターン(\nを含むもの)はマッチしな
い。しかしながらリテラルなヌル文字(NL)を、普通の文字として代用することはでき
る。例:
	"foo\nbar" =~ "\n"	1として評価される
	"foo\nbar" =~ "\\n"	0として評価される


expr5 and expr6						*expr5* *expr6*
---------------
expr6 +	 expr6 ..	足し算、またはリストの連結	*expr-+*
expr6 -	 expr6 ..	引き算				*expr--*
expr6 .	 expr6 ..	文字列の連結			*expr-.*

リストに対しては "+" のみ可能で、expr6は両方ともリストでなければならない。結果
は2つのリストを連結した新しいリスト。

expr7 *	 expr7 ..	掛け算					*expr-star*
expr7 /	 expr7 ..	割り算					*expr-/*
expr7 %	 expr7 ..	剰余(割った余り)			*expr-%*

"." を除く全ての演算子は自動的に文字列を数値に変換する。
ビット演算については |and()|, |or()|, |xor()| を参照。

"+" と "." の違いに注意:
	"123" + "456" = 579
	"123" . "456" = "123456"

'.' は '+' と '-' と等しい優先順位を持つので、次の式は: >
	1 . 90 + 90.0
次のように解釈される: >
	(1 . 90) + 90.0
これはエラーにならない。というのは、"190" は自動的に数値 190 に変換さ
れ、それと浮動小数点数 90.0 との和になる。しかし次の式は: >
	1 . 90 * 90.0
次のように解釈される: >
	1 . (90 * 90.0)
'.' は '*' より優先順位が低いためである。これはエラーになる。というのは、浮動
小数点数と文字列を結合することになるからである。

数値をゼロで割った結果は、被除数によって次のようになる:
	  0 / 0  = -0x80000000	(浮動小数点数の NaN のようなもの)
	 >0 / 0  =  0x7fffffff	(正の無限大のようなもの)
	 <0 / 0  = -0x7fffffff	(負の無限大のようなもの)
	{訳注: >0 は正の数、<0 は負の数の意味}
	(Vim 7.2 以前では常に 0x7fffffff だった)

'/' の右辺(除数)が0の場合、結果は0x7ffffffになる。
'%' の右辺(法)が0の場合、結果は0になる。

これらは全て|Funcref|には適用できない。

. と % は浮動小数点数には適用できない。 *E804*


expr7							*expr7*
-----
! expr7			論理否定		*expr-!*
- expr7			単項マイナス		*expr-unary--*
+ expr7			単項プラス		*expr-unary-+*

'!' 演算子では非零は0に、0は1になる。
'-' では数値の符号が反転される。
'+" では変化はない。

文字列はまず数値に変換される。

これら2つは繰り返したり混ぜたりできる。例:
	!-1	    == 0
	!!8	    == 1
	--9	    == 9


expr8							*expr8*
-----
expr8[expr1]		文字列またはリストの要素	*expr-[]* *E111*

expr8が数値か文字列ならば、この値は文字列 expr8 の第 expr1 番目のバイトからな
る 1 バイトの文字列となる。expr8は文字列、expr1は数として扱われる。ただし
expr8 がマルチバイト文字列である場合、この値は単なるバイトコードであり、1文字
とはならないかもしれないことに注意。マルチバイト文字列に対する代替方法は
|byteidx()| を参照。

インデックスが0の場合、先頭のキャラクタが得られることに注意。これはC言語のよう
に働く。注意:カラム番号は1から始まる。例えばカーソルの下の文字を得るためには、
次のようにする必要がある: >
	:let c = getline(".")[col(".") - 1]

文字列の長さよりも大きなインデックスが指定された場合、結果は空文字列になる。負
数のインデックスを指定すると、結果は常に空文字列になる(後方互換性のため)。
最後のバイトを得るには[-1:]を使うこと。

expr8がリスト|List|ならばインデックスexpr1の要素が返る。取りうるインデックスの
値については|list-index|を参照。インデックスが範囲を超えている場合はエラーとな
る。例: >
	:let item = mylist[-1]		" 最後の要素を取得

一般的には、インデックスが正でリストの長さ以上または、負でリストの長さ×-1より
小さいときエラーとなる。


expr8[expr1a : expr1b]	部分文字列または部分リスト	*expr-[:]*

expr8が数値か文字列ならば、expr1aバイトからexpr1bバイトまでの部分文字列となる
(両端を含む)。expr8は文字列として扱われ、expr1aとexpr1bは数値として扱われる。
Note マルチバイトのエンコーディングは認識しない。マルチバイト文字列のイン
デックスを計算する方法については |byteidx()| を参照。

expr1aが省略されたときは0となる。expr1bが省略されたときは文字列の長さ-1となる。

負数のインデックスを使うことによって文字列の末尾から取り出すことができる。-1は
最後の文字、-2は最後から2文字目…を表す。

インデックスがその文字の範囲外に出てしまったときは、その文字は省かれる。expr1b
がexpr1aより小さいときは空文字列となる。

例: >
	:let c = name[-1:]		" 文字列の最後のバイト
	:let c = name[-2:-2]		" 文字列の最後から2バイト目
	:let s = line(".")[4:]		" 5バイト目から末尾まで
	:let s = s[:-3]			" 最後の2文字を削除する
<
							*sublist* *slice*
expr8がリストならば、インデックスexpr1aとexpr1bの間の要素からなる新しいリスト
となる。上で説明した文字列の場合と同様だが、インデックスが範囲を超えるとエラー
になる。例: >
	:let l = mylist[:3]		" 最初の4個の要素
	:let l = mylist[4:4]		" 1個の要素からなるリスト
	:let l = mylist[:]		" リストの浅いコピー

|Funcref|に対してexpr8[expr1]やexpr8[expr1a : expr1b]を使うとエラーになる。


expr8.name		辞書|Dictionary|の要素		*expr-entry*

expr8が辞書|Dictionary|のとき、ドットをつけるとその後に書かれた名前が辞書の
キーと見なされる。例: expr8[name]。

名前は変数名と同じようにアルファベットと数字だけから構成されなければならない
が、数字で始まってもよい。波括弧は使えない。

ドットの前後に空白があってはならない。

例: >
	:let dict = {"one": 1, 2: "two"}
	:echo dict.one
	:echo dict .2

Note ドットは文字列連結にも使われる。混乱を避けるために、文字列連結のドットの
周りには必ずスペースを入れること。


expr8(expr1, ...)	|Funcref| 関数呼び出し

expr8が|Funcref|型の変数のとき、その参照する関数を呼び出す。



							*expr9*
数
------
number			数定数				*expr-number*
						*hex-number* *octal-number*

10進数、16進数(0xか0Xで始まる)、もしくは8進数(0で始まる)の数定数。

						*floating-point-format*
浮動小数点数は次の2つの形式で書ける:

	[-+]{N}.{M}
	[-+]{N}.{M}e[-+]{exp}

ここで {N} と {M} は数値である。{N} と {M} の両方とも省略してはならず、数値の
みを含めることができる。
[-+] は、省略可能なプラスまたはマイナス記号である。
{exp} は指数で、10 のベキ。
現在のロケールが何であれ、小数点にはドットのみを使える。コンマは使えない。
{|+float| 機能つきでコンパイルされたときのみ有効}

例:
	123.456
	+0.0001
	55.0
	-0.123
	1.234e03
	1.0E-6
	-3.1416e+88

次のものは無効である:
	3.		{M} が空
	1e40		.{M} がない

							*float-pi* *float-e*
コピー＆ペーストしておくのに便利な値: >
	:let pi = 3.14159265359
	:let e  = 2.71828182846

論理的根拠:
浮動小数点数が導入される前は、123.456 と書くと 123 と 456 の2つの数値と解釈
され、それらが文字列に変換されて結合されて "123456" という文字列になった。
これは無意味であり、Vim スクリプト内で意図的に使われているものが見つからな
かったので、浮動小数点数の普通の表記法を用いるため、この後方非互換性は許容され
た。

						*floating-point-precision*
浮動小数点数の精度と範囲は、Vim とリンクしたライブラリの "double" の意味によ
る。実行時にこれを変更することはできない。

浮動小数点数 |Float| は printf("%g", f) とするのと同様に、小数点以下6桁まで表
示される。表示する桁数は |printf()| を使えば変えられる。例: >
	:echo printf('%.15e', atan(1))
<	7.853981633974483e-01



文字列							*expr-string* *E114*
------
"string"		文字列定数		*expr-quote*

ダブルクォートが使われていることに注意。

文字列定数には以下の特殊文字が使用できる: 
\...	3桁の8進数字 (例 "\316")
\..	2桁の8進数字 (非数字が続かなければならない)
\.	1桁の8進数字 (非数字が続かなければならない)
\x..	2桁の16進数字 (例 "\x1f")
\x.	1桁の16進数字 (16進数字でないものが続かなければならない)
\X..	\x..に同じ
\X.	\x.に同じ
\u....	文字を4桁の16進数で表現したもので、実際の値は現在の 'encoding' の値に
	依存する (例えば "\u02a4")
\U....	\u....に同じ
\b	バックスペース <BS>
\e	エスケープ <Esc>
\f	フォームフィード <FF>
\n	改行 <NL>
\r	改行(キャリッジリターン) <CR>
\t	タブ <Tab>
\\	円記号(バックスラッシュ)
\"	ダブルクォート
\<xxx>	"xxx" という名の特殊キー。 例 "\<C-W>" は CTRL-W。これはマップで使うた
	めのものである。utf-8 文字を得るためには <Char-xxxx> を使わずに、上述
	の \uxxxx を使うこと。

Note "\xff" は値255の1バイトとなる。これはエンコーディングによっては無効な値か
もしれない。現在の 'encoding' の値に応じた文字255を得るには "\u00ff" を使う。

Note "\000" と "\x00" は強制的に文字列の終端として扱われる。


リテラル文字列						*literal-string* *E115*
---------------
'string'		文字列定数		*expr-'*

Note シングルクォートが使われていることに注意。

この文字列は文字通りに扱われる。バックスラッシュは取り除かれないし、また特別な
意味を持ったりもしない。唯一の例外は、2つのシングルクォートで1つのシングル
クォートになることである。

シングルクォートの文字列は、バックスラッシュを2重にしなくてよいため、正規表現
パターンを表すのに便利である。以下の2つのコマンドは同値である: >
	if a =~ "\\s*"
	if a =~ '\s*'


オプション					*expr-option* *E112* *E113*
------
&option			オプション変数、ローカルなものが優先
&g:option		グローバルオプション変数
&l:option		ローカルオプション変数

例: >
	echo "タブストップは " . &tabstop . " です"
	if &insertmode

ここにはあらゆるオプション名を使うことができる。|options|を参照。ローカル変数
を使おうとして、実際にはバッファローカルもウィンドウローカルも存在しない場合に
は、グローバル変数が利用される。


レジスタ						*expr-register* *@r*
--------
@r			レジスタ 'r' の値

名前付きレジスタの中身を1つの文字列として得る。必要なところには改行文字が挿入
されている。無名レジスタの中身を取得するには@"か@@を使う。利用可能なレジスタの
説明については|registers|を参照。

レジスタ '=' を使うと、式の値でなく式そのものを得る。それを評価するには
|eval()|を使う。


入れ子							*expr-nesting* *E110*
-------
(expr1)			式の入れ子


環境変数						*expr-env*
--------------------
$VAR			環境変数

環境変数の文字列。定義されていない環境変数を指定した場合、結果は空文字列。
							*expr-env-expand*
Note $VARを直接使用した場合とexpand("$VAR")を使用した場合では、動作に違いがあ
ることに注意。直接使用した場合には、現在のVimのセッション中で既知の値に展開さ
れるだけである。expand()を使用した場合、まず最初にVimのセッション中で既知の値
に展開される。それが失敗した場合、変数の展開にシェルが使用されることになる。こ
れは遅くはなるが、シェルの知りうる全ての変数を展開することができる。例: >
	:echo $version
	:echo expand("$version")
最初の一つは恐らく何も返ってこず、2つ目は$versionの値が返ってくるだろう(貴方の
シェルがサポートしていたとして)


内部変数						*expr-variable*
-----------------
variable		内部変数
以下の|internal-variables|を参照。


関数呼出		*expr-function* *E116* *E118* *E119* *E120*
-------------
function(expr1, ...)	関数呼出
以下の|functions|を参照。


==============================================================================
3. 内部変数					*internal-variables* *E461*

内部変数の名前には文字と、数字とアンダーバー('_')を使うことができる。しかし数
字で始めることはできない。波括弧を使うこともできる。
詳細は|curly-braces-names|を参照。

内部変数は ":let" コマンドで作成される |:let|。":unlet" コマンドで明示的に内部
変数を破棄することができる |:unlet|。内部変数に使われてない名前か、既に破棄さ
れた内部変数を使うとエラーとなる。

変数には幾つもの名前空間が存在する。実際にどれが利用されるかは、どのような前置
子が使われたかで決まる:

		(無し) 関数の中では関数ローカル、それ以外ではグローバル
|buffer-variable|    b:	  現在のバッファにローカル
|window-variable|    w:	  現在のウィンドウにローカル
|tabpage-variable|   t:	  現在のタブページにローカル
|global-variable|    g:	  グローバル
|local-variable|     l:	  関数にローカル
|script-variable|    s:	  |:source|されたVimスクリプトにローカル
|function-argument|  a:	  関数の引数(関数内のみ)
|vim-variable|       v:	  グローバル、Vimがあらかじめ定義

これらのスコープそのものに辞書を通じてアクセスできる。例えば、全てのスクリプト
ローカル変数を削除するには次のようにする: >
	:for k in keys(s:)
	:    unlet s:[k]
	:endfor
<
						*buffer-variable* *b:var* *b:*
"b:" で始まる変数名は、カレントバッファに局所的な変数を意味する。このように一
つ一つのバッファ毎に、変数 "b:foo" を別々に使用することができる。この種の変数
はバッファが掃除(wipe out)された時や、":bdelete" で削除された時に一緒に削除さ
れる。

1つのバッファローカル変数が定義済:
					*b:changedtick* *changetick*
b:changedtick	現在のバッファに対する総変更の回数。変更を行うたびに増加する。
		これには一回のアンドゥ操作もカウントされる。この変数はバッファ
		に変更が行われた際にだけアクションを起こしたい時に利用できる。
		例: >
		    :if my_changedtick != b:changedtick
		    :   let my_changedtick = b:changedtick
		    :   call My_Update()
		    :endif
<
						*window-variable* *w:var* *w:*
"w:" で始まる変数名は、カレントウィンドウにローカルな変数を意味する。これはウィ
ンドウを閉じるときに破棄される。

						*tabpage-variable* *t:var* *t:*
"t:" で始まる変数名は、カレントタブページにローカルな変数を意味する。これはタ
ブページを閉じるときに破棄される。{|+windows| 機能つきでコンパイルしたときのみ
利用可能}

						*global-variable* *g:var* *g:*
関数の中からグローバル変数へアクセスするには、"g:" を付けた名前を使用する。こ
れが省略された場合は関数ローカルな変数にアクセスする。ただし "g:" 自体は、関数
の外でも使うことができる。

						*local-variable* *l:var* *l:*
関数の中からそのローカル変数にアクセスするには何も前置しなければ良い。明示的
に "l:" を付けることも可能である。ただし "l:" をつけないと予約されている変数名
と衝突してしまうことがある。例: "count" とすると "v:count" を参照してしまう。
"l:count" とすればローカル変数countを参照できる。

						*script-variable* *s:var*
Vimスクリプト内では "s:" で始まる変数名を使うことができる。これはスクリプトに
ついてローカルであり、スクリプトの外部からはアクセスできない。

スクリプト変数は次の場所で使える:
- そのスクリプトをsourceしている間に実行されるコマンド
- そのスクリプト内で定義される関数
- そのスクリプト内で定義されるオートコマンド
- そのスクリプト内で定義される関数やオートコマンドで定義される関数やオートコマ
  ンド(再帰的)
- そのスクリプト内で定義されるユーザ定義コマンド
次の場面では使えない:
- そのスクリプトからsourceされる他のスクリプト
- マッピング
- メニュー
- など。

グローバル変数との衝突を避けるにはスクリプト変数を使う。
次の例を参照: >

	let s:counter = 0
	function MyCounter()
	  let s:counter = s:counter + 1
	  echo s:counter
	endfunction
	command Tick call MyCounter()

ここで他のスクリプトから "Tick" を実行してみると、そのスクリプト内の変数
"s:counter" は変化せず、"Tick" が定義されたスクリプト内の "s:counter" だけが変
化する。

これと同じことをするもう1つの例: >

	let s:counter = 0
	command Tick let s:counter = s:counter + 1 | echo s:counter

関数呼び出しやユーザ定義コマンドを実行するとき、スクリプト変数のコンテキストは
その関数、コマンドが定義されたスクリプトとなる。

関数の中で関数を定義した場合、スクリプト変数も共有される。例: >

	let s:counter = 0
	function StartCounting(incr)
	  if a:incr
	    function MyCounter()
	      let s:counter = s:counter + 1
	    endfunction
	  else
	    function MyCounter()
	      let s:counter = s:counter - 1
	    endfunction
	  endif
	endfunction

このStartCounting()を呼ぶと、カウントアップかカウントダウンのどちらかを行う関
数MyCounter()を定義する。StartCounting()がどこで呼ばれたかに関係なく、
MyCounter()の中では変数s:counterにアクセスできる。

同じスクリプトが再度読み込まれた場合、同一のスクリプト変数が使われる。スクリプ
ト変数はVimが終了するまで存続する。以下の例はカウンタを保持する: >

	if !exists("s:counter")
	  let s:counter = 1
	  echo "script executed for the first time"
	else
	  let s:counter = s:counter + 1
	  echo "script executed " . s:counter . " times now"
	endif

Note これはつまり、ファイルタイププラグインはバッファごとにスクリプト変数を1セッ
ト持つのではないということを意味する。そのような目的にはバッファローカル変数
|b:var|を使うこと。


Vimの定義済変数:				*vim-variable* *v:var* *v:*

					*v:beval_col* *beval_col-variable*
v:beval_col	マウスポインタがある桁の桁番号。|v:beval_lnum|行目のバイトイン
		デックスである。オプション 'balloonexpr' を評価している最中の
		み有効。

					*v:beval_bufnr* *beval_bufnr-variable*
v:beval_bufnr	マウスポインタがあるバッファの番号。オプション 'balloonexpr'
		を評価している最中のみ有効。

					*v:beval_lnum* *beval_lnum-variable*
v:beval_lnum	マウスポインタがある行の行番号。オプション 'balloonexpr' を
		評価している最中のみ有効。

					*v:beval_text* *beval_text-variable*
v:beval_text	マウスポインタの下もしくは後ろにあるテキスト。Cプログラムのデ
		バッグのために有用。'iskeyword' が適用されるが、マウスポインタ
		の下より前にあるドットと "->" は含まれる。マウスポインタが ']'
		の上にあるときは、そこから対応する '[' とその前にあるテキスト
		までが含まれる。マウスポインタが1行に収まるビジュアル領域の上
		にあるときはその選択領域となる。オプション 'balloonexpr' を評
		価している最中のみ有効。

					*v:beval_winnr* *beval_winnr-variable*
v:beval_winnr	マウスポインタがあるウィンドウの番号。オプション 'balloonexpr'
		を評価している最中のみ有効。1番目のウィンドウの番号はゼロであ
		る(他の場所でのウィンドウ番号と異なっている)。

					*v:char* *char-variable*
v:char		'formatexpr' を評価しているときの引数。また、短縮入力
		|:map-<expr>| で <expr> を指定しているとき、タイプされた文字を
		保持する。
		これは |InsertCharPre| と |InsertEnter| イベントでも使われる。

			*v:charconvert_from* *charconvert_from-variable*
v:charconvert_from
		変換しようとしているファイルの文字エンコーディング名。オプショ
		ン 'charconvert' を評価している最中のみ有効。

			*v:charconvert_to* *charconvert_to-variable*
v:charconvert_to
		変換後のファイルの文字エンコーディング名。オプション
		'charconvert' を評価している最中のみ有効。

					*v:cmdarg* *cmdarg-variable*
v:cmdarg	2つの目的のために使われる:
		1. ファイルの読み書きコマンドに与えられる余分な引数。現在のと
		   ころ "++enc=" と "++ff=" がそれである。読み書きコマンドに対
		   するオートコマンドイベントが発生する前にこの変数が代入され
		   る。その読み書きコマンドの後に直接この変数を連結できるよう
		   に、先頭にスペースがついている。Note: ここには "+cmd" 引数
		   は含まれていない。どちらにしろそれは実行されるからである。
		2. ":hardcopy" でPostScriptファイルを印刷するとき、これが
		   ":hardcopy" への引数になる。'printexpr' の中で使うことがで
		   きる。

					*v:cmdbang* *cmdbang-variable*
v:cmdbang	v:cmdargと同じく読み書きコマンドを実行したとき設定される。読み
		書きコマンドに "!" が使われたときは1となり、使われていなければ
		0となる。Note オートコマンドの中でのみ利用可能なことに注意。
		ユーザ定義コマンドでは|<bang>|を使えば同じことができる。

					*v:count* *count-variable*
v:count		最後に実行されたノーマルモードコマンドに渡されたコマンドの実行
		回数を返す。読出し専用。使用例: >
	:map _x :<C-U>echo "the count is " . count<CR>
<		Note: <C-U>は、カウントの後に ':' をタイプした時に示される、行
		範囲指定を削除するために必要となる。
		"3d2w" のようにカウントが2個指定された場合、その数が掛けられる。
		よって "d6w" となる。
		オプション 'formatexpr' を評価するためにも使われる。
		また "count" は、以前の版のVimとの互換性の為に動作する。

					*v:count1* *count1-variable*
v:count1	"v:count" と同じように、しかしカウントが指定されなかった時の省
		略値として存在する。

						*v:ctype* *ctype-variable*
v:ctype		文字に関する実行環境の現在のロケール設定。これを使えばVim
		スクリプト内で現在のロケール設定に対応できるようになる。技術的
		な詳細: LC_CTYPEに等しい。ロケールを使用していないときは "C"
		になる。
		この変数を設定するには|:language|コマンドを使うこと。直接設定
		することはできない。
		|multi-lang|を参照。

					*v:dying* *dying-variable*
v:dying		通常時は0。致命的なシグナルを受信したとき1が代入される。複数
		のシグナルを受信すると値が増加していく。オートコマンド内でVim
		が正常に終了するかチェックするために使える。{Unix でのみ動作}
		例: >
	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif

<		Note: v:dying が 1 のときに別の致命的なシグナルを受信した場合
		は VimLeave 自動コマンドは実行されない。

					*v:errmsg* *errmsg-variable*
v:errmsg	最後に表示されたエラーメッセージ。この変数は代入することが許
		されている。例: >
	:let errmsg = ""
	:next
	:if (errmsg != "")
	:  ...
<		また "errmsg" は、以前の版のVimとの互換性の為に動作する。

					*v:exception* *exception-variable*
v:exception	最も直近に捕捉され、まだ終了していない例外の値。
		|v:throwpoint|と|throw-variables|を参照。
		例: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "caught" v:exception
	:endtry
<		出力: "caught oops".

					*v:fcs_reason* *fcs_reason-variable*
v:fcs_reason	|FileChangedShell|イベントが発生した理由。オートコマンドの中で
		何をすべきかやv:fcs_choiceに何を代入すべきかを決めるために使う。
		値は次のどれかとなる:
			deleted		もはやファイルが存在しない
			conflict	ファイルの内容、モード、タイムスタンプ
					が変化しており、バッファが変更されてい
					る状態。
			changed		ファイルの内容が変化している
			mode		ファイルのモードが変化している
			time		タイムスタンプだけが変化している

					*v:fcs_choice* *fcs_choice-variable*
v:fcs_choice	|FileChangedShell|イベントが発生した後に何をすべきかを表す。
		オートコマンドの中で、そのバッファに対して何をすべきかを指示す
		るために使う。
			reload		バッファを読み直す(バッファが削除され
					ている場合には効果がない)。
			ask		何をすべきかをユーザに問い合わせる。こ
					れはこのオートコマンドがない場合と同じ
					である。ただしタイムスタンプだけが変化
					しているときは何もしない。
			<empty>		何もしない。オートコマンドの中だけで必
					要なことは全て行ってしまっているという
					場合にこの値を代入する。
		既定値は<empty>。これら以外の(無効な)値が代入されたときは空の
		ときと同じ動作になり、警告メッセージは表示されない。

					*v:fname_in* *fname_in-variable*
v:fname_in	入力ファイルの名前。以下のオプションを評価している最中のみ
		有効:
			オプション	このファイル名の意味 ~
			'charconvert'	変換するファイル
			'diffexpr'	元のファイル
			'patchexpr'	元のファイル
			'printexpr'	印刷するファイル
		また、オートコマンドイベント|SwapExists|が発生したときスワップ
		ファイル名が代入される。

					*v:fname_out* *fname_out-variable*
v:fname_out	出力ファイルの名前。以下のオプションを評価している最中のみ
		有効:
			オプション	このファイル名の意味 ~
			'charconvert'	変換した結果のファイル (*)
			'diffexpr'	diffの出力
			'patchexpr'	パッチを当てた結果のファイル
		(*) 書き込みコマンド(":w file" など)を実行する際の変換では
		v:fname_inと同じになる。読み込みコマンド(":e file" など)を実行
		する際の変換では一時ファイル名になり、v:fname_inと異なる。

					*v:fname_new* *fname_new-variable*
v:fname_new	新しい方のファイル名。'diffexpr' を評価している最中のみ有効。

					*v:fname_diff* *fname_diff-variable*
v:fname_diff	diff(patch)ファイルの名前。'patchexpr' を評価している最中のみ
		有効。

					*v:folddashes* *folddashes-variable*
v:folddashes	'foldtext' 用。閉じた折り畳みのレベルを表すダッシュ。
		サンドボックス|sandbox|の中では読出し専用。|fold-foldtext|

					*v:foldlevel* *foldlevel-variable*
v:foldlevel	'foldtext' 用。閉じた折り畳みのレベル。
		サンドボックス|sandbox|の中では読出し専用。|fold-foldtext|

					*v:foldend* *foldend-variable*
v:foldend	'foldtext' 用。閉じた折り畳みの最後の行。
		サンドボックス|sandbox|の中では読出し専用。|fold-foldtext|

					*v:foldstart* *foldstart-variable*
v:foldstart	'foldtext' 用。閉じた折り畳みの最初の行。
		サンドボックス|sandbox|の中では読出し専用。|fold-foldtext|

					*v:insertmode* *insertmode-variable*
v:insertmode	オートコマンドイベント|InsertEnter|と|InsertChange|用。
		値は次のどれか:
			i	挿入モード
			r	置換モード
			v	仮想置換モード

						*v:key* *key-variable*
v:key		辞書|Dictionary|の現在の要素のキー。|map()|と|filter()|で使わ
		れる式を評価している最中のみ有効。
		読出し専用。

						*v:lang* *lang-variable*
v:lang		メッセージに関する実行環境の現在のロケール設定。これを使えば
		Vimスクリプト内で現在のロケール設定に対応できるようになる。
		技術的な詳細: LC_MESSAGESに等しい。この値はシステムに依存する。
		この変数を設定するには|:language|コマンドを使うこと。直接設定
		することはできない。
		文字エンコーディングに使うのと違う言語でメッセージを表示させた
		い場合は|v:ctype|と異なる値でもよい。|multi-lang|を参照。

						*v:lc_time* *lc_time-variable*
v:lc_time	時刻のメッセージに関する実行環境の現在のロケール設定。これを使
		えばVimスクリプト内で現在のロケール設定に対応できるようになる。
		技術的な詳細: LC_TIMEに等しい。この値はシステムに依存する。こ
		の変数を設定するには|:language|コマンドを使うこと。直接設定す
		ることはできない。

						*v:lnum* *lnum-variable*
v:lnum		'foldexpr' |fold-expr| と 'indentexpr' に使うための行番号。ま
		た 'guitablabel' と 'guitabtooltip' の文脈ではタブページ番号に
		なる。これらの式のどれかを評価しているときのみ有効。サンドボッ
		クス |sandbox| の中では読出し専用。

					*v:mouse_win* *mouse_win-variable*
v:mouse_win	|getchar()|でマウスクリックイベントを取得したとき、この変数に
		ウィンドウ番号が代入されている。|winnr()|と同じく番号は1から始
		まる。マウスがクリックされなかったときは0となる。

					*v:mouse_lnum* *mouse_lnum-variable*
v:mouse_lnum	|getchar()|でマウスクリックイベントを取得したとき、この変数に
		行番号が代入されている。物理行ではなく論理行。マウスがクリック
		されていないときは0となる。

					*v:mouse_col* *mouse_col-variable*
v:mouse_col	|getchar()|でマウスクリックイベントを取得したとき、この変数に
		桁番号が代入されている。|virtcol()|と同じく画面上の桁番号。マ
		ウスがクリックされていないときは0となる。

					*v:oldfiles* *oldfiles-variable*
v:oldfiles	起動時に |viminfo| から読み込まれたファイルの名前のリスト。
		これらはマークを記憶しているファイルである。リストの長さの上限
		はオプション 'viminfo' の引数 ' によって決まる(既定では 100)。
		|:oldfiles| と |c_#<| を参照。
		このリストは変更可能であるが、後で |viminfo| ファイルに書き込ま
		れるものには影響しない。文字列以外の値を使うと問題を引き起こす
		だろう。
		{|+viminfo| 機能つきでコンパイルされたときのみ有効}

					*v:operator* *operator-variable*
v:operator	ノーマルモードにおいて最後に実行したオペレータコマンド。基本的に
		1文字である。例外は <g> や <z> で始まるコマンドで、その場合は2文
		字になる。|v:prevcount| と |v:register| と組み合わせて使うとよ
		い。オペレータ待機モードをキャンセルして、それからオペレータを
		使いたいときに便利である。例: >
			:omap O <Esc>:call MyMotion(v:operator)<CR>
<		この値は他のオペレータが入力されるまでセットされてい
		る。よって空になると期待してはいけない。
		|:delete|, |:yank| などの Ex コマンドに対しては v:operator は
		セットされない。
		読出し専用。

					*v:prevcount* *prevcount-variable*
v:prevcount	最後のノーマルモードコマンドに与えられたカウントの値。前のコマ
		ンドのv:countの値である。ビジュアルモードやオペレータ待機モー
		ドをキャンセルし、その後にカウントを使う場合に便利である。
		例: >
			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
<		読出し専用。

					*v:profiling* *profiling-variable*
v:profiling	通常時は0。":profile start" を実行すると1が代入される。
		|profiling|を参照。

					*v:progname* *progname-variable*
v:progname	Vimを起動したときのプログラム名(パスは除かれる)。|view|、
		|evim| などの名前やシンボリックリンクなどで起動した場合に特別な
		初期化を行うのに便利。
		読出し専用。

					*v:register* *register-variable*
v:register	現在のノーマルモードコマンドに適用されるレジスタの名前 (そのコ
		マンドが実際にレジスタを使うかどうかには依らない)。または、現
		在実行しているノーマルモードマッピング用のレジスタの名前 (レジ
		スタを使うカスタムコマンドの中で使う)。レジスタが指定されなかっ
		たときはデフォルトレジスタ '"' になる。'clipboard' に
		"unnamed" か "unnamedplus" が含まれているときはデフォルトはそ
		れぞれ '*' か '+' になる。
		|getreg()| と |setreg()| も参照。

					*v:scrollstart* *scrollstart-variable*
v:scrollstart	画面のスクロールの原因となったスクリプトや関数を説明する
		文字列。空であるときのみ代入される。よってこの変数には最初の原
		因だけが記録されている。原因がキーボードから入力されたコマンド
		の場合は "Unknown" が代入される。
		スクリプトを実行したとき現れたhit-enterプロンプトの原因を探る
		ために便利。

					*v:servername* *servername-variable*
v:servername	|x11-clientserver|に登録されている名前。
		読出し専用。


v:searchforward			*v:searchforward* *searchforward-variable*
		検索方向: 前方検索の後なら1、後方検索の後なら0。|quote/| で示す
		方法によって最終検索パターンを直接セットしたときは0(前方検索)
		にセットされる。関数から戻るとき、この値は呼び出し前の値に復元
		される。
		|function-search-undo|。
		読み書き両用。

					*v:shell_error* *shell_error-variable*
v:shell_error	最後に実行したシェルコマンドの結果。シェルコマンドの実行時にな
		にかエラーがあったならば、非零の値を取る。問題がなければ零にな
		る。これはシェルがエラーコードをVimに通知する時のみ働く。コマ
		ンドが実行されなかった時には、値として-1が良く使われる。読出し
		専用。
		例: >
	:!mv foo bar
	:if v:shell_error
	:  echo 'could not rename "foo" to "bar"!'
	:endif
<		また "shell_error" は、以前の版のVimとの互換性の為に動作する。

					*v:statusmsg* *statusmsg-variable*
v:statusmsg	最後に表示されたステータスメッセージ。この変数は代入すること
		が許されている。

					*v:swapname* *swapname-variable*
v:swapname	オートコマンド|SwapExists|を実行している最中のみ有効。見つかっ
		たスワップファイルの名前。読出し専用。

					*v:swapchoice* *swapchoice-variable*
v:swapchoice	イベント|SwapExists|により実行されたオートコマンドが、見つかっ
		たスワップファイルをどう処理するかをこの変数に代入する。
			'o'	読込専用で開く
			'e'	とにかく編集する
			'r'	復活させる
			'd'	スワップファイルを削除する
			'q'	終了する
			'a'	中止する
		この変数の値は1文字の文字列でなければならない。値が空のときは
		オートコマンドSwapExistsが存在しないときと同じようにユーザに問
		い合わせる。既定値は空。

					*v:swapcommand* *swapcommand-variable*
v:swapcommand	ファイルを開いた後に実行するノーマルモードコマンド。オートコマ
		ンド|SwapExists|で、他のVimインスタンスにファイルを開かせ、指
		定位置までジャンプするために使うことができる。例えば、あるタグ
		へジャンプするには、この変数に ":tag tagname\r" という値を代入
		する。":edit +cmd file" を実行させるには ":cmd\r" を代入する。

				*v:termresponse* *termresponse-variable*
v:termresponse	termcapのエントリ|t_RV|で端末から返されるエスケープシーケン
		ス。ESC [またはCSIで始まり、途中数字と ';' と '.' だけから構成
		され 'c' で終わるエスケープシーケンスを受け取ったとき代入され
		る。このオプションがセットされるとオートコマンドイベント
		TermResponseが発生し、端末からの応答に反応することができる。
		新しいxtermからの応答は次の形式である:
		 "<Esc>[ Pp ; Pv ; Pc c"。ここでPpは端末のタイプ: 0ならvt100、
		 1ならvt220。Pvはパッチレベル(パッチ95で導入されたため常
		 に95以上)。Pcは常に0。
		{Vimが|+termresponse|機能付きでコンパイルされたときのみ有効}

				*v:this_session* *this_session-variable*
v:this_session	最後にロードされたか、セーブされたセッションファイルの完全な
		ファイル名。|:mksession|を参照。この変数は代入することが許さ
		れている。それ以前にセーブされたセッションがなければ、この変数
		は空となる。
		また "this_session" は、以前の版のVimとの互換性の為に動作する。

					*v:throwpoint* *throwpoint-variable*
v:throwpoint	最も直近に捕捉されてまだ終了していない例外が発生した位置。キー
		ボードから入力されたコマンドは記録されていない。|v:exception|
		と|throw-variables|も参照。
		例: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "Exception from" v:throwpoint
	:endtry
<		出力: "Exception from test.vim, line 2"

						*v:val* *val-variable*
v:val		辞書|Dictionary|の現在の要素の値。|map()|と|filter()|で使わ
		れる式を評価している最中のみ有効。
		読出し専用。

				*v:version* *version-variable*
v:version	Vimのバージョン番号。メジャーバージョン番号は100倍され、マイ
		ナーバージョン番号と足されている。Version 5.0は500。Version
		5.1 (5.01)は501となる。読出し専用。また "version" は、以前の版
		のVimとの互換性の為に動作する。
		特定のパッチが適用されているかを調べるには|has()|を使う。例: >
			if has("patch123")
<		5.0と5.1には両方ともパッチ123が存在しているが、バージョンが違
		えば番号は同じでもパッチの内容は全く異なっている。

					*v:warningmsg* *warningmsg-variable*
v:warningmsg	最後に表示された警告メッセージ。この変数は代入することが許され
		ている。

					*v:windowid* *windowid-variable*
v:windowid	X11 ベースの GUI を使っているとき、もしくは端末の Vim を使って
		いて X サーバーに接続しているとき (|-X|) は、ウィンドウ ID が
		セットされる。
		MS-Windows の GUI を使っているときはウィンドウハンドルがセット
		される。
		それ以外では値はゼロである。
		Note: Vim の中のウィンドウを扱うときは |winnr()| を使う。

==============================================================================
4. 組み込み関数						*functions*

(関数名の上でCTRL-]を使うことで、詳細な説明へ飛ぶことができる)

使用法				結果	説明		~

abs( {expr})			浮動小数点数または数値	{expr}の絶対値
acos( {expr})			浮動小数点数	{expr}のアークコサイン
add( {list}, {item})		リスト	{item}をリスト{list}に追加する
and( {expr}, {expr})		数値    ビット論理積
append( {lnum}, {string})	数値	{string}を{lnum}行目に付け加える
append( {lnum}, {list})		数値	行{list}を{lnum}行目に付け加える
argc()				数値	引数内のファイルの数
argv( {nr})			文字列	引数の第{nr}番目
argv( )				リスト	引数リスト
asin( {expr})			浮動小数点数	{expr}のアークサイン
atan( {expr})			浮動小数点数	{expr}のアークタンジェント
atan2( {expr}, {expr})		浮動小数点数	{expr1} / {expr2} のアークタン
						ジェント
browse( {save}, {title}, {initdir}, {default})
				文字列	ファイル選択ダイアログを表示
browsedir( {title}, {initdir})  文字列	ディレクトリ選択ダイアログを表示
bufexists( {expr})		数値	バッファ{expr}が存在すればTRUE
buflisted( {expr})		数値	バッファ{expr}がリストにあるならTRUE
bufloaded( {expr})		数値	バッファ{expr}がロード済みならTRUE
bufname( {expr})		文字列	バッファ{expr}の名前
bufnr( {expr})			数値	バッファ{expr}の番号
bufwinnr( {nr})			数値	バッファ{nr}のウィンドウ番号
byte2line( {byte})		数値	{byte}番目のバイトの行番号
byteidx( {expr}, {nr})		数値	{expr}の{nr}文字目のバイトインデックス
call( {func}, {arglist} [, {dict}])
				任意	引数{arglist}をつけて{func}を呼ぶ
ceil( {expr})			浮動小数点数	{expr} を切り上げる
changenr()			数値	現在の変更番号
char2nr( {expr}[, {utf8}])	数値	{expr}の先頭文字のASCII/UTF8コード
cindent( {lnum})		数値	{lnum}行目のCインデント量
clearmatches()			なし	全マッチをクリアする
col( {expr})			数値	カーソルかマークのカラム番号nr
complete( {startcol}, {matches}) なし	挿入モード補完を設定する
complete({startcol}, {matches})	文字列  挿入モード補完の結果を設定する
complete_add( {expr})		数値	補完候補を追加する
complete_check()		数値	補完中に押されたキーをチェックする
confirm( {msg}, {choices} [, {default} [, {type}]])
				数値	ユーザへの選択肢と番号
copy( {expr})			任意	{expr}の浅いコピーを作る
cos( {expr})			浮動小数点数	{expr} の余弦(コサイン)
cosh( {expr})			浮動小数点数	{expr}のハイパボリックコサイン
count( {list}, {expr} [, {start} [, {ic}]])
				数値	 {list}中に{expr}が何個現れるか数える
cscope_connection( [{num} , {dbpath} [, {prepend}]])
				数値	cscope接続の存在を判定する
cursor( {lnum}, {col} [, {coladd}])
				数値	カーソルを{lnum}, {col}, {coladd}へ移動
cursor( {list})			数値	カーソルを{list}の位置へ移動
deepcopy( {expr})		任意	{expr}の完全なコピーを作る
delete( {fname})		数値	ファイル{fname}を消す
did_filetype()			数値	FileTypeのautocommandが実行されたか?
diff_filler( {lnum})		数値	差分モードで{lnum}に挿入された行
diff_hlID( {lnum}, {col})	数値	差分モードで{lnum}/{col}位置の強調
empty( {expr})			数値	{expr}が空ならTRUE
escape( {string}, {chars})	文字列	{string}内の{chars}を '\' でエスケープ
eval( {string})			任意	{string}を評価し、値を得る
eventhandler( )			数値	イベントハンドラの内側ならTRUE
executable( {expr})		数値	実行可能な{expr}が存在するなら1
exists( {var})			数値	変数{var}が存在したらTRUE
extend( {expr1}, {expr2} [, {expr3}])
				リスト/辞書 {expr1}に{expr2}の要素を挿入
exp( {expr})			浮動小数点数	{expr}の指数
expand( {expr} [, {nosuf} [, {list}]])
				任意	{expr}内の特別なキーワードを展開
feedkeys( {string} [, {mode}])	数値	先行入力バッファにキーシーケンスを追加
filereadable( {file})		数値	{file}が読みこみ可能ならTRUE
filewritable( {file})		数値	{file}が書き込み可能ならTRUE
filter( {expr}, {string})	リスト/辞書  {string}が0となる要素を{expr}から
					とり除く
finddir( {name}[, {path}[, {count}]])
				文字列	{path}からディレクトリ{name}を探す
findfile( {name}[, {path}[, {count}]])
				文字列	{path}からファイル{name}を探す
float2nr( {expr})		数値	浮動小数点数 {expr} を数値に変換する
floor( {expr})			浮動小数点数	{expr} を切り捨てる
fmod( {expr1}, {expr2})		浮動小数点数	{expr1} / {expr2} の余り
fnameescape( {fname})		文字列	{fname} 内の特殊文字をエスケープする
fnamemodify( {fname}, {mods})	文字列	ファイル名を変更
foldclosed( {lnum})		数値	{lnum}の折り畳みの最初の行(閉じている
					なら)
foldclosedend( {lnum})		数値	{lnum}の折り畳みの最後の行(閉じている
					なら)
foldlevel( {lnum})		数値	{lnum}の折り畳みレベル
foldtext( )			文字列	閉じた折り畳みに表示されている行
foldtextresult( {lnum})		文字列	{lnum}で閉じている折り畳みのテキスト
foreground( )			数値	Vimウィンドウを前面に移動する
function( {name})		Funcref 関数{name}への参照を取得
garbagecollect( [{atexit}])	なし	メモリを解放する。循環参照を断ち切る
get( {list}, {idx} [, {def}])	任意	{list}や{def}から要素{idx}を取得
get( {dict}, {key} [, {def}])	任意	{dict}や{def}から要素{key}を取得
getbufline( {expr}, {lnum} [, {end}])
				リスト	バッファ{expr}の{lnum}から{end}行目
getbufvar( {expr}, {varname} [, {def}])
				任意	バッファ{expr}の変数 {varname}
getcmdline()			文字列	現在のコマンドラインを取得
getcmdpos()			数値	コマンドラインのカーソル位置を取得
getcmdtype()			文字列	現在のコマンドラインの種類を取得
getcwd()			文字列	現在の作業ディレクトリ
getfperm( {fname})		文字列	ファイル{fname}の許可属性を取得
getfsize( {fname})		数値	ファイル{fname}のバイト数を取得
getfontname( [{name}])		文字列	使用しているフォントの名前
getftime( {fname})		数値	ファイルの最終更新時間
getftype( {fname})		文字列	ファイル{fname}の種類の説明
getline( {lnum})		文字列	現在のバッファから行の内容を取得
getline( {lnum}, {end})		リスト	カレントバッファの{lnum}から{end}行目
getloclist( {nr})		リスト	ロケーションリストの要素のリスト
getmatches()			リスト	現在のマッチのリスト
getpid()			数値	Vim のプロセス ID
getpos( {expr})			リスト	カーソル・マークなどの位置を取得
getqflist()			リスト	quickfixリストの要素のリスト
getreg( [{regname} [, 1]])	文字列	レジスタの中身を取得
getregtype( [{regname}])	文字列	レジスタの種類を取得
gettabvar( {nr}, {varname} [, {def}])
				任意	タブ{nr}の変数{varname}または{def}
gettabwinvar( {tabnr}, {winnr}, {name} [, {def}])
				任意	タブページ{tabnr}の{winnr}の{name}
getwinposx()			数値	GUI vim windowのX座標
getwinposy()			数値	GUI vim windowのY座標
getwinvar( {nr}, {varname} [, {def}])
				文字列	ウィンドウ{nr}の変数{varname}
glob( {expr} [, {nosuf} [, {list}]])
				任意	{expr}内のfile wildcardを展開
globpath( {path}, {expr} [, {flag}])
				文字列	{path}の全ディレクトリに対し
					glob({expr})を行う
has( {feature})			数値	機能{feature}がサポートならばTRUE
has_key( {dict}, {key})		数値	{dict}が要素{key}を持つならTRUE
haslocaldir()			数値	現在のウィンドウで|:lcd|が実行された
					ならTRUE
hasmapto( {what} [, {mode} [, {abbr}]])
				数値	{what}へのマッピングが存在するならTRUE
histadd( {history},{item})	文字列	ヒストリに追加
histdel( {history} [, {item}])	文字列	ヒストリからitemを削除
histget( {history} [, {index}])	文字列	ヒストリから{index}アイテムを取得
histnr( {history})		数値	ヒストリの数
hlexists( {name})		数値	highligth group {name}が存在したらTRUE
hlID( {name})			数値	highlight group {name}のID
hostname()			文字列	vimが動作しているマシンの名前
iconv( {expr}, {from}, {to})	文字列	{expr}のエンコーディングを変換する
indent( {lnum})			文字列	行{lnum}のインデントを取得
index( {list}, {expr} [, {start} [, {ic}]])
				数値	{list}中に{expr}が現れる位置
input( {prompt} [, {text} [, {completion}]])
				文字列	ユーザからの入力を取得
inputdialog( {p} [, {t} [, {c}]]) 文字列  input()と同様。GUIのダイアログを使用
inputlist( {textlist})		数値	ユーザに選択肢から選ばせる
inputrestore()			数値	先行入力を復元する
inputsave()			数値	先行入力を保存し、クリアする
inputsecret( {prompt} [, {text}]) 文字列  input()だがテキストを隠す
insert( {list}, {item} [, {idx}]) リスト  {list}に要素{item}を挿入 [{idx}の前]
invert( {expr})			数値    ビット反転
isdirectory( {directory})	数値	{directory}がディレクトリならばTRUE
islocked( {expr})		数値	{expr}がロックされているならTRUE
items( {dict})			リスト	{dict}のキーと値のペアを取得
join( {list} [, {sep}])		文字列	{list}の要素を連結して文字列にする
keys( {dict})			リスト	{dict}のキーを取得
len( {expr})			数値	{expr}の長さを取得
libcall( {lib}, {func}, {arg}	文字列	ライブラリ{lib}の関数{func}をコール
libcallnr( {lib}, {func}, {arg})  数値  上と同じ。ただし数値を返す
line( {expr})			数値	行番号の取得
line2byte( {lnum})		数値	行{lnum}のバイトカウント
lispindent( {lnum})		数値	{lnum}行目のLispインデント量を取得
localtime()			数値	現在時刻
log( {expr})			浮動小数点数	{expr}の自然対数(底e)
log10( {expr})			浮動小数点数	浮動小数点数 {expr} の 10 を底
						とする対数
luaeval( {expr}[, {expr}])	任意	|Lua| の式を評価する
map( {expr}, {string})		リスト/辞書  {expr}の各要素を{expr}に変える
matchadd( {group}, {pattern}[, {priority}[, {id}]])
				数値	{pattern} を {group} で強調表示する
maparg( {name}[, {mode} [, {abbr} [, {dict}]]])
				文字列/辞書
					モード{mode}でのマッピング{name}の値
mapcheck( {name}[, {mode} [, {abbr}]])
				文字列	{name}にマッチするマッピングを確認
match( {expr}, {pat}[, {start}[, {count}]])
				数値	{expr}内で{pat}がマッチする位置
matcharg( {nr})			リスト	|:match|の引数
matchdelete( {id})		数値	{id} で指定されるマッチを削除する
matchend( {expr}, {pat}[, {start}[, {count}]])
				数値	{expr}内で{pat}が終了する位置
matchlist( {expr}, {pat}[, {start}[, {count}]])
				リスト	{expr}内の{pat}のマッチと部分マッチ
matchstr( {expr}, {pat}[, {start}[, {count}]])
				文字列	{expr}内の{count}番目の{pat}のマッチ
max( {list})			数値	{list}内の要素の最大値
min( {list})			数値	{list}内の要素の最小値
mkdir( {name} [, {path} [, {prot}]])
				数値	ディレクトリ{name}を作成
mode( [expr])			文字列	現在の編集モード
mzeval( {expr})			任意	|MzScheme| の式を評価する
nextnonblank( {lnum})		数値	{lnum}行目以降で空行でない行の行番号
nr2char( {expr}[, {utf8}])	文字列	ASCII/UTF8コード{expr}で示される文字
or( {expr}, {expr})		数値    ビット論理和
pathshorten( {expr})		文字列	path内の短縮したディレクトリ名
pow( {x}, {y})			浮動小数点数	{x} の {y} 乗
prevnonblank( {lnum})		数値	{lnum}行目以前の空行でない行の行番号
printf( {fmt}, {expr1}...)	文字列	文字列を組み立てる
pumvisible()			数値	ポップアップメニューが表示されているか
pyeval( {expr})			任意	|Python| の式を評価する
py3eval( {expr})		任意	|python3| の式を評価する
range( {expr} [, {max} [, {stride}]])
				リスト	{expr}から{max}までの要素のリスト
readfile( {fname} [, {binary} [, {max}]])
				リスト	ファイル{fname}から行のリストを取得
reltime( [{start} [, {end}]])	リスト	時刻の値を取得
reltimestr( {time})		文字列	時刻の値を文字列に変換
remote_expr( {server}, {string} [, {idvar}])
				文字列	式を送信する
remote_foreground( {server})	数値	Vimサーバを前面に出す
remote_peek( {serverid} [, {retvar}])
				数値	返信文字列を確認する
remote_read( {serverid})	文字列	返信文字列を読み込む
remote_send( {server}, {string} [, {idvar}])
				文字列	キーシーケンスを送信する
remove( {list}, {idx} [, {end}])  任意	{list}から{idx}と{end}間の要素を削除
remove( {dict}, {key})		任意	{dict}から要素{key}を削除
rename({from}, {to})		数値	{file}から{to}へファイル名変更
repeat( {expr}, {count})	文字列	{expr}を{count}回繰り返す
resolve( {filename})		文字列	ショートカットが指す先のファイル名
reverse( {list})		文字列	{list}をその場で反転させる
round( {expr})			浮動小数点数	{expr} を四捨五入する
screencol()			数値	現在のカーソル列
screenrow()			数値	現在のカーソル行
search( {pattern} [, {flags} [, {stopline} [, {timeout}]]])
				数値	{pattern} を検索する
searchdecl( {name} [, {global} [, {thisblock}]])
				数値	変数の宣言を検索
searchpair( {start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				数値	開始/終端のペアの他方を検索
searchpairpos( {start}, {middle}, {end} [, {flags} [, {skip} [...]]])
				リスト	開始/終端のペアの他方を検索
searchpos( {pattern} [, {flags} [, {stopline} [, {timeout}]]])
				リスト	{pattern}を検索
server2client( {clientid}, {string})
				数値	返信文字列を送信する
serverlist()			文字列	利用可能なサーバのリストを取得
setbufvar( {expr}, {varname}, {val})	バッファ{expr}内の変数{varname}に{val}
					をセット
setcmdpos( {pos})		数値	コマンドライン内のカーソル位置を設定
setline( {lnum}, {line})	数値	行{lnum}に{line}(文字列)をセット
setloclist( {nr}, {list}[, {action}])
				数値	{list}を使ってロケーションリストを変更
setmatches( {list})		数値	マッチのリストを復元する
setpos( {expr}, {list})		なし	{expr}の位置を{list}にする
setqflist( {list}[, {action}])	数値	{list}を使ってQuickFixリストを変更
setreg( {n}, {v}[, {opt}])	数値	レジスタの値とタイプを設定
settabvar( {nr}, {varname}, {val})	タブページ{nr}の変数{varname}を{val}に
					設定する
settabwinvar( {tabnr}, {winnr}, {varname}, {val})  タブページ{tabnr}内のウィン
					ドウ{winnr}の変数{varname}に{val}を
					セット
setwinvar( {nr}, {varname}, {val})	ウィンドウ{nr}の変数{varname}に{val}を
					セット
sha256( {string})		文字列	{string}のSHA256チェックサム
shellescape( {string} [, {special}])
				文字列	{string}をシェルコマンド引数として使う
					ためにエスケープする。
shiftwidth()			数値	実際に使用される 'shiftwidth' の値
simplify( {filename})		文字列	ファイル名を可能なかぎり簡略化する
sin( {expr})			浮動小数点数	{expr} の正弦(サイン)
sinh( {expr})			浮動小数点数	{expr}のハイパボリックサイン
sort( {list} [, {func} [, {dict}]])
				リスト	比較に{func}を使って{list}をソートする
soundfold( {word})		文字列	{word}のsound-fold
spellbadword()			文字列	カーソル位置のスペルミスした単語
spellsuggest( {word} [, {max} [, {capital}]])
				リスト	スペリング補完
split( {expr} [, {pat} [, {keepempty}]])
				リスト	{expr}を{pat}で区切ってリストを作る
sqrt( {expr})			浮動小数点数	{expr} の平方根
str2float( {expr})		浮動小数点数	文字列を浮動小数点数に変換する
str2nr( {expr} [, {base}])	数値	文字列を数値に変換する
strchars( {expr})		数値	文字列{expr}の文字の数
strdisplaywidth( {expr} [, {col}]) 数値 文字列{expr}の表示幅
strftime( {format}[, {time}])	文字列	指定されたフォーマットでの時刻
stridx( {haystack}, {needle}[, {start}])
				数値	{haystack}内の{needle}のインデックス
string( {expr})			文字列	{expr}の値の文字列表現
strlen( {expr})			数値	文字列{expr}の長さ
strpart( {src}, {start}[, {len}])
				文字列	{src}内{start}から長さ{len}の部分
strridx( {haystack}, {needle} [, {start}])
				数値	{haystack}内の最後の{needle}のインデッ
					クス
strtrans( {expr})		文字列	文字列を表示可能に変更
strwidth( {expr})		数値	文字列{expr}の表示セル幅
submatch( {nr})			文字列	":s" やsubstitute()における特定のマッチ
substitute( {expr}, {pat}, {sub}, {flags})
				文字列	{expr}の{pat}を{sub}に置換え
synID( {line}, {col}, {trans})	数値	{line}と{col}のsyntax IDを取得
synIDattr( {synID}, {what} [, {mode}])
				文字列	syntax ID{synID}の属性{what}を取得
synIDtrans( {synID})		数値	{synID}の翻訳されたsyntax ID
synconcealed( {lnum}, {col})	リスト  Conceal の情報
synstack( {lnum}, {col})	リスト	{lnum}行{col}列目における構文IDの
					スタック
system( {expr} [, {input}])	文字列	シェルコマンド{expr}の出力結果
tabpagebuflist( [{arg}])	リスト	タブページ内のバッファ番号のリスト
tabpagenr( [{arg}])		数値	現在または最後のタブページの番号
tabpagewinnr( {tabarg}[, {arg}])
				数値	タブページ内の現在のウィンドウの番号
taglist( {expr})		リスト	{expr}にマッチするタグのリスト
tagfiles()			リスト	使用しているタグファイルのリスト
tempname()			文字列	テンポラリファイルの名前
tan( {expr})			浮動小数点数	{expr}のタンジェント
tanh( {expr})			浮動小数点数	{expr}のハイパボリックタンジェ
						ント
tolower( {expr})		文字列	文字列{expr}を小文字にする
toupper( {expr})		文字列	文字列{expr}を大文字にする
tr( {src}, {fromstr}, {tostr})	文字列	{src}中に現れる文字{fromstr}を{tostr}
					に変換する。
trunc( {expr})			浮動小数点数	浮動小数点数{expr}を切り詰める
type( {name})			数値	変数{name}の型
undofile( {name})		文字列	{name}に対するアンドゥファイルの名前
undotree()			リスト	アンドゥファイルツリー
values( {dict})			リスト	{dict}の値のリスト
virtcol( {expr})		数値	カーソルのスクリーンカラム位置
visualmode( [expr])		文字列	最後に使われたビジュアルモード
wildmenumode()			数値	'wildmenu' モードが有効かどうか
winbufnr( {nr})			数値	ウィンドウ{nr}のバッファ番号
wincol()			数値	カーソル位置のウィンドウ桁
winheight( {nr})		数値	ウィンドウ{nr}の高さ
winline()			数値	カーソル位置のウィンドウ行
winnr()				数値	現在のウィンドウの番号
winrestcmd()			文字列	ウィンドウサイズを復元するコマンド
winrestview( {dict})		なし	現在のウィンドウのビューを復元
winsaveview()			辞書	現在のウィンドウのビューを保存
winwidth( {nr})			数値	ウィンドウ{nr}の幅を取得
writefile( {list}, {fname} [, {binary}])
				数値	行のリストをファイル{fname}に書き込む
xor( {expr}, {expr})		数値	ビット排他的論理和


abs({expr})							*abs()*
		{expr} の絶対値を返す。{expr} の値が浮動小数点数である場合は浮
		動小数点数を返す。{expr} が|Number|に変換可能な場合は数値が戻
		り値になる。それ以外の場合はエラーメッセージを表示し、-1
		を返す。
		例: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


acos({expr})							*acos()*
		{expr} の逆余弦 (アークコサイン) をラジアンで返す。
		値は [0, pi] の範囲の浮動小数点数 (|Float|)。
		{expr} は [-1, 1] の範囲の浮動小数点数 (|Float|) か数値
		(|Number|) でなければならない。
		例: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


add({list}, {expr})					*add()*
		リスト|List|{list}の末尾に要素{expr}を追加する。結果のリストを
		返す。例: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		Note {expr}がリストのときは、1個の要素として追加される。リスト
		を連結するには|extend()|を使う。
		他の位置に要素を追加するには|insert()|を使う。


and({expr}, {expr})					*and()*
		二つの引数のビット論理積。引数は数値に変換される。リスト、辞
		書、浮動小数点数を指定するとエラーになる。
		例: >
			:let flag = and(bits, 0x80)


append({lnum}, {expr})					*append()*
		{expr}がリスト|List|のときは、各要素をカレントバッファの{lnum}
		行目以降にテキストとして追加する。
		リストでないときは、{expr}をテキストとしてカレントバッファの
		{lnum}行目以降にテキストとして追加する。
		{lnum}は0でもよく、その場合は1行目の前に行を挿入する。
		失敗した場合は1を返す({lnum}が不正な範囲であるか、メモリ不足)。
		成功なら0を返す。例: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])
<
							*argc()*
argc()		カレントウィンドウの引数リスト内の、ファイルの数を返す。
		|arglist|を参照。

							*argidx()*
argidx()	引数リスト内の現在のインデックスを返す。最初のファイルは0とな
		る。argc() - 1が最後のファイルとなる。|arglist|を参照。

							*argv()*
argv([{nr}])	結果は引数リスト内の、{nr}番目のファイル。|arglist|を参照。
		"argv(0)" は一番最初のファイルを示す。例: >
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '.')
	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
	:  let i = i + 1
	:endwhile
<		引数{nr}が指定されなかった場合は、引数リスト|arglist|全体を
		返す。

asin({expr})						*asin()*
		{expr} の逆正弦 (アークサイン) をラジアンで返す。
		値は [-pi/2, pi/2] の範囲の浮動小数点数 (|Float|)。
		{expr} は [-1, 1] の範囲の浮動小数点数 (|Float|) か数値
		(|Number|) でなければならない。
		例: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599
		{|+float| 機能つきでコンパイルされたときのみ有効}


atan({expr})						*atan()*
		{expr} の逆正接(アークタンジェント)の主値を浮動小数点数
		|Float| で返す。主値はラジアンで[-pi/2, +pi/2]の範囲内にある。
		{expr} は |Float| か |Number| に評価されなければならない。
		例: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405
		{|+float| 機能つきでコンパイルされたときのみ有効}


atan2({expr1}, {expr2})					*atan2()*
		{expr1} / {expr2} の逆正接 (アークタンジェント) をラジアンで返
		す。値は [-pi, pi] の範囲の浮動小数点数 (|Float|)。
		{expr1} と {expr2} は浮動小数点数 (|Float|) か数値 (|Number|)
		でなければならない。
		例: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


							*browse()*
browse({save}, {title}, {initdir}, {default})
		ファイル選択ダイアログを起動。"has("browse")" が非零を返すとき
		(幾つかのGUIバージョンに限定)だけ利用可能。
		入力フィールドの意味は:
		    {save}	非零ならば書込み用ファイルの選択
		    {title}	ダイアログのタイトル
		    {initdir}	ダイアログの始まるディレクトリ
		    {default}	ファイル名の省略値
		ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブ
		ラウジングが不可能ならば、空文字列が戻ってくる。

							*browsedir()*
browsedir({title}, {initdir})
		ディレクトリ選択ダイアログを起動。"has("browse")" が非零を返す
		とき(幾つかのGUIバージョンに限定)だけ利用可能。
		ディレクトリ選択ダイアログがないシステムにおいてはファイル選択
		ダイアログが使われる。その場合は、指定したいディレクトリの中の
		ファイルを選択すること。
		入力フィールドの意味は:
		    {title}	ダイアログのタイトル
		    {initdir}	ダイアログの始まるディレクトリ
		ダイアログがキャンセルされるか、何かエラーがあるか、もしくはブ
		ラウジングが不可能ならば、空文字列が戻ってくる。

							*bufexists()*
bufexists({expr})
		結果は数値で、{expr}と呼ばれるバッファが存在すれば非零となる。
		{expr}が数値の場合、バッファ番号とみなされる。
		{expr}が文字列の場合、バッファ名に正確にマッチしなければな
		らない。名前として以下のものが許される:
		- カレントディレクトリからの相対パス。
		- フルパス。
		- 'buftype' が "nofile" であるバッファの名前
		- URL名。
		バッファリストにないバッファも検索される。
		Note |:buffers|の出力で、ヘルプファイルは短い名前でリストされ
		ているが、bufexists()は長い名前でないと見つけることができない。
		ある名前を bufexists() に与えて非零になったとしても、その名前
		をコマンド |:buffer| に与える際には |expand()| を使って展開し
		なければならない場合がある。特に MS-Windows の "c:\DOCUME~1"
		という 8.3 名形式において。
		代替ファイル名が存在するかを判定するには "bufexists(0)" を使う。
							*buffer_exists()*
		以前の名前: buffer_exists().

buflisted({expr})					*buflisted()*
		戻り値は数値で、{expr}と呼ばれるバッファが存在しリストされてい
		る ('buflisted' オプションがオンになっている) ならば結果は非零
		となる。引数{expr}は|bufexists()|と同じように扱われる。

							*bufloaded()*
bufloaded({expr})
		戻り値は数値で、{expr}と呼ばれるバッファが存在しロード済み(
		ウィンドウに表示されているか、隠されているかは問わない)ならば
		結果は非零となる。引数{expr}は|bufexists()|と同じように扱われ
		る。

							*bufname()*
bufname({expr})
		戻り値はバッファの名前。バッファ名はコマンド ":ls" で表示され
		るものと同様。
		{expr}が数値ならば、その番号のバッファ名が返される。0は現在の
		ウィンドウの代替バッファを意味する。{expr}が文字列ならば、バッ
		ファ名に対してファイル名マッチング |file-pattern| を行うパター
		ンとなる。このマッチングは常に、'magic' をセットし 'cpoptions'
		を空にした状態で行われる。複数マッチしてしまった場合には空文字
		列が返される。
		"" や "%" は現在のバッファを意味し、"#" は代替バッファを意味す
		る。
		完全マッチのものが優先され、完全マッチがなければ、バッファ名の
		先頭でのマッチ、末尾でのマッチ、中間でのマッチが探される。完全
		マッチのみを探すには、パターン先頭に "^" を、末尾に "$" をつけ
		る。
		まずバッファリストにあるバッファが探される。そこで1個だけマッ
		チが見つかればそれを返す。次にバッファリストにないものが探され
		る。
		{expr}が文字列のときに、それをバッファ番号として使いたいなら
		ば、0を足すことによって強制的に数値にすることができる: >
			echo bufname("3" + 0)
<		バッファが存在しないか名前を持っていない場合には、空文字列が返
		される。 >
  bufname("#")			alternate buffer name
  bufname(3)			name of buffer 3
  bufname("%")			name of current buffer
  bufname("file2")		name of buffer where "file2" matches.
<							*buffer_name()*
		以前の名前: buffer_name().

							*bufnr()*
bufnr({expr} [, {create}])
		結果はバッファの番号。バッファ番号はコマンド ":ls" で表示され
		るものと同様。{expr}の使い方は前述のbufname()を参照。バッファ
		が存在しない場合-1が返される。ただし、{create}が与えられて0で
		ないときは、バッファリストに載せない新しいバッファを作成しその
		番号を返す。
		bufnr("$")は最後のバッファを意味する: >
  :let last_buffer = bufnr("$")
<		結果は存在しているバッファのうちで、もっとも大きなバッファ番号
		となる。 Note そのバッファ番号より小さいバッファ番号を持つ(ハ
		ズの)バッファが、必ずしも全て存在するとは限らない。なぜなら
		":bwipeout" がバッファを消すことができるからだ。バッファが存在
		するかテストするにはbufexists()を使う。
							*buffer_number()*
		以前の名前: buffer_number().
							*last_buffer_nr()*
		bufnr("$")の以前の名前: last_buffer_nr().

							*bufwinnr()*
bufwinnr({expr})
		結果は数値で、バッファ{expr}に関連付けられた最初のウィンドウの
		番号。{expr}の使い方は前述の|bufname()|を参照。バッファ{expr}
		が存在しないか、ウィンドウが無い場合には-1を返す。例: >

	echo "A window containing buffer 1 is " . (bufwinnr(1))

<		この番号は|CTRL-W_w|や ":wincmd w" |:wincmd|で使える。
		カレントタブページ内のウィンドウだけを探す。
							*byte2line()*
byte2line({byte})
		カレントバッファの先頭から{byte}番目の文字が、何行目に含まれる
		かを返す。これにはカレントバッファの 'fileformat' に依存した、
		改行文字も含まれる。先頭の文字にはバイトカウント1が与えられる。
		|line2byte()|と|go|と|:goto|も参照。
		{|+byte_offset|機能付きでコンパイルされたときのみ有効}

byteidx({expr}, {nr})					*byteidx()*
		文字列{expr}の{nr}番目の文字のバイトインデックスを返す。
		最初の文字の{nr}は0であり、戻り値は0となる。この関数はマルチバ
		イト文字が存在するときのみ有用であり、そうでなければこの関数が
		返す値は{nr}に等しい。合成文字は別々の文字と数えられる。
		例 : >
			echo matchstr(str, ".", byteidx(str, 3))
<		は4文字目を表示する。次も同じことをする: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		{expr}が{nr}文字以下の場合は-1を返す。
		{expr}がちょうど{nr}文字の場合は文字列の長さ(バイト単位)を返す。

call({func}, {arglist} [, {dict}])			*call()* *E699*
		リスト|List|{arglist}の要素を引数として関数{func}を呼ぶ。
		{func}は|Funcref|でも関数の名前でもよい。
		a:firstlineとa:lastlineにはカレント行が代入される。
		呼び出した関数の戻り値を返す。
		{dict}は "dict" 属性つきの関数用で、これがローカル変数 "self"
		に代入される。|Dictionary-function|を参照。

ceil({expr})							*ceil()*
		{expr} 以上となる最小の整数を浮動小数点数 |Float| で返す
		(切り上げる)。
		{expr} は |Float| か |Number| に評価されなければならない。
		例: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0
		{|+float| 機能つきでコンパイルされたときのみ有効}

changenr()						*changenr()*
		最も最近の変更の番号を返す。|:undolist|で表示される番号と同じ
		であり、|:undo|コマンドの引数として使うことができる。
		変更を行った直後ではその変更の番号となる。redoを行った直後は
		redoされた変更の番号となる。undoを行った直後はundoされた変更よ
		り1小さい番号になる。

char2nr({expr}[, {utf8}])					*char2nr()*
		{expr}の最初の文字のASCIIコードを返す。例: >
			char2nr(" ")		returns 32
			char2nr("ABC")		returns 65
<		{utf8} を省略、またはゼロを指定すると、現在の 'encoding' が適
		用される。"utf-8" の場合の例: >
			char2nr("á")		returns 225
			char2nr("á"[0])		returns 195
<		{utf8} に 1 を指定すると、常に utf-8 文字として扱われる。
		合成文字は個別の文字として扱われる。
		|nr2char()| はこの逆を行う。

cindent({lnum})						*cindent()*
		'cindent' で使われるのと同じC言語用のインデント規則に従った場合
		の{lnum}行目のインデント量を返す。
		インデント量はスペースで数えられ、'tabstop' の値は関係ない。
		{lnum}は|getline()|の場合と同様に扱われる。
		{lnum}が無効な値のときや|+cindent|機能なしでコンパイルされてい
		るときは-1を返す。
		|C-indenting|を参照。

clearmatches()						*clearmatches()*
		|matchadd()| と コマンド |:match| により定義されたマッチをすべ
		て消去する。

							*col()*
col({expr})	
		戻り値は数値で、{expr}で与えられる位置の桁番号(バイトインデッ
		クス)。有効な位置は:
		    .	    現在の位置
		    $	    カレント行の末尾(カレント行のバイト数+1を返す)
		    'x	    マークxの位置(マークが設定されていない場合0)
		さらに {expr} は [lnum, col] という行番号と桁番号のリストで
		あってもよい。col に "$" を指定して、ある行の最後の桁を取得す
		るのにとても便利である。"lnum" か "col" が範囲外である場合は
		0 を返す。
		行番号を取得するには|line()|を使う。行番号と桁番号両方を取得す
		るには|getpos()|を使う。
		画面上の桁番号を取得するには|virtcol()|を使う。
		Note 現在のファイルのマークしか使えないことに注意。
		例: >
			col(".")		カーソルの桁
			col("$")		カレント行の長さ+1
			col("'t")		マークtの桁
			col("'" . markname)	マークmarknameの桁
<		先頭の桁は1になる。戻り値0はエラーを意味する。
		大文字のマークは他のバッファを指しているかもしれない。
		'virtualedit' が有効なとき、カーソルが行末を越えていると、桁番
		号は行の長さより1大きい値を返す。挿入モードで桁番号を取得する
		には次のマップが使える: >
			:imap <F2> <C-O>:let save_ve = &ve<CR>
				\<C-O>:set ve=all<CR>
				\<C-O>:echo col(".") . "\n" <Bar>
				\let &ve = save_ve<CR>
<
complete({startcol}, {matches})			*complete()* *E785*
		挿入モード補完の候補を設定する。
		挿入モードでのみ使用できる。CTRL-R = |i_CTRL-R|と組み合わせて
		マッピングを作る必要がある。CTRL-Oの後や、<expr>マッピングの中
		では正しく動作しない。
		{startcol}は補完すべき単語の開始位置を示す、行内のバイトオフセッ
		トである。その位置からカーソルまでのテキストが補完すべき単語と
		なる。
		{matches}はリスト|List|でなければならない。リストの各要素が1つ
		の候補となる。この要素として許される値については
		|complete-items|を参照。
		Note この関数を呼んだ後は補完を停止させるようなテキストの挿入
		をしないように注意しなければならない。
		この関数で設定した候補は普通の挿入モード補完と同じ様にCTRL-Nと
		CTRL-Pで選択できる。設定されていればポップアップメニューが表示
		される。|ins-completion-menu|を参照。
		例: >
	inoremap <F5> <C-R>=ListMonths()<CR>
	func! ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
<		この例はそれほど役には立たないが、使い方を示している。Note 0が
		挿入されてしまわないように空文字列を返していることに注意。

complete_add({expr})				*complete_add()*
		候補のリストに{expr}を追加する。'completefunc' で指定された関
		数の中でのみ使われる。
		失敗したときは0を返す(空文字列かメモリ不足)。候補が追加された
		ときは1を返し、その候補が既にリストに存在するときは2を返す。
		{expr}の説明については|complete-functions|を参照。'omnifunc'
		が返すリストと同じである。

complete_check()				*complete_check()*
		補完候補を探している間にキーがタイプされたかどうか確認する。補
		完の検索に時間がかかる場合に使われる。候補の検索を中断しようと
		しているときは0以外を返す。そうでないときは0を返す。
		'completefunc' で指定された関数の中でのみ使われる。

							*confirm()*
confirm({msg}, {choices} [, {default} [, {type}]])
		confirm()はユーザに選択させるためのダイアログを提供する。戻り
		値は選択した番号になる。最初の選択肢が1である。
		Note: confirm()は、ダイアログサポートを有効にしてコンパイルし
		た時にだけ動作する。|+dialog_con|と|+dialog_gui|を参照。

		ダイアログには{msg}に加えて{choices}の選択肢が表示される。
		{choices}が指定されない、または空の場合は選択肢 "&OK" が表示さ
		れる(使用している言語に翻訳される)。
		{msg}は文字列で '\n' を改行として使用できる。幾つかのシステム
		では、長すぎる行は自動的に折り返される。

		{choices}は文字列で、個々の選択肢は '\n' によって区切られる。
		例: >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' の後の文字は選択肢のショートカットキーになる。この場合
		"Cancel" を選択するのに 'c' をタイプすることができる。ショート
		カットキーは最初の文字である必要は無い: >
			confirm("file has been modified", "&Save\nSave &All")
<		コンソールでは、デフォルトのショートカットキーとして、各選択肢
		の最初の文字が使われる。

		省略可能な引数{default}は<CR>キーを叩いた時に選択される選択肢
		の番号を指定する。最初の選択肢をデフォルトにするならば1を使用
		する。デフォルトを設定したくないのならば0を使用する。
		{default}を省略した場合、0が使用される。

		省略可能な引数{type}はダイアログの種類を指定する。これは GTK,
		Mac, Motif, Win32 の GUI でアイコンを指定するのに使われる。
		"Error", "Question", "Info", "Warning", "Generic" のうちどれか
		一つを指定する。以上のうちの先頭の文字だけで指定できる。{type}
		が省略された場合、"Generic" が使用される。

		ユーザが<Esc>やCTRL-Cや、その他の割りこみキーでダイアログを中
		断した場合、confirm()は0を返す。

		例: >
   :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
   :if choice == 0
   :	echo "make up your mind!"
   :elseif choice == 3
   :	echo "tasteful"
   :else
   :	echo "I prefer bananas myself."
   :endif
<		GUIのダイアログではボタンが使用される。ボタンの配置は
		'guioptions' の 'v' フラグに依存する。もしも 'v' フラグが含ま
		れているのなら、ボタンは常に垂直に配置される。そうでなければ水
		平に配置しようと試みられる。水平配置がうまくマッチしない場合
		は、垂直配置が使われる。幾つかのシステムでは常に水平配置が使わ
		れる。

							*copy()*
copy({expr})	{expr}のコピーを作る。数値と文字列の場合は、{expr}そのものとコ
		ピーの間に違いはない。
		{expr}がリスト|List|の場合は浅いコピーを作る。つまり元のリスト
		を変更してもコピーは変更されず、逆も同じである。しかし要素は共
		通で、片方の要素に対し変更を加えると、もう一方の要素も変更され
		る。|deepcopy()|も参照。

cos({expr})						*cos()*
		{expr} の余弦(コサイン)をラジアンで浮動小数点数 |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならない。
		例: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043
		{|+float| 機能つきでコンパイルされたときのみ有効}


cosh({expr})						*cosh()*
		{expr} の双曲線余弦 (ハイパボリックコサイン) を返す。
		値は [1, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か 数値 (|Number|) でなければ
		ならない。
		例: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


count({comp}, {expr} [, {ic} [, {start}]])			*count()*
		リスト|List|または辞書|Dictionary| {comp}の中に値{expr}が何回
		現れるかを返す。
		{start}が指定されたときはそのインデックスの要素から検索を開始
		する。{start}は{comp}がリストの場合のみ使用できる。
		{ic}が指定され、0でない場合は大文字・小文字は区別されない。


							*cscope_connection()*
cscope_connection([{num} , {dbpath} [, {prepend}]])
		|cscope|接続が存在するかどうか判定する。引数が1個も指定されな
		かった場合、戻り値は以下のようになる:
			0, cscopeが利用できない(コンパイル時に無効化されている)
			   またはcscope接続が存在しない場合
			1, 1個以上のcscope接続が存在する場合

		引数が与えられた場合は次のようになる。{num}は、接続の存在を確
		認する際のマッチング方法を指定する。

		{num}	存在確認の方法
		-----	------------------------------
		0	引数なしの場合と同じ (例: "cscope_connection()")。
		1	{prepend}を無視し、{dbpath}に部分マッチを行う。
		2	{prepend}を無視し、{dbpath}に部分マッチを行う。
		3	{prepend}を使用し、{dbpath}と{prepend}に部分マッチを行
			う。
		4	{prepend}を使用し、{dbpath}と{prepend}に完全マッチを行
			う。

		Note: 以上のどの場合も文字列の比較は大文字・小文字を区別する。

		例: ":cs show" の表示が以下のようになったとする: >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		実行						戻り値 ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		{lnum}行目の{col}桁目(バイトで数える)にカーソルを移動させる。
		桁番号{col}は1から始まる。
		引数が1個の場合は、{lnum}, {col}, {off}からなる、2個または3個
		の要素を持つリスト|List|でなければならない。これは|getpos()|の
		戻り値と似ているが、1個目の要素がない点が異なる。
		この関数を呼んでもジャンプリストは変更されない。
		{lnum}がバッファの行数よりも大きい場合は、最後の行へ移動する。
		{lnum}が0の場合はカレント行に留まる。
		{col}がその行のバイト数より大きい場合は、その行の最後の文字へ
		移動する。
		{col}が0の場合は、カレント桁に留まる。
		'virtualedit' が有効のとき、{off}は文字の先頭からの画面上のオ
		フセットを指定する。例えば、<Tab>の中の位置や最後の文字より後
		などへも移動できる。
		カーソルを移動できたときは 0 を、できなかったときは-1 を返す。

deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
		{expr}のコピーを作る。数値と文字列の場合は、{expr}そのものとコ
		ピーの間に違いはない。
		{expr}がリスト|List|の場合は完全なコピーを作る。つまり元のリス
		トを変更してもコピーは変更されず、逆も同じである。要素の1つが
		リストであるときは、再帰的にコピーが作成される。よってコピーの
		要素に変更を加えても元のリストの要素は変更を受けない。
		{noref}が省略された、または0のとき、含まれているリストや辞書は
		1度だけコピーされる。全ての参照はこのただ1つのコピーを指す。
		{noref}が1の場合、リストや辞書は現れるたびに新しいコピーが作ら
		れる。そのため循環参照があるとdeepcopy()は失敗する。
								*E724*
		ネストは100レベルまで可能である。それ以上参照を繰り返している
		要素があると、{noref}が1の場合は失敗する。
		|copy()|も参照。

delete({fname})							*delete()*
		{fname}という名前のファイルを削除する。戻り値は数値で、削除に
		成功したら0、失敗したら0以外が返る。
		リスト|List|から要素を削除するには|remove()|を使う。
		バッファから行を削除するには|:delete|を使う。行番号が変数に入っ
		ている場合は|:exe|を使う。

							*did_filetype()*
did_filetype()	autocommandが実行されFileTypeイベントが一度でも起こっていれ
		ば、非零が返る。スクリプトのFileTypeイベントが、複数回呼び出さ
		れるのを回避するのに使える。 |FileType|
		他のファイルへ移動すると、このカウンタはリセットされる。よって
		実際は、カレントバッファに対してFileTypeイベントが発生したかど
		うかを判定する。他のバッファを開くオートコマンドの中でこの関数
		を使って 'filetype' を設定し、構文ファイルを読み込むために使え
		る。

diff_filler({lnum})					*diff_filler()*
		{lnum}行目より上にある削除行の数を返す。削除行とは、差分モード
		で他方のウィンドウにテキストが挿入されていることを表す行のこと
		である。削除行は表示はされているが、実際にはバッファに存在しな
		い。
		{lnum}は|getline()|と同様に扱われる。つまり "." はカレント行と
		なり、"'m" はマークmを表す。
		カレントウィンドウが差分モードでないときは0を返す。

diff_hlID({lnum}, {col})				*diff_hlID()*
		差分モードで{lnum}行{col}桁(バイト単位)の位置のハイライトIDを
		返す。カレント行に変更がないときは0を返す。
		{lnum}は|getline()|と同様に扱われる。つまり "." はカレント行と
		なり、"'m" はマークmを表す。
		先頭の桁の{col}は1となり、最初の行の{lnum}は1となる。
		ハイライトIDは|synIDattr()|を使って構文情報を得るために使える。

empty({expr})						*empty()*
		{expr}が空なら1を、そうでなければ0を返す。
		リスト|List|または辞書|Dictionary|は要素を1個も持たないとき空
		とみなされる。数値は値が0のとき空とみなされる。
		長いリストに対しては長さを0と比較するよりこちらの方がずっと高
		速である。

escape({string}, {chars})				*escape()*
		{string}内に現れる{chars}の文字をバックスラッシュでエスケープ
		する。例: >
			:echo escape('c:\program files\vim', ' \')
<		結果: >
			c:\\program\ files\\vim
<		|shellescape()| も参照。

							*eval()*
eval({string})	{string}を評価し、値を返す。|string()|の戻り値を元の値に戻すの
		に非常に便利である。数値、浮動小数点数文字列、それらの複合に対
		して動作する。実際に存在する関数への|Funcref|に対しても動作す
		る。

eventhandler()						*eventhandler()*
		イベントハンドラの中では1を返す。つまり、ユーザの文字入力を待っ
		ている間に、ファイルをドラッグ＆ドロップするなど割り込みされた
		ことを表す。このときは対話的なコマンドは使えない。イベントハン
		ドラの中でないときは0を返す。

executable({expr})					*executable()*
		{expr}という名前の実行可能ファイルが存在するかどうか判定する。
		{expr}は引数を何もつけないプログラム名でなければならない。
		executable()は$PATHと通常のプログラム検索ディレクトリを参照す
		る。					*PATHEXT*
		MS-DOSとMS-Windowsでは ".exe"、".bat" などの拡張子は含めても含
		めなくてもよい。省略された場合は$PATHEXTの拡張子を検索する。
		よって "foo.exe" が存在しなければ "foo.exe.bat" が見つかること
		もありうる。$PATHEXTが存在しなければ ".exe;.com;.bat;.cmd" が
		使われる。$PATHEXTにドットだけを含めると拡張子なしの名前を検索
		することができる。'shell' がUnixシェルのように思われるときは、
		{expr}の後に拡張子をつけない名前も検索される。
		MS-DOSとMS-Windowsではファイルが存在するかどうかだけを判定し、
		それがディレクトリでないことや、それが本当に実行可能であるかど
		うかは判定されない。
		MS-WindowsではVimと同じディレクトリにある実行ファイルは必ず発
		見できる。Vimがこのディレクトリを$PATHに加えるためである。
		|win32-PATH|。
		戻り値は数値:
			1	存在する
			0	存在しない
			-1	このシステム上では実装されていない

							*exists()*
exists({expr})	結果は数値で、変数{expr}が存在すれば1となり、そうでなければ0と
		なる。引数{expr}は文字列で次のうちいずれかである。
			&option-name	Vimオプション(存在するかだけを判定し、
					本当に動作するかは判定しない)
			+option-name	動作するVimオプション
			$ENVNAME	環境変数(空文字列と比較することでも判
					定できる)
			*funcname	組み込み関数(|functions|参照)かユーザ
					が定義した関数(|user-functions|参照)
			varname		内部変数(|internal-variables|)
					|curly-braces-names|, |Dictionary|の要
					素、|List|の要素などに対しても動作する。
					インデックスの評価で無効な式であるとエ
					ラーメッセージが出る可能性があることに
					注意。例: >
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0
			:cmdname	exコマンド: 組み込みコマンド、ユーザ定
					義コマンド、コマンド修飾子|:command|。
					戻り値:
					1  コマンド名の先頭に一致
					2  コマンド名に完全一致
					3  複数のユーザ定義コマンドに一致
					コマンドが定義されているかどうかを判定
					するには、必ず戻り値が2であるかを確認
					すること。
			:2match		|:2match|のコマンド。
			:3match		|:3match|のコマンド。
			#event		このイベントに対するオートコマンド定義
			#event#pattern	このイベントとパターンに対するオートコ
					マンド定義(パターンは文字そのままに解
					釈され、オートコマンドのパターンと1文
					字ずつ比較される)
			#group		オートコマンドグループが存在するか
			#group#event	このグループとイベントに対してオートコ
					マンドが定義されているか
			#group#event#pattern
					このグループ、イベント、パターンに対す
					るオートコマンド定義
			##event		このイベントに対するオートコマンドがサ
					ポートされているか
		ある機能がサポートされているか判定するには|has()|を使う。

		例: >
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
<		シンボルである&/$/*と名前の間には、空白文字があってはならな
		い。
		ある少数の場合では無視されるが、名前の後に余計な文字があっては
		ならない。将来はもっと厳格になる可能性があるので、現在許される
		からといって頼ってはならない。
		正しい例: >
			exists(":make")
<		正しくない例: >
			exists(":make install")

<		Note 引数は変数そのものではなく、文字列でなければならない。例
		えば、次は動作しない: >
			exists(bufcount)
<		これは変数 "bufcount" の存在を判定するのではなく、bufcountの値
		を渡し、それが存在するかどうか判定してしまう。

exp({expr})						*exp()*
		{expr} の指数を返す。
		値は [0, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		例: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


expand({expr} [, {nosuf} [, {list}]])				*expand()*
		ワイルドカードと{expr}内の特殊なキーワードを展開する。
		'wildignorecase' が適用される。

		{list} が指定されその値が非ゼロなら、結果はリストで返される。
		そうでない場合は結果は文字列で返される。その場合、複数のマッチ
		があるときはそれらは文字 <NL> で区切られる。[Note: バージョン
		5.0 では空白文字が用いられ、スペースを含むファイル名について問
		題を引き起こしていた]

		展開が失敗した場合、結果は空文字列となる。また存在しないファイ
		ル名というのは、結果の文字列には含まれない。

		{expr} が '%' か '#' か '<' で始まる場合には、展開は
		|cmdline-special|のように、変換子を受け付け、それらに関連付け
		られた変換が施される。ここに簡単な概略を示す:

			%		現在のファイル名
			#		代替バッファのファイル名
			#n		n番の代替バッファのファイル名
			<cfile>		カーソルの下のファイル名
			<afile>		autocmdのファイル名
			<abuf>		autocmdのバッファ名
			<sfile>		取り込み(source)中のファイル名
			<slnum>		取り込み(source)中の行番号
			<cword>		カーソル下の単語(word)
			<cWORD>		カーソル下の単語(WORD)
			<client>	最後に受け取ったメッセージの{clientid}
					|server2client()|
		変換子:
			:p		フルパス名を展開
			:h		ヘッド(ディレクトリ)
			:t		テイル(ファイル名だけ)
			:r		拡張子が削除される
			:e		拡張子だけ

		例: >
			:let &tags = expand("%:p:h") . "/tags"
<		'%' や '#' や '<' で始まる文字列を展開する時には、それに続くテ
		キストは無視されることに注意。従ってこれは正しくない: >
			:let doesntwork = expand("%:h.bak")
<		こうすると良い: >
			:let doeswork = expand("%:h") . ".bak"
<		"<cfile>" やそれらを展開する時には、戻り値が完全な展開をされな
		い参照名であることにも注意が必要。もしも "<cfile>" が
		"~/.cshrc" であった場合、"~/" を展開してホームディレクトリにす
		るために、もう一度expand()を呼び出す必要がある: >
			:echo expand(expand("<cfile>"))
<
		変数と変換子の間には空白文字があってはならない。関数
		|fnamemodify()|が通常のファイル名の変換には使用可能である。

		カレントバッファや代替バッファの名前が未定義のときに '%' や
		'#' を使うと空文字列になる。"%:p" を名無しのバッファに使用した
		場合、結果はカレントディレクトリに '/' が付加されたものになる。

		'%' や '#' や '<' で始まらない{expr}は、コマンドラインのファイ
		ル名と同じように展開される。{nosuf}引数に非ゼロを指定しない限
		り、'suffixes' と 'wildignore' が使用される。
		存在しないファイルの名前も結果の文字列に含まれる。"**" を使う
		とディレクトリツリーを検索できる。例えば、カレントディレクトリ
		以下にある全ての "README" を見つけるには次のようにする: >
			:echo expand("**/README")
< 
		expand()は、シェルの持っている変数や環境変数を展開することがで
		きる。しかしシェルを起動しなければならないので、遅くなる。
		|expr-env-expand|を参照。展開された変数はファイル名のリストの
		ように扱われる。環境変数を展開できないときはそのままになる。よっ
		て ":echo expand('$FOOBAR')" の結果は "$FOOBAR" となる。

		存在するファイルを探すには|glob()|を参照。外部コマンドの「生
		の」実行結果を扱うには|system()|を参照。

extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1}と{expr2}は両方ともリスト|List|であるか、両方とも辞書
		|Dictionaries|でなければならない。

		両方ともリストであるなら、{expr2}を{expr1}に付け加える。
		{expr3}が指定された場合は、{expr1}の第{expr3}番目の要素の前に
		{expr2}の要素を挿入する。{expr3}が0のときは最初の要素の前に挿
		入する。{expr3}がlen({expr1})に等しいときは末尾に{expr2}が付け
		加えられる。
		例: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		{expr1} が {expr2} と同じリストである場合、コピーされる要素の
		数はリストの元の長さと同じである。
		例として {expr3} が 1 のとき、最初の要素の N 個の新しいコピー
		が挿入される(ここで N はリストの元の長さ)。
		リストに1個の要素を加えるには|add()|を使う。2つのリストを連結
		して新しいリストを作るには演算子+を使う: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		両方とも辞書である場合:
		{expr2}の全要素を{expr1}に加える。
		{expr1}と{expr2}で共通のキーがある場合は、{expr3}によって動作
		が決まる:
		{expr3} = "keep" の場合: {expr1}の値そのままにする
		{expr3} = "force" の場合: {expr2}の値で上書きする
		{expr3} = "error" の場合: エラーメッセージを表示する	*E737*
		{expr3}が省略された場合は "force" と同じになる。

		{expr2}が空でないならば{expr1}が変更される。必要ならば最初に
		{expr1}のコピーを作ること。
		{expr2}は変更されない。
		{expr1}を返す。


feedkeys({string} [, {mode}])				*feedkeys()*
		{string}中の各文字を、あたかもマッピングまたはユーザによってタ
		イプされたかのように、処理キューに入れる。 これらの文字は先行
		入力バッファの末尾に付け足される。そのためマッピングを展開して
		いる途中であれば、これらの文字はマッピングを展開した後に来るこ
		とになる。
		この関数は、{string}中の文字が処理されるまでは待たない。
		特殊なキーを{string}に含めるにはダブルクォートと "\..." 記法を
		使う(|expr-quote|を参照)。例えば、feedkeys("\<CR>")は<Enter>
		キーの押下をシミュレートする。しかしfeedkeys('\<CR>')とすると、
		この文字の通り5文字を挿入する。
		{mode}が省略されたときは、挿入されたキーはマップ展開の対象にな
		る。{mode}は以下の文字フラグを含む文字列:
		'm'	キーをマップ展開する。これが既定である。
		'n'	キーをマップ展開しない。
		't'	キーをタイプされたかのように扱う。そうでない場合は
			マッピングから展開されたかのように扱われる。これは
			undoや折り畳みの展開などで違いが現れる。
		戻り値は常に0。

							*filereadable()*
filereadable({file})
		結果は数値で、{file}というファイルが存在し、読みこむことが可能
		ならばTRUEとなる。ファイル{file}が存在しないかディレクトリだっ
		た場合には、結果はFALSEとなる。引数{file}は文字列として使えれ
		ばどのような表現でもよい。
		ファイルが読み込み可能でなくてもよい場合には|glob()|を使う。
							*file_readable()*
		以前の名前: file_readable().

filewritable({file})					*filewritable()*
		結果は数値で、{file}というファイルが存在し、書き込むことが可能
		ならば1となる。ファイル{file}が存在しないか書き込み不可能であ
		る場合には、結果は0となる。{file}がディレクトリであり、書き込
		み可能な場合、結果は2となる。


filter({expr}, {string})					*filter()*
		{expr}はリスト|List|または辞書|Dictionary|でなければならない。
		{expr}の各要素に対して{string}を評価し、その結果が0ならばリス
		トまたは辞書からその要素を削除する。{string}の内部では|v:val|
		が現在の要素の値を保持している。
		辞書の場合は|v:key|が現在の要素のキーを保持している。
		例: >
			:call filter(mylist, 'v:val !~ "OLD"')
<		は要素 "OLD" を削除する。 >
			:call filter(mydict, 'v:key >= 8')
<		は8未満のキーを持つ要素を削除する。 >
			:call filter(var, 0)
<		は全要素を削除する。つまりリストまたは辞書をクリアする。

		Note {string}は式を表す文字列である。バックスラッシュを二重に
		しなくても済むように|literal-string|を使うとよいだろう。

		この操作はその場で(in-place)行われる。リストや辞書を変更したく
		ない場合は最初にコピーを作ること: >
			:let l = filter(copy(mylist), 'v:val =~ "KEEP"')

<		フィルタされたリストまたは辞書を返す。{string}を評価している最
		中にエラーが発生した場合は、それ以降の要素の処理は行われない。


finddir({name}[, {path}[, {count}]])				*finddir()*
		{path}から{name}という名前のディレクトリを探す。ディレクトリを
		上方・下方のどちらにも再帰的に検索できる。{path}の記法について
		は|file-searching|を参照。
		最初に見つかったディレクトリのパスを返す。そのディレクトリがカ
		レントディレクトリの下にある場合は相対パスを返す。そうでなけれ
		ば絶対パスを返す。
		{path}が省略されたとき、または空のときはオプション 'path' の値
		が使われる。
		省略可能な引数{count}が指定されたときは、最初に見つかったディ
		レクトリでなく、{count}番目に見つかったディレクトリを返す。
		{count}が負の場合は、見つかったディレクトリ全てのリスト|List|
		を返す。これはexコマンド|:find|によく似ている。
		{|+file_in_path| 機能付きでコンパイルされたときのみ利用可能}

findfile({name}[, {path}[, {count}]])				*findfile()*
		|finddir()|と同様だが、ディレクトリでなくファイルを検索する。
		'suffixesadd' が適用される。
		例: >
			:echo findfile("tags.vim", ".;")
<		この例は、カレントファイルがあるディレクトリから上方に
		"tags.vim" を見つけるまで再帰的に検索する。

float2nr({expr})					*float2nr()*
		{expr} の小数点以下を切り捨てて |Number| に変換する。
		{expr} は |Float| または |Number| に評価されなければならない。
		{expr} の値が |Number| の範囲外の場合、結果は 0x7fffffff また
		は -0x7fffffff になる。NaN は -0x80000000 になる。
		例: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  >
			echo float2nr(-1.0e150)
<			-2147483647  >
			echo float2nr(1.0e-100)
<			0
		{|+float| 機能つきでコンパイルされたときのみ有効}


floor({expr})							*floor()*
		{expr} 以下の最大の整数を |Float| で返す(切り捨て)。
		{expr} は |Float| または |Number| に評価されなければならな
		い。
		例: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0
		{|+float| 機能つきでコンパイルされたときのみ有効}


fmod({expr1}, {expr2})					*fmod()*
		{expr1} / {expr2} の余りを返す (割り算が表現できなくても)。
		{expr2} が非ゼロなら {expr1} - i * {expr2} の結果を返す (i は
		返り値が {expr1} と同じ符号を持ちその絶対値が {expr2} よりも小
		さくなるような値)。{expr2} がゼロならゼロが返る。返り値の型は
		浮動小数点数 (|Float|)。
		{expr1} と {expr2} は浮動小数点数 (|Float|) か数値 (|Number|)
		でなければならない。
		例: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


fnameescape({string})					*fnameescape()*
		コマンド引数のファイル名として使うために {string} をエスケープ
		する。'%' や '|' など特別な意味を持つ全ての文字がバックスラッ
		シュでエスケープされる。
		特別な文字とは、ほとんどのシステムにおいて
		" \t\n*?[{`$\\%#'\"|!<" である。ファイル名にバックスラッシュが
		現れるシステムにおいては 'isfname' の値に依存する。
		先頭の '+' と '>' もエスケープされる(|:edit| と |:write| の引
		数では特別な意味を持つ)。{string} が "-" である場合もエスケー
		プされる(|:cd| の引数では意味を持つ)。
		例: >
			:let fname = '+some str%nge|name'
			:exe "edit " . fnameescape(fname)
<		上記は次と同じ結果になる: >
			edit \+some\ str\%nge\|name

fnamemodify({fname}, {mods})				*fnamemodify()*
		ファイル名{fname}を{mods}にしたがって変更する。{mods}はコマン
		ドラインで使われるのと同様な文字列である。詳細は
		|filename-modifiers|を参照。
		例: >
			:echo fnamemodify("main.c", ":p:h")
<		結果: >
			/home/mool/vim/vim/src/
<		Note: {fname}の中の環境変数は展開されない。環境変数を展開させ
		るには|expand()|を使うこと。

foldclosed({lnum})					*foldclosed()*
		結果は数値。{lnum}行目が閉じた折り畳みの中にあるなら、その折り
		畳みを構成する最初の行の行番号を返す。{lnum}行目が閉じた折り畳
		みに入っていないなら-1を返す。

foldclosedend({lnum})					*foldclosedend()*
		結果は数値。{lnum}行目が閉じた折り畳みの中にあるなら、その折り
		畳みを構成する最後の行の行番号を返す。{lnum}行目が閉じた折り畳
		みに入っていないなら-1を返す。

foldlevel({lnum})					*foldlevel()*
		カレントバッファの{lnum}行目の折り畳みレベルを表す数値を返す。
		折り畳みがネストしているときは一番下のレベルを返す。{lnum}行目
		に折り畳みがまったくないときは0を返す。折り畳みが開いているか
		閉じているかは関係ない。('foldexpr' の中で)折り畳みを更新して
		いる最中に呼ぶと、まだ折り畳みを更新していなく、折り畳みレベル
		が未知の行に対しては-1を返す。特別な場合として、普通は1行前の
		レベルは取得できる。

							*foldtext()*
foldtext()	閉じた折り畳みに表示する文字列を返す。これはオプション
		'foldtext' のデフォルトの関数であり、'foldtext' を評価している
		ときにだけ呼ぶようにすべきである。この関数は変数|v:foldstart|,
		|v:foldend|, |v:folddashes|を使用する。
		戻り値の文字列は次のようになる: >
			+-- 45 lines: abcdef
<		
		ダッシュ(-)の数は折り畳みレベルによって決まる。"45" はその折り
		畳みに含まれている行数である。"abcdef" はその折り畳みの中の最
		初の空行でない行のテキストである。行頭の空白と、"//" や "/*"、
		'foldmarker' と 'commentstring' に設定されている文字列は削除さ
		れる。
		{|+folding|機能付きでコンパイルされたときのみ利用可能}

foldtextresult({lnum})					*foldtextresult()*
		{lnum}行目の閉じた折り畳みに表示される文字列を返す。'foldtext'
		を適切なコンテキストの中で評価する。{lnum}行目に閉じた折り畳み
		がないときは空文字列を返す。
		{lnum}は|getline()|のときと同様に扱われる。つまり "." はカレン
		ト行、"'m" はマークmを表す。
		折り畳まれたテキストをHTMLなどにエクスポートするときに有用。
		{|+folding|機能付きでコンパイルされたときのみ利用可能}

							*foreground()*
foreground()	Vimのウィンドウを前面に移動する。この関数はクライアントからVim
		サーバへ送ると便利である。|remote_send()|
		Win32では自分自身のウィンドウを前面に持ってくることが必ずしも
		許可されていないので、動作しないかもしれない。そのときは代わり
		に|remote_foreground()|を使うこと。
		{Win32, Athena, Motif, GTKいずれかのGUI版とWin32コンソール版で
		のみ利用できる}


function({name})					*function()* *E700*
		関数{name}を参照する|Funcref|の変数を返す。{name}はユーザ定義
		関数でも組み込み関数でもよい。


garbagecollect([{atexit}])				*garbagecollect()*
		循環参照を持ち、使われていないリスト|List|と辞書|Dictionaries|
		をクリーンアップする。これはメモリ不足に陥ったときや、
		'updatetime' 経過後ユーザのキー入力を待っているときに自動的に行
		われるので、この関数を呼ぶ必要があることはほとんどない。
		循環参照を持たない要素は、使われなくなったとき必ず解放される。
		長時間実行されるスクリプトの中で循環参照を持つ非常に大きなリス
		トや辞書を削除したときに有用である。
		省略可能な引数 {atexit} に 1 を指定すると、Vim を終了するとき
		にもガベージコレクションが行われる。これはメモリリークを発見す
		るのに役に立つ。

get({list}, {idx} [, {default}])			*get()*
		リスト|List| {list}から{idx}番目の要素を取得する。この要素を取
		得できないときは{default}を返す。{default}が省略されたときは0
		を返す。
get({dict}, {key} [, {default}])
		辞書|Dictionary| {dict}からキー{key}に関連づけられた値を取得す
		る。この要素を取得できないときは{default}を返す。{default}が省
		略されたときは0を返す。

							*getbufline()*
getbufline({expr}, {lnum} [, {end}])
		バッファ{expr}の{lnum}行目から{end}行目まで(両端含む)の行から
		なるリスト|List|を返す。{end}が省略されたときは{lnum}行目だけ
		からなるリストを返す。

		{expr}の指定の仕方については|bufname()|を参照。

		{lnum}と{end}では "$" でバッファの最後の行を表すことができる。
		それ以外は数値でなければならない。

		{lnum}が1より小さいときや、バッファの行数より大きいときは空リ
		ストを返す。

		{end}がバッファの行数より大きいときは、バッファの行数が設定さ
		れたものとして扱う。{end}が{lnum}行目より前に設定された場合は
		空リストを返す。

		この関数は読み込まれているバッファに対してのみ動作する。既にア
		ンロードされているバッファや存在しないバッファに対しては空リス
		トを返す。

		例: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")

getbufvar({expr}, {varname} [, {def}])				*getbufvar()*
		バッファ{expr}のオプションの値やバッファローカル変数{varname}
		の値を返す。Note "b:" をつけない変数名を指定すること。
		{varname} が空文字列の場合、全てのバッファローカル変数からなる
		辞書を返す。
		グローバルオプション、バッファローカルオプションのどちらに対し
		ても動作するが、グローバル変数、ウィンドウローカル変数、ウィン
		ドウローカルオプションに対しては動作しない。
		{expr}の指定の仕方については|bufname()|を参照。
		バッファや変数が存在しないときは{def}または空文字列を返し、エ
		ラーメッセージは表示されない。
		例: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " . getbufvar("todo", "myvar")
<
getchar([expr])						*getchar()*
		ユーザまたは入力ストリームから1文字を取得する。
		[expr]が省略されたときは1文字を取得できるまで待つ。
		[expr]が0のときは1文字を取得できる場合のみ取得する。取得できな
		ければ0を返す。
		[expr]が1のときは1文字を取得できるか判定し、実際には取得しない。
		取得できないときは0を返す。

		{expr}が省略されたときや{expr}が0のときは、文字全体または特殊
		キーを返す。それが8ビット文字なら戻り値は数値である。これを文
		字列に戻すにはnr2char()を使う。8ビット文字でないならばエンコー
		ドして文字列にして返す。
		特殊キーとは0x80(10進数で128)で始まるバイト列である。これは
		文字列 "\<Key>" と同じ値である(例: "\<Left>")。戻り値は文字列
		であり、修飾キー(shift, control, alt)は含まれない。

		{expr}が1のときは最初のバイトだけを返す。1バイト文字の場合、こ
		れはその文字そのものを表す数値である。これを文字列に変換するに
		はnr2char()を使う。

		修飾キーを取得するには getcharmod() を使う。

		ユーザがマウスをクリックしたときはマウスイベントを返す。クリッ
		クした位置は|v:mouse_col|, |v:mouse_lnum|, |v:mouse_win|で得ら
		れる。以下の例は、普通にマウスがクリックされたときと同じように
		カーソルを移動させる。 >
			let c = getchar()
			if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win . "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " . v:mouse_col . "|"
			endif
<
		この関数を呼んだときプロンプトは表示されない。文字入力を待って
		いることをなんらかの方法でユーザがわかるようにしなければならな
		いだろう。
		入力された文字に対してマッピングは適用されない。
		キーコードは置換される。つまりユーザが<Del>を押した場合、「生
		の」文字シーケンスでなく<Del>キーに対応するコードが得られる。
		例: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		以下の例は大文字・小文字を区別しないように "f" を再定義する: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction

getcharmod()						*getcharmod()*
		最後にgetchar()などで得た文字に対する修飾キーの状態を表す数値
		を返す。以下の値の和となる:
			2	shift
			4	control
			8	alt (meta)
			16	meta (ALT と META が区別される場合)
			32	マウスのダブルクリック
			64	マウスのトリプルクリック
			96	マウスのクアドラプルクリック (== 32 + 64)
			128	command (Macintosh のみ)
		文字自身に含まれていない修飾キーのみ取得できる。つまり、
		Shift-aは修飾キーなしの "A" となる。

getcmdline()						*getcmdline()*
		現在のコマンドラインの内容を取得する。コマンドラインを編集して
		いるときのみ動作する。つまり|c_CTRL-\_e|または|c_CTRL-R_=|を使っ
		ているときのみ有効。
		例: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		|getcmdtype()|, |getcmdpos()|, |setcmdpos()|も参照。

getcmdpos()						*getcmdpos()*
		コマンドラインにおけるカーソル位置をバイト単位で取得する。最初
		の桁は1となる。コマンドラインを編集しているときのみ動作する。
		つまり|c_CTRL-\_e|または|c_CTRL-R_=|または式マッピングを使って
		いるときのみ有効。そうでないときは 0 を返す。
		|getcmdtype()|, |setcmdpos()|, |getcmdline()|も参照。

getcmdtype()						*getcmdtype()*
		現在のコマンドラインの種類を返す。戻り値は次のいずれか:
		    :	通常のexコマンド
		    >	デバッグモードコマンド |debug-mode|
		    /	前方検索コマンド
		    ?	後方検索コマンド
		    @	|input()| コマンド
		    -	|:insert| または |:append| コマンド
		コマンドラインを編集しているときのみ動作する。つまり
		|c_CTRL-\_e|または|c_CTRL-R_=|または式マッピングを使っていると
		きのみ有効。そうでないときは空文字列を返す。
		|getcmdpos()|, |setcmdpos()|, |getcmdline()|も参照。

							*getcwd()*
getcwd()	結果は文字列で、現在のディレクトリ名。

getfsize({fname})					*getfsize()*
		結果は数値で、{fname}で指定されるファイルのサイズをバイト単位
		で返す。
		{fname}がディレクトリのときは0を返す。
		ファイル{fname}が見つからないときは-1を返す。
		{fname} のサイズが |Number| の範囲外の場合は -2 を返す。

getfontname([{name}])					*getfontname()*
		引数なしで使われた場合には現在の通常のフォント名を返す。ハイラ
		イトグループNormalに対して使われるものと同様|hl-Normal|。
		引数が指定された場合には{name}が有効なフォント名であるか判定さ
		れる。有効でないときは空文字列を返す。
		有効なときは実際のフォント名を返す。またはGUIが実際の名前の取
		得をサポートしていないときは{name}をそのまま返す。
		GUIモードで実行しているときのみ動作する。よってvimrcやgvimrcの
		中では使えない。GUIモードが起動した直後にこの関数を呼ぶには、
		オートコマンド|GUIEnter|を使うこと。
		Note GTK 2のGUIはどんなフォント名でも受け付けてしまうため、名
		前が有効であるかのチェックは動作しない。

getfperm({fname})					*getfperm()*
		{fname}で指定されたファイルの読み込み、書き込み、実行の許可属
		性を示す文字列を返す。
		{fname}が存在しない、またはそのディレクトリが読み込み不可能な
		ときは空文字列を返す。
		戻り値は "rwxrwxrwx" の形で、"rwx" フラグの各グループは順にファ
		イルの所有者、ファイルが所属するグループ、その他のユーザを表
		す。許可属性が与えられていないフラグは "-" で置き換えられる。
		例: >
			:echo getfperm("/etc/passwd")
			:echo getfperm(expand("~/.vimrc"))
<		この例は、(セキュリティの観点から望ましい設定がされているなら
		ば) "rw-r--r--" あるいは "rw-------" と表示する。

							*getftime()*
getftime({fname})
		結果は{fname}で与えられたファイルの、最終更新時間を示す数値。
		1970年1月1日からの経過時間(秒)で、strftime()に渡すことができる
		だろう。|localtime()|と|strftime()|も参照。
		ファイル{fname}が見つからなかった場合には-1を返す。

getftype({fname})					*getftype()*
		{fname}で指定されたファイルの種別を示す文字列を返す。
		{fname}が存在しないときは空文字列を返す。
		ファイルの種別とそれらの結果の表を以下に示す:
			通常ファイル		"file"
			ディレクトリ		"dir"
			シンボリックリンク	"link"
			ブロックデバイス	"bdev"
			キャラクタデバイス	"cdev"
			ソケット		"socket"
			FIFO			"fifo"
			それ以外		"other"
		例: >
			getftype("/home")
<		Note "link" などの種別はそれをサポートしているシステムでのみ返
		される。"dir" と "file" しか返らないシステムもある。

							*getline()*
getline({lnum} [, {end}])
		{end}が指定されない場合は、カレントバッファの{lnum}行目の内容
		を文字列にして返す。例: >
			getline(1)
<		{lnum}が数字ではない文字で始まる文字列であった場合、line()に
		よってその文字列が数字に変換される。よって、カーソルのある行の
		文字列を取得するには: >
			getline(".")
<		{lnum}が1より小さいかバッファの行数よりも大きい数値の場合、空
		文字列が返される。

		{end}が指定された場合は、カレントバッファの{lnum}行目から
		{end}行目までを要素とするリスト|List|を返す。
		{end}は{lnum}と同様に解釈される。
		存在しない行は省略され、エラーメッセージは表示されない。
		{end}が{lnum}より前になる場合は空リストを返す。
		例: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		他のバッファの行を取得するには|getbufline()|を参照。

getloclist({nr})					*getloclist()*
		ウィンドウ{nr}のロケーションリストの全項目からなるリストを返す。
		{nr}に0を指定するとカレントウィンドウになる。ロケーションリス
		トウィンドウに対して使用すると、そこに表示されているロケーショ
		ンリストが返る。ウィンドウ番号{nr}が無効な場合は、空リストが返
		る。それ以外は|getqflist()|と同じ。

getmatches()						*getmatches()*
		|matchadd()| と |:match| により定義された全てのマッチの |List|
		を返す。|setmatches()| は |getmatches()| で保存されたマッチの
		リストを復元できるので、|getmatches()| と |setmatches()| は組
		み合わせて使うと便利である。
		例: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<
getqflist()						*getqflist()*
		現在の全quickfixエラーのリストを返す。リストの各要素は辞書で、
		以下の要素を持つ:
			bufnr	ファイル名を持つバッファの番号。その名前を取得
				するにはbufname()を使う。
			lnum	バッファ中の行番号(最初の行は1)
			col	桁番号(最初の桁は1)
			vcol	0以外: "col" は画面上の桁
				0: "col" はバイトインデックス
			nr	エラー番号
			pattern	エラーの位置を特定するために使う検索パターン
			text	エラーの説明
			type	エラーメッセージの種類。'E', '1' など。
			valid	0以外: エラーメッセージが認識されている

		エラーリストがまったくないか、空であるときは空リストを返す。
		存在しないバッファ番号を持つquickfixリストの項目は "bufnr" を0
		にして返される。

		役に立つ応用例: 複数のファイルから正規表現検索を行い、見つかっ
		たものに対してなんらかの操作をする: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor

getreg([{regname} [, 1]])				*getreg()*
		レジスタ{regname}の中身を文字列にして返す。例: >
			:let cliptext = getreg('*')
<		getreg('=')は最後に評価した式レジスタの値を返す。(マップの中で
		使用する)。
		getreg('=', 1)はその式そのものを返す。これを使って|setreg()|で
		復元することができる。他のレジスタの場合は、この引数は無視され
		るので、常に指定していても害はない。
		{regname}を指定しないときは|v:register|が使われる。


getregtype([{regname}])					*getregtype()*
		レジスタ{regname}の種類を表す文字列を返す。
		戻り値は次のいずれかとなる:
		    "v"			文字指向|characterwise|の場合
		    "V"			行指向|linewise|の場合
		    "<CTRL-V>{width}"	矩形指向|blockwise-visual|の場合
		    0			空、または未知のレジスタの場合
		<CTRL-V>は値0x16の1文字である。
		{regname}を指定しないときは|v:register|が使われる。

gettabvar({tabnr}, {varname} [, {def}])				*gettabvar()*
		タブページ {tabnr} のタブローカル変数 {varname} を取得する。
		|t:var|
		タブの番号は 1 から始まる。
		Note: 指定する変数名は "t:" を除いた名前。
		タブや変数が存在しないときは{def}または空文字列を返し、エラー
		メッセージは表示されない。

gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])		*gettabwinvar()*
		タブページ{tabnr}内のウィンドウ{winnr}のウィンドウローカル変数
		{varname}の値を取得する。
		{varname}が文字 "&" で始まるときはウィンドウローカルオプション
		の値を取得する。
		{varname}が空のときは全ウィンドウローカル変数からなる辞書を返
		す。
		Note {varname}は "w:" をつけずに指定しなければならない。
		タブページ番号は1から始まる。カレントタブページを指定するには
		|getwinvar()|を指定する。
		{winnr}が0のときはカレントウィンドウとなる。
		グローバルオプション、バッファローカルオプション、ウィンドウ
		ローカルオプションに対しても動作するが、グローバル変数やバッ
		ファローカル変数に対しては動作しない。
		ウィンドウやタブや変数が存在しないときは{def}または空文字列を
		返し、エラーメッセージは表示されない。
		例: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
<

							*getwinposx()*
getwinposx()	結果はGUIのVimウィンドウの左端の、デスクトップ上でのX座標値(数
		値)。情報が存在しない(コンソールの)場合は-1となる。

							*getwinposy()*
getwinposy()	結果はGUIのVimウィンドウの上端の、デスクトップ上でのY座標値(数
		値)。情報が存在しない(コンソールの)場合は-1となる。

getwinvar({winnr}, {varname} [, {def}])				*getwinvar()*
		カレントタブページに対する|gettabwinvar()|と同様。
		例: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " . getwinvar(1, 'myvar')
<
glob({expr} [, {nosuf} [, {list}]])				*glob()*
		{expr}内のファイル名のワイルドカードを展開する。特殊文字につい
		ては|wildcards|を参照。

		{nosuf} に非零を指定しない限り、'suffixes' と 'wildignore' が
		適用される。つまり 'wildignore' のパターンにマッチする名前はス
		キップされ、'suffixes' がマッチの順番に影響を与える。
		'wildignorecase' は常に適用される。

		{list} が指定されその値が非ゼロなら、マッチしたすべてのファイ
		ルがリストとして返される。リストを使うことで、改行を含むファイ
		ル名があっても結果を正しく受け取ることができる。
		そうでない場合は結果は文字列で返される。その場合、複数のマッチ
		があるときはそれらは文字 <NL> で区切られる。

		展開が失敗した場合、空の文字列またはリストが返される。存在しな
		いファイル名は結果に含まれない。シンボリックリンクは、それが存
		在するファイルを指す場合のみ含まれる。

		多くのシステムではバッククォート(「`」という文字のこと)を、外
		部コマンドの実行結果からファイル名を取得するために使用できる。
		例: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		バッククォート内のプログラムの実行結果は、一行に一つずつの項目
		が含まれてなければならない。項目内のスペースは許容される。
		
		特殊なVimの変数を展開するためには|expand()|を参照。外部コマン
		ドの生の出力を得るためには|system()|を参照。

globpath({path}, {expr} [, {flag}])			*globpath()*
		{path}の中の全ディレクトリに対して|glob()|を実行し、結果を連結
		する。例: >
			:echo globpath(&rtp, "syntax/c.vim")
<		{path}はコンマ区切りのディレクトリのリスト。各ディレクトリを
		{expr}の前に付加し、glob()と同様にそれを展開する。必要に応じて
		パスの区切り文字が挿入される。
		ディレクトリ名の中にコンマを含めるには、バックスラッシュでエス
		ケープすること。Note MS-Windowsではディレクトリ名の末尾にバッ
		クスラッシュがつくことがある。その後に区切りのコンマを書くとエ
		スケープと見なされてしまうので、バックスラッシュは削除すること。
		どれかのディレクトリに対して展開が失敗してもエラーメッセージは
		表示されない。
		{flag} に非零が指定されない限り、オプション 'wildignore' が適
		用される。つまり、'wildignore' のパターンにマッチする名前はス
		キップされる。

		"**" を使ってディレクトリツリーを再帰的に検索することができる。
		例えば、'runtimepath' とそれ以下のディレクトリから全ての
		"README.txt" を探すには次のようにする: >
			:echo globpath(&rtp, "**/README.txt")
<		上向き検索と、"**" の深さの限界はサポートされていない。よって
		オプション 'path' の値をそのまま使うとうまく動かないことが
		ある。

							*has()*
has({feature})	結果は機能{feature}がサポートされる場合1、されない場合0とな
		る。引数{feature}は文字列。下記の|feature-list|を参照。
		|exists()|も参照。

has_key({dict}, {key})					*has_key()*
		結果は数値で、辞書|Dictionary| {dict}がキー{key}の要素を持つな
		ら1、持たないなら0となる。

haslocaldir()						*haslocaldir()*
		結果は数値でカレントウィンドウが|:lcd|によってローカルなカレン
		トディレクトリを持つようセットされているなら1、そうでないなら
		0となる。

hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		結果は数値。右辺側(マップした先)の一部分に{what}を含むマッピン
		グが存在し、それが{mode}で指定されたモードのいずれかで定義され
		ているなら1を返す。
		{abbr}が指定されていて0でないときはマッピングでなく短縮入力の
		存在を判定する。挿入モードまたはコマンドモードを指定することを
		忘れないように。
		グローバルマップとバッファローカルマップの両方をチェックする。
		マッピングが1個も見つからなかったときは0を返す。
		{mode}に対しては以下の文字が利用できる:
			n	ノーマルモード
			v	ビジュアルモード
			o	オペレータ待機モード (Operator-pending)
			i	挿入モード
			l	Language-Argumentモード ("r", "f", "t" など)
			c	コマンドラインモード
		{mode}が省略されたときは "nvo" となる。

		この関数はVimスクリプトの中で、ある関数へのマッピングが既に存
		在するか判定するために有用である。例: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		この例は、"\ABCdoit" へのマッピングが存在しないときだけ
		"\ABCdoit" へのマッピングを作成する。

histadd({history}, {item})				*histadd()*
		文字列{item}を履歴{history}に追加する。履歴{history}は以下のう
		ちどれか一つから選択:			*hist-names*
			"cmd"	 or ":"	  コマンドライン履歴
			"search" or "/"   検索パターン履歴
			"expr"   or "="   タイプされた式の履歴
			"input"  or "@"	  input()の履歴
			"debug"  or ">"   デバッグコマンドの履歴
		{history} 文字列はフルネームで指定する必要はありません。頭文字
		だけでも構いません。
		{item}が履歴内に既に存在する場合、それが最新の項目の位置へシフ
		トされる。結果は数値:操作が成功した場合1、そうでなければ0

		例: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		サンドボックス|sandbox|の中では利用できない。

histdel({history} [, {item}])				*histdel()*
		{history}の内容を削除する。例えば全てのエントリを消すこともで
		きる。{history}の部分に可能な値は|hist-names|を参照。

		パラメータ{item}が文字列に評価される場合、これは正規表現と
		して扱われる。その表現にマッチする全てのエントリがhistoryから
		削除される(複数あっても)。
		"\c" をつけない場合、大文字・小文字が一致しなければならない。
		|/\c|。
		{item}が数値に評価される場合、インデックスとして解釈される。イ
		ンデックスについては|:history-indexing|を参照。関連するエント
		リ{訳注: The respective entry}も、存在すれば削除される。

		結果は数値: 削除に成功すれば1を、そうでなければ0が返る。

		例:
		式レジスタの履歴を削除する: >
			:call histdel("expr")
<
		検索履歴から、"*" で始まるエントリを全て削除する: >
			:call histdel("/", '^\*')
<
		次の3つは等価である: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^'.histget("search", -1).'$')
<
		最後の検索パターンを削除し、一つ前のパターンを "n" コマンド(次
		のマッチへ移動)と 'hlsearch' の為に設定する: >
			:call histdel("search", -1)
			:let @/ = histget("search", -1) 

histget({history} [, {index}])				*histget()*
		結果は{history}の第{index}エントリを表わす文字列。{history} の
		部分に可能な値は|hist-names|を、{index}については
		|:history-indexing|を参照。指定されたエントリが存在しない場合
		は空文字列が返される。{index}が省略された場合には、履歴中の最
		新のエントリが戻り値として使用される。

		例:
		2つ前に行われた検索をやり直す: >
			:execute '/' . histget("search", -2)

<		|:history|によって出力される{num}番目のエントリを、再度実行す
		るための ":H {num}" というコマンドを定義する。 >
			:command -nargs=1 H execute histget("cmd",0+<args>)
<
histnr({history})					*histnr()*
		結果は数値で{history}の現在のエントリ数。{history}の部分に可能
		な値は|hist-names|を参照。エラーが起こった場合、-1が返される。

		例: >
			:let inp_index = histnr("expr")
<
hlexists({name})					*hlexists()*
		結果は数値で、{name}という名のハイライトグループが存在すれば、
		非ゼロの値が返される。これはなんらかの方法でそのグループが既に
		定義されている時にのみ起こる。これの為に実際に何らかのハイライ
		ティングアイテムが設定されている必要はなく、単に構文アイテムと
		しても使われるだろう。
							*highlight_exists()*
		以前の名前: highlight_exists().

							*hlID()*
hlID({name})	結果は数値で、{name}という名前のハイライトグループのID番号。そ
		のハイライトグループが存在しない場合は0が返される。
		これはハイライトグループについての情報を獲得するために使用され
		る。例えば "Comment" グループの背景色を取得するにはこのように
		する: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<							*highlightID()*
		以前の名前: highlightID()

hostname()						*hostname()*
		結果は文字列で、現在Vimが実行されているマシンの名前。名前が256
		文字を超える場合、超えた部分は切り捨てられる。

iconv({expr}, {from}, {to})				*iconv()*
		文字列{expr}をエンコーディング{from}からエンコーディング{to}に
		変換した文字列を返す。
		変換が完全に失敗したときは空文字列を返す。一部の文字が変換でき
		なかった場合、その文字は "?" に置き換わる。
		エンコーディング名はライブラリ関数iconv()が受け付けるものなら
		なんでもよい。":!man 3 iconv" を参照。
		ほとんどの変換は、Vimが|+iconv|機能つきでコンパイルされている
		ときのみ利用可能。|+iconv|つきでないときもUTF-8からlatin1への
		変換とその逆は行える。
		オプション 'encoding' の値に関係なく、特殊な文字を含むメッセー
		ジを表示するために使える。UTF-8でエンコードされたメッセージを
		表示するには次のようにする: >
			echo iconv(utf8_str, "utf-8", &enc)
<		Note Vimは全てのUnicodeエンコーディングに対してUTF-8を使う。
		UCS-2との変換を行おうとしても、自動的にUTF-8との変換に変更され
		る。いずれにせよ、UCS-2はNULバイトを含むため、文字列にUCS-2を
		使うことはできない。
		{|+multi_byte| 機能付きでコンパイルされたときのみ利用可能}

							*indent()*
indent({lnum})	カレントバッファの{lnum}行目のインデント量を数値で返す。この
		インデント量はスペース単位で数えられ、'tabstop' の値が関係する。
		{lnum}は|getline()|の場合と同様に扱われる。
		{lnum}が無効なときは-1を返す。


index({list}, {expr} [, {start} [, {ic}]])			*index()*
		リスト|List| {list}の中で、{expr}に等しい要素の最小のインデッ
		クスを返す。自動的な変換は行われないので、文字列の "4" は数値
		の 4 とは異なると判定される。そして数値の 4 は浮動小数点数の
		4.0 とも異なる。'ignorecase' はここでは適用されず、常に大文字・
		小文字は区別される。
		{start}が指定された場合はインデックス{start}から要素の検索を始
		める(負数を指定すると末尾からの相対位置となる)。
		{ic}に0でない値が指定された場合、大文字・小文字は区別されない。
		そうでない場合は区別される。
		{list}の中に{expr}が見つからない場合は-1を返す。
		例: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0

input({prompt} [, {text} [, {completion}]])		*input()*
		結果は文字列で、ユーザがコマンドラインに入力したものが返される。
		引数 {prompt} にはプロンプト文字列か空文字列を指定する。空文字
		列の場合はプロンプトなしになる。'\n' を使ってプロンプトに改行
		を含めることができる。|:echohl|によるハイライトの設定がプロン
		プトに適用される。入力はコマンドラインと同様に行え、同じ編集コ
		マンドやキーマップが使用できる。input()に入力された文字列には、
		他の履歴とは独立した履歴が与えられる。
		例: >
			:if input("Coffee or beer? ") == "beer"
			:  echo "Cheers!"
			:endif
<
		省略可能な引数{text}が与えられ、空でないならば、それが入力の初
		期値として、ユーザが入力したのと同じ様に表示される。例: >
			:let color = input("Color? ", "white")

<		省略可能な引数{completion}はこの入力において利用できる補完の種
		類を指定する。この引数がないときは補完は行われない。対応してい
		る補完の種類は、ユーザ定義コマンドにおいて引数 "-complete=" で
		指定するものと同じである。詳しくは|:command-completion|を参照。
		例: >
			let fname = input("File: ", "", "file")
<
		NOTE: この関数はGUIモードしか持たないバージョン(例、Win32 GUI)
		のVimでは、スタートアップファイルの中で使用することはできな
		い。
		NOTE: マッピングの中からinput()を呼ぶと、そのマッピングの残り
		の文字が消費される。マッピングは、その文字が入力されたときと同
		じように処理されるためである。
		これを避けるには、input()の前に|inputsave()|を呼び、input()の
		後に|inputrestore()|を呼ぶ。もう1つの対策は、|:execute|や
		|:normal|を使うなどして、そのマッピングでそれ以上文字を続けな
		いようにすることである。

		マッピングと同時に使う例: >
			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction

inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
		|input()|と同様。GUIで動作していて、テキストダイアログがサポー
		トされている場合はダイアログを表示してテキストを入力させる。
		例: >
		   :let n = inputdialog("value for shiftwidth", shiftwidth())
		   :if n != ""
		   :  let &sw = n
		   :endif
<		ダイアログがキャンセルされたときは{cancelreturn}を返す。
		{cancelreturn}が省略されているときは空文字列を返す。
		<Enter>を押すとOKボタンを押すのと同じ動作になる。<Esc>を押すと
		キャンセルボタンを押すのと同じ動作になる。
		NOTE: コマンドライン補完は対応していない。

inputlist({textlist})					*inputlist()*
		{textlist}は文字列のリスト|List|でなければならない。1行につき
		リストの要素を1個表示し、ユーザに数字を入力するよう促す。入力
		された数字を返す。
		ユーザはマウスで文字列をクリックすることでも選択できる。最初の
		文字列を選択すると0が返る。最初の文字列より上をクリックすると
		負数が返る。プロンプト自身をクリックすると{textlist}の長さ+1が
		返る。
		{textlist}の要素数はオプション 'lines' の値より少なくなければ
		ならない。そうでないと動作しない。最初の要素にメッセージを書
		き、各文字列の先頭に番号をつけておくとよい。
		例: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])

inputrestore()						*inputrestore()*
		前回の|inputsave()|で保存しておいた先行入力を復元する。
		inputsave()と同じ回数だけ呼ぶようにしなければならない。しかし
		多く呼びすぎても害はない。復元するものがなければ1を、そうでな
		ければ0を返す。

inputsave()						*inputsave()*
		先行入力(マッピングにより入力された文字も含む)を保存し、クリア
		することにより、これ以降のプロンプトがユーザからの入力を得るよ
		うにする。プロンプトの後で、対応するinputrestore()を呼び出さね
		ばならない。複数回呼ぶこともできる。ただしその場合は同じ回数だ
		けinputrestore()を呼ばなくてはならない。
		メモリ不足のときは1を、そうでなければ0を返す。

inputsecret({prompt} [, {text}])			*inputsecret()*
		|input()|とほぼ同じだが、以下の2点が異なる:
		a) ユーザの入力をアスタリスク("*")の列として表示し、入力内容を
		読めないようにする。
		b) ユーザの入力が入力履歴|history|に残らない。
		ユーザの入力内容を文字列として返す。
		NOTE: コマンドライン補完には対応していない。

insert({list}, {item} [, {idx}])			*insert()*
		リスト|List| {list}の初めに{item}を挿入する。
		{idx}が指定されたときはインデックス{idx}の要素の前に{item}を挿
		入する。{idx}が0のときは{idx}を省略した場合と同じ様に最初の要
		素の前に挿入する。{idx}は負数でもよい(|list-index|参照)。-1を
		指定すると最後の要素の前に挿入する。
		挿入した結果のリストを返す。例: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		最後の例は|add()|を使うともっと簡単に書ける。
		Note {item}がリストの場合は、1個の要素として追加される。リスト
		を連結するには|extend()|を使うこと。

invert({expr})						*invert()*
		ビット反転。引数は数値に変換される。リスト、辞書、浮動小数点数
		を指定するとエラーになる。例: >
			:let bits = invert(bits)

							*isdirectory()*
isdirectory({directory})
		結果は数値で、{directory}という名前のディレクトリが存在すれば
		TRUEとなる。{directory}が存在しないか、存在したとしてもディレ
		クトリではなかった場合には、FALSEが返される。文字列として解釈
		できるのならば{directory}の表現はどのようなものであってもかま
		わない。

islocked({expr})					*islocked()* *E786*
		結果は数値で、{expr}がロックされている変数の名前ならば非0を返
		す。
		{expr}は変数の名前、リストの要素、辞書の要素のいずれかでなけれ
		ばならない。変数そのものを指定しないように注意。例: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		{expr}が存在しない変数のときはエラーメッセージが表示される。変
		数の存在を確認するには|exists()|を使う。

items({dict})						*items()*
		{dict}の全要素のキー・値のペアからなるリストを返す。戻り値の各
		要素はリストであり、キーと値の2個の要素を持つ。戻り値のリスト
		の要素の順序は不定である。


join({list} [, {sep}])					*join()*
		リスト{list}の要素を連結し、1個の文字列にして返す。
		{sep}が指定されたときは、要素の間にそれを挿入する。{sep}が指定
		されなかったときは1個のスペースが使われる。
		Note 末尾には{sep}がつかない。末尾にもつけたければ以下のように
		する: >
			let lines = join(mylist, "\n") . "\n"
<		{list}の要素が文字列なら、そのまま使われる。リストと辞書は
		|string()|を使ったときと同じようにして文字列に変換される。
		この逆を行う関数は|split()|である。

keys({dict})						*keys()*
		{dict}の全キーからなるリストを返す。リストの順序は不定である。

							*len()* *E701*
len({expr})	結果は数値で、引数{expr}の長さ。{expr}が文字列または数値のとき
		は|strlen()|と同じようにバイト単位での長さを返す。
		{expr}がリストのときは要素数を返す。
		{expr}が辞書のときは要素数を返す。
		それ以外のときはエラーとなる。

						*libcall()* *E364* *E368*
libcall({libname}, {funcname}, {argument})
		ランタイムライブラリ{libname}の関数{funcname}を、単一の引数
		{argument}で呼び出す。
		Vimで使うように特別に作ったライブラリの関数を呼ぶために使われ
		る。引数は1個しか指定できないため、普通のライブラリ関数を呼ぶ
		にはかなり制限がある。
		結果には、呼び出した関数から返された文字列が返される。呼び出し
		た関数がNULLを返した場合には、Vimには空文字列 "" が戻される。
		関数の戻り値が数値である場合には|libcallnr()|を使うこと。
		もしも引数が数値ならば、関数にはint型の引数が1つ渡される。引数
		が文字列の場合には、関数にはヌル終端記号を持つ文字列が引数とし
		て渡される。
		|restricted-mode|の中で呼ぶと失敗する。

		libcall()によってVimを再コンパイルすることなく 'plug-in' と呼
		ばれる独自の拡張を行うことができるようになる。それは (直接) シ
		ステムの関数を呼ぶ、ということではない。システム関数を呼ぶとお
		そらくVimがクラッシュするだろう。

		Win32では、あなたが書いた関数をDLLに置かなければならず、また通
		常のC呼出し規約を使用しなければならない(WindowsのシステムDLLが
		使うPascalではない)。関数は正確に1つのパラメータ、char型ポイン
		タもしくはint型を取らなければならず、戻り値としてchar型ポイン
		タかNULLを返さなければならない。返されるchar型ポインタは、関数
		終了後も有効なポインタ(例えばDLL内の静的なデータ)を指さなけれ
		ばならない。(malloc等で)割り当てられたメモリを保持していた場
		合、それはリークしてしまう。DLL内のスタティックバッファを用い
		る方法は動くかもしれないが、使用済みDLLがメモリから削除される
		と同時に解放されてしまう。

		警告: もしも関数が有効ではないポインタを返すと、Vimはクラッ
		シュしてしまう。関数が数値を返してしまった場合、Vimはそれをポ
		インタとして扱ってしまうので、やはりクラッシュが起こる。
		Win32のシステムでは、{libname}はDLLのファイル名の拡張子 ".DLL"
		を付けてはならない。通常の(パスの通った)場所にDLLがない場合に
		は、フルパスで指定する必要がある。
		Unixでは、独自のプラグインをコンパイルするときはオブジェクトコー
		ドを位置独立('PIC')としてコンパイルしなければならない。
		{Win32 といくつかの Unix で、|+libcall| 機能が有効になっている
		ときのみ利用可能}
		例: >
			:echo libcall("libc.so", "getenv", "HOME")
< 
							*libcallnr()*
libcallnr({libname}, {funcname}, {argument})
		|libcall()|とほぼ同様だが、文字列でなくintを返す関数に使う。
		{Win32と、|+libcall|機能が有効になっているUnixでのみ利用可能}
		例: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
							*line()*
line({expr})	結果は数値で、{expr}で与えられた位置のファイル内での行番号。受
		け付けられる位置指定は次の通り:
		    .	    カーソルの位置
		    $	    現在のバッファの最後の位置
		    'x	    マークxの位置(マークが設定されていない場合、0が返
			    る)
		    w0	    カレントウィンドウの最上行
		    w$	    カレントウィンドウの最下行
		    v	    ビジュアルモードでは: ビジュアル選択領域の開始行
			    (カーソルがその端)。ビジュアルモード以外ではカーソ
			    ル位置を返す。すぐに更新される点が |'<| と違う。
		Note 他のファイルのマークも使える。その場合、戻り値はそのファ
		イルの行番号となる。
		桁番号を取得するには|col()|を使う。両方を取得するには
		|getpos()|を使う。
		例: >
			line(".")		カーソルの行番号
			line("'t")		マークtの位置の行番号
			line("'" . marker)	マークmarkerの位置の行番号
<							*last-position-jump*
		このオートコマンドはファイルを開いた時に、最後に開かれていた時
		の行へ自動的にジャンプするものである。これは '" マークがセット
		されている時にのみ有効である: >
	:au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

							*line2byte()*
line2byte({lnum})
		バッファの先頭から、{lnum}行目までのバイト数を返す。これには現
		在のバッファのオプション 'fileformat' に従った、end-of-line(行
		終端)文字も含まれている。最初の行においては1が返る。バイト数は
		'encoding' に基づく。'fileencoding' は無視される。
		次のようにすることで最終行を含むバイトサイズを獲得することがで
		きる: >
			line2byte(line("$") + 1)
<		これはバッファの大きさプラス1になる。もし 'fileencoding' が空
		ならその値はファイルの大きさプラス1に等しい。
		{lnum}が無効であるか、|+byte_offset|機能がコンパイル時に無効に
		されている場合、-1が返される。
		|byte2line()|、|go|及び|:goto|も参照。

lispindent({lnum})					*lispindent()*
		'lisp' をオンにしたときと同じlisp用のインデント規則に従った場
		合の{lnum}行目のインデント量を返す。
		インデント量はスペースで数えられ、'tabstop' の値は関係ない。
		{lnum}は|getline()|の場合と同様に扱われる。
		{lnum}が無効な値のときや|+lispindent|機能なしでコンパイルされ
		ているときは-1を返す。

							*localtime()*
localtime()
		現在の時刻、1970年1月1日からの経過秒数を返す。|strftime()|と
		|getftime()|も参照。


log({expr})						*log()*
		{expr} の自然対数 (底e) を浮動小数点数 (|Float|) で返す。
		{expr} は (0, inf] の範囲の浮動小数点数 (|Float|) か数値
		(|Number|) でなければならない。
		例: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


log10({expr})						*log10()*
		浮動小数点数 {expr} の 10 を底とする対数を |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならな
		い。
		例: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0
		{|+float| 機能つきでコンパイルされたときのみ有効}
		
luaeval({expr}[, {expr}])					*luaeval()*
		Lua の式 {expr} を評価し、その結果を Vim のデータ構造に変換し
		たものを返す。2番目の {expr} は、最初の {expr} の中では _A と
		してアクセスできる追加の引数を保持する。
		文字列はそのまま返される。
		ブーリアンオブジェクトは数値に変換される。
		数値は、vim が |+float| つきでコンパイルされたときは |Float|
		値に変換され、そうでなければ数値に変換される。
		vim.eval() で取得される辞書とリストはそのまま返される。
		それ以外のオブジェクトは 0 が返され、エラーにはならない。
		詳細は |lua-luaeval| を参照。
		{|+lua| 機能つきでコンパイルされたときのみ有効}

map({expr}, {string})					*map()*
		{expr}はリスト|List|または辞書|Dictionary|。
		{expr}の各要素を、{string}を評価した結果で置き換える。
		{string}の中では|v:val|が現在の要素の値を保持している。
		辞書の場合は|v:key|が現在の要素のキーを保持している。
		リストの場合は|v:key|が現在の要素のインデックスを保持してい
		る。
		例: >
			:call map(mylist, '"> " . v:val . " <"')
<		これは "mylist" の各要素の前に "> " をつけ、後に " <" をつける。

		Note {string}は式を表す文字列である。バックスラッシュを二重に
		しなくても済むように|literal-string|を使うとよいだろう。ただし
		その場合はシングルクォートを2重にしなければならない。

		この操作はその場で(in-place)行われる。リストや辞書を変更したく
		ない場合は最初にコピーを作ること: >
			:let tlist = map(copy(mylist), ' v:val . "\t"')

<		式を適用した結果の{expr}を返す。{string}を評価している最中にエ
		ラーが発生した場合は、それ以降の要素は処理されない。


maparg({name}[, {mode} [, {abbr} [, {dict}]]])			*maparg()*
		{dict}が省略されたかゼロのとき: モード{mode}におけるキーマップ
		{name}のrhsを返す。結果の文字列内の特殊文字は、":map" コマンド
		でリスト表示した時のように変換される。
		
		{name}というキーマップが存在しない場合、空文字列が返される。
		
		{name}には ":map" コマンドで使用可能な、特殊なキー名が指定でき
		る。
		
		{mode}には次の文字が使用可能:
			"n"	ノーマル
			"v"	ビジュアル (選択含む)
			"o"	オペレータ待機 (Operator-pending)
			"i"	挿入
			"c"	コマンドライン
			"s"	選択
			"x"	ビジュアル
			"l"	langmap |language-mapping|
			""	ノーマル、ビジュアル、及びオペレータ待機
		{mode}が省略された場合、"" が使用される。

		{abbr}が指定され、0でない場合はマッピングでなく短縮入力を対象
		とする。

		{dict} に非ゼロの値が指定されたときはマッピングのすべての情報
		を含んだ辞書が返る:
		  "lhs"	     マッピングの {lhs}
		  "rhs"	     マッピングの {rhs} (入力されたまま)
		  "silent"   |:map-silent| マッピングなら 1。そうでなければ0。
		  "noremap"  マッピングの {rhs} が再マップ可能なら 1。
		  "expr"     式マッピング (|:map-<expr>|) なら 1。
		  "buffer"   バッファローカルマッピング (|:map-local|) なら1。
		  "mode"     マッピングが定義されているモード。上述のモードに
			     加え、次の文字が使用される:
			     " "     ノーマル、ビジュアル、オペレータ待機
			     "!"     挿入、コマンドラインモード (|mapmode-ic|)
		  "sid"	     <sid> マッピングで使用されるスクリプトローカルID
			     (|<SID>|)。

		まずカレントバッファにローカルなマッピングを探し、次のグローバ
		ルマッピングを探す。
		この関数を使うと、あるキーに対して既にマップがされているとき、
		その動作を行いつつ、再マップすることができる。概要: >
			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')

mapcheck({name}[, {mode} [, {abbr}]])			*mapcheck()*
		モード{mode}におけるキーマップ{name}が存在するかチェックする。
		{name}に指定できる特殊文字は|maparg()|を参照。
		{abbr}が指定され、0でない場合はマッピングでなく短縮入力を対象
		とする。
		マッピングが{name}で始まるとき、またはマッピングが{name}のはじ
		めに等しいときマッチすると見なされる。

			マッチするか    "a"     "ab"    "abc" ~
		   mapcheck("a")	yes	yes	 yes
		   mapcheck("abc")	yes	yes	 yes
		   mapcheck("ax")	yes	no	 no
		   mapcheck("b")	no	no	 no

		maparg()との違いは、mapcheck()は{name}にマッチするマップを見つ
		けるが、maparg()はぴったり{name}に一致するマッピングのみを見つ
		ける。
		{name}にマッチするキーマップが存在しない時には、空文字列が返さ
		れる。結果が一つならばマップされたrhsが返される。複数見つかっ
		た場合には、それらのうちどれか一つのrhsが返される。
		まずカレントバッファにローカルなマッピングを探し、次のグローバ
		ルマッピングを探す。
		この関数はマッピングが曖昧にならないかチェックするために使うこ
		とができる。例: >
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
<		これは、"_vv" というマッピングが "_v" とか "_vvv" といったマッ
		ピングと衝突しないように事前にチェックしている。

match({expr}, {pat}[, {start}[, {count}]])			*match()*
		{expr}がリストの場合は、{pat}にマッチする最初の要素のインデッ
		クスを返す。各要素は文字列として扱われる。リストと辞書はechoし
		たときと同じように文字列表現に変換される。
		それ以外の場合は、{expr}は文字列として扱われる。{expr}の中で
		{pat}にマッチするインデックス(バイト単位のオフセット)を表す数
		値を返す。
		最初の文字またはリストの最初の要素にマッチしたときは0を返す。
		マッチがないときは-1を返す。
		サブマッチを取得するには |matchlist()| を参照。
		例: >
			:echo match("testing", "ing")	" 結果は 4
			:echo match([1, 'x'], '\a')	" 結果は 1
<		{pat}の扱われ方については|string-match|を参照。
								*strpbrk()*
		strpbrk()に相当する関数はVimに存在しない。しかし同じことを次の
		ようにしてできる: >
			:let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		strcasestr()に相当する関数はVimに存在しない。しかし正規表現に
		"\c" をつければ大文字・小文字の違いを無視できる: >
			:let idx = match(haystack, '\cneedle')
<
		{start}が指定されたときは、文字列のバイトインデックス{start}の
		位置、またはリストの{start}の要素から検索を始める。
		その場合も戻り値は最初の文字/要素から数えたインデックスである
		ことに注意。例: >
			:echo match("testing", "ing", 2)
<		の結果は "4"。 >
			:echo match("testing", "ing", 4)
<		の結果は "4"。 >
			:echo match("testing", "t", 2)
<		の結果は "3"。
		文字列の場合、{start} > 0のときは、その文字列が{start}バイト後
		から始まるかのように扱われる。そのため、"^" は{start}の位置に
		マッチする。ただし{count}が指定されたときは、{start}より前にお
		けるマッチを無視しているかのように振る舞う(これは後方互換性を
		保つのを少々複雑にしている)。
		文字列の場合、{start} < 0のときは{start}に0をセットする。リス
		トの場合は、末尾からインデックスを数えるという意味になる。
		{start}が範囲外の場合(文字列で{start} > strlen({expr})となった
		場合、リストで{start} > len({expr})となった場合)は-1を返す。

		{count}が指定されたときは{count}番目のマッチ位置を返す。文字列
		でマッチが見つかったとき、次のマッチングは1文字先から行われる。
		よって次の例は1を返す: >
			echo match("testing", "..", 0, 2)
<		リストの場合は次の要素から検索を続ける。
		Note {count}を指定すると、{start}の扱い方が変わってしまう。
		前の段落を参照。

		受け付ける正規表現については|pattern|を参照。
		オプション 'ignorecase' により、大文字・小文字を区別するかどう
		かを設定できる。'smartcase' は適用されない。マッチングは常に
		'magic' をオン、'cpoptions' を空にした状態で行われる。

					*matchadd()* *E798* *E799* *E801*
matchadd({group}, {pattern}[, {priority}[, {id}]])
		カレントウィンドウで強調表示するパターンを定義する。このパター
		ンのことを「マッチ」と呼ぶ。構文グループ {group}で強調する。戻
		り値は、マッチを識別する ID である。|matchdelete()|でこの ID
		を指定してマッチを削除することができる。

		省略可能な引数 {priority} はマッチの優先度を指定する。優先度が
		高いマッチは、より低いマッチの強調を上書きする。優先度は整数で
		指定する(負の数も可能)。{priority} が指定されない場合は既定の
		優先度 10 となる。'hlsearch' の優先度はゼロで、したがってゼロ
		より大きい優先度のマッチはすべてそれを上書きする。構文ハイライ
		ト('syntax' を参照)は独立したメカニズムであり、優先度がいくつ
		であろうとマッチは構文ハイライトより優先する。

		{id} は特定のマッチ ID を返すことを要求する。指定された ID が
		すでに使われていたら、エラーメッセージが表示され、そのマッチは
		登録されない。ID は正の整数を指定する(ゼロは除く)。ID 1, 2, 3
		は |:match|, |:2match|, |:3match| 用に予約されている。{id} が
		指定されないときは、|matchadd()| が自動的に空いている ID を取
		得する。

		コマンド |:match| と異なり、マッチの個数に上限はない。

		例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		このパターンを削除するには: >
			:call matchdelete(m)

<		|matchadd()| と |:match| で定義したマッチのリストは
		|getmatches()| で取得できる。全てのマッチを削除するのは
		|clearmatches()| 一発でできる。

matcharg({nr})							*matcharg()*
		|:match|、|:2match|、|:3match|によって設定されているマッチパター
		ンの情報を返す。{nr}が1のときは|:match|の情報、2のときは
		|:2match|の情報、3のときは|:3match|の情報を返す。
		戻り値は次の2個の要素を持つリストである:
			引数で指定したハイライトグループ名
			引数で指定した検索パターン
		{nr}が1、2、3のどれでもないときは空リストを返す。
		マッチパターンがセットされていないときは['', '']を返す。
		|:match|を保存し、復元するのに便利である。
		|:match| を使った強調は 3 個までに限られている。
		|matchadd()| にはこの制限はない。

matchdelete({id})			       *matchdelete()* *E802* *E803*
		|matchadd()| または |:match| で定義したマッチの中で ID が {id}
		であるものを削除する。成功したときは 0、失敗したときは
		-1 を返す。|matchadd()| の例を参照。すべてのマッチを削除するの
		は |clearmatches()| 一発でできる。

matchend({expr}, {pat}[, {start}[, {count}]])			*matchend()*
		|match()|と同じだが、返されるのはマッチした部分文字列の終了後の
		インデックスである。例: >
			:echo matchend("testing", "ing")
<		結果は "7"。
							*strspn()* *strcspn()*
		Vimにはstrspn()やstrcspn()に相当する関数はないが、matchend()を
		使えば同じことができる: >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		ただしマッチがないときには-1を返すところが異なる。

		{start}は|match()|の場合と同じ意味を持つ。 >
			:echo matchend("testing", "ing", 2)
<		結果は "7"。 >
			:echo matchend("testing", "ing", 5)
<		結果は "-1"。
		{expr}がリストの場合、戻り値は |match()| と等しくなる。

matchlist({expr}, {pat}[, {start}[, {count}]])			*matchlist()*
		|match()| と同じだがリストを返す。リストの最初の要素は、
		matchstr()が返すのと同じマッチした文字列。それ以降の要素は
		|:substitute|における "\1"、"\2" のようなサブマッチである。\1
		から\9までの間で、指定されなかったものは空文字列となる。例: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		結果は['acd', 'a', '', 'c', 'd', '', '', '', '', '']となる。
		マッチしなかったときは空リストを返す。

matchstr({expr}, {pat}[, {start}[, {count}]])			*matchstr()*
		|match()| と同じだが、マッチした文字列を返す。例: >
			:echo matchstr("testing", "ing")
<		結果は "ing"。
		マッチしなかったときは "" を返す。
		{start}の意味は |match()| の場合と同じ。 >
			:echo matchstr("testing", "ing", 2)
<		結果は "ing"。 >
			:echo matchstr("testing", "ing", 5)
<		結果は ""。
		{expr}がリストのときはマッチした要素を返す。
		その要素の型は変換されないため、必ずしも文字列であるとは限らな
		い。

							*max()*
max({list})	{list}の全要素の値の最大値を返す。
		{list}がリストでなかったり、要素のどれかが数値に変換できない場
		合はエラーとなる。
		空リストの場合は0を返す。

							*min()*
min({list})	{list}の全要素の値の最小値を返す。
		{list}がリストでなかったり、要素のどれかが数値に変換できない場
		合はエラーとなる。
		空リストの場合は0を返す。

							*mkdir()* *E739*
mkdir({name} [, {path} [, {prot}]])
		ディレクトリ{name}を作成する。
		{path}が "p" のときは必要に応じて途中のディレクトリも作成され
		る。そうでないときは "" にすること。
		{prot}は作成するディレクトリの保護ビット。デフォルトは0755
		(rwxr-xr-x: 所有者は読み書き可能、他の人は読み込み可能)。
		他の人が読み込めないようにするには0700とすること。{prot} は
		{name} の最後の部分にのみ適用される。なので、/tmp/foo/bar
		を作成すると /tmp/foo は 0755 で作成される。
		例: >
			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
<		|sandbox|の中ではこの関数は使用できない。
		システムによっては利用できない場合がある。これを確認するには次
		のようにする: >
			:if exists("*mkdir")
<
							*mode()*
mode([expr])		現在のモードを示す文字列を返す。
			[expr] に 0 でない数値か空でない文字列(|non-zero-arg|)
			を指定した場合、フルモードが返される。それ以外の場合は
			最初の一文字だけが返される。" " と "0" はどちらも空文
			字列ではないことに注意。

			n	ノーマル
			no	オペレータ待機
			v	文字指向ビジュアル
			V	行指向ビジュアル
			CTRL-V	矩形指向ビジュアル
			s	文字指向選択
			S	行指向選択
			CTRL-S	矩形指向選択
			i	挿入
			R	置換 |R|
			Rv	仮想置換 |gR|
			c	コマンドライン
			cv	Vim Ex モード |gQ|
			ce	ノーマル Ex モード |Q|
			r	Hit-enter プロンプト
			rm	-- more -- プロンプト
			r?	ある種の |:confirm| 問い合わせ
			!	シェルまたは外部コマンド実行中
		これらはオプション 'statusline' の中や、|remote_expr()| といっ
		しょに使うと便利である。他のほとんどの場所では "c" または "n"
		しか返さない。
		|visualmode()| も参照。

mzeval({expr})							*mzeval()*
		MzScheme の式 {expr} を評価してその結果を Vim の変数に変換した
		結果を返す。
		数値と文字列はそのまま返る。
		ペア (リストと不適切なリスト (improper list) を含む) とベクタ
		は Vim のリスト (|Lists|) に変換される。
		ハッシュテーブルは Vim の辞書 (|Dictionary|) に変換され、その
		キーは文字列に変換される。
		その他のすべての型は display 関数を使って文字列に変換される。
		例: >
		    :mz (define l (list 1 2 3))
		    :mz (define h (make-hash)) (hash-set! h "list" l)
		    :echo mzeval("l")
		    :echo mzeval("h")
<
		{|+mzscheme| 機能を有効にしてコンパイルしたときのみ有効}

nextnonblank({lnum})					*nextnonblank()*
		{lnum}行以降({lnum}行を含む)の最初の非空行の行番号を返す。
		例: >
			if getline(nextnonblank(1)) =~ "Java"
<		{lnum}が無効なときや、それ以降に非空行がないときは0を返す。
		|prevnonblank()|も参照。

nr2char({expr}[, {utf8}])				*nr2char()*
		コード{expr}で表される1文字からなる文字列を返す。例: >
			nr2char(64)		"@"を返す
			nr2char(32)		" "を返す
<		{utf8} を省略、またはゼロを指定すると、現在の 'encoding' が適
		用される。"utf-8" の場合の例: >
			nr2char(300)		短音記号つきのIを返す
<		{utf8} に 1 を指定すると、常に utf-8 文字が返る。
		Note Vim内部では、ファイル中のNUL文字を改行文字(0x0A)に変換し
		て保持している。そのため、nr2char(10)とすればNUL文字を指定でき
		る。nr2char(0)は真のNUL文字(文字列の終端)となるので、空文字列
		を返す。

							*getpid()*
getpid()	Vim のプロセス ID を数値で返す。Unix と MS-Windows では Vim が
		終了するまでこれは一意な数値である。MS-DOS では常にゼロである。

							*getpos()*
getpos({expr})	{expr}の位置を返す。{expr}として指定できる値については
		|line()|を参照。
		結果は次の4個の要素を持つリスト|List|:
		    [bufnum, lnum, col, off]
		"bufnum" は、'0 や 'A のようなマークが指定されたときは、その
		マークのバッファ番号となる。それ以外では0となる。
		"lnum" と "col" はバッファ中の位置。桁番号は1から始まる。
		"off" の値は、'virtualedit' がオフのときは常に0で、オンのとき
		はその文字の始点からの画面上の桁のオフセットである。つまり、
		カーソルが<Tab>の中や、その行の最後の文字より後にあるとき意味
		を持つ。
		この関数はカーソル位置を保存し、復元するために使われる: >
			let save_cursor = getpos(".")
			MoveTheCursorAround
			call setpos('.', save_cursor)
<		|setpos()|も参照。

or({expr}, {expr})					*or()*
		二つの引数のビット論理和。引数は数値に変換される。リスト、辞
		書、浮動小数点数を指定するとエラーになる。
		例: >
			:let bits = or(bits, 0x80)


pathshorten({expr})					*pathshorten()*
		パス{expr}におけるディレクトリ名を短縮して返す。拡張子、ファイ
		ル名はそのまま保たれる。パスのその他の構成要素は1文字に縮めら
		れる。1文字目の '~' と '.' はそのまま保たれる。例: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
		パスが実際に存在するかどうかは関係ない。

pow({x}, {y})						*pow()*
		{x} の {y} 乗を |Float| で返す。{x} と {y} は |Float| または
		|Number| に評価されなければならない。
		例: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0
		{|+float| 機能つきでコンパイルされたときのみ有効}
		
prevnonblank({lnum})					*prevnonblank()*
		{lnum}行以前({lnum}行を含む)の最初の非空行の行番号を返す。
		例: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		{lnum}が無効なときや、それ以降に非空行がないときは0を返す。
		|nextnonblank()|も参照。


printf({fmt}, {expr1} ...)				*printf()*
		{fmt}にしたがって組み立てた文字列を返す。{fmt}中の "%" 変換指
		示子は、対応する引数の値で置き換えられる。例: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		結果は次のような形になる:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		よく使われる変換指示子は次の通り:
		  %s	文字列
		  %6S	6表示幅で右揃えした文字列
		  %6s	6バイトで右揃えした文字列
		  %.9s	9バイトに切り詰めた文字列
		  %c	1バイト
		  %d	10進数値
		  %5d	スペースで埋めて5文字にした10進数値
		  %x	16進数値
		  %04x	0で埋めて少なくとも4文字にした16進数値
		  %X	16進数値(大文字)
		  %o	8進数値
		  %f	123.456 形式の浮動小数点数
		  %e	1.234e3 形式の浮動小数点数
		  %E	1.234E3 形式の浮動小数点数
		  %g	浮動小数点数。値によって %f または %e となる
		  %G	浮動小数点数。値によって %f または %E となる
		  %%    文字 % そのもの

		変換指示子は '%' で始まり、変換文字で終わる。それ以外の全ての
		文字はそのままになる。

		"%" は変換指示子の開始を意味する。以下の順序で引数を指定できる:

			%  [flags]  [field-width]  [.precision]  type

		フラグ
			0個以上の以下のフラグを指定できる

		    #	      値を「代替形式」に変換する。変換指示子c, d, sに
			      対してはこのオプションは効果を持たない。変換指示
			      子oに対しては数値の精度を上げ、出力文字列の最初
			      の文字が0になる。(明示的な精度0で値0が表示される
			      ときを除く)
			      変換指示子xとXに対しては、値が0でない場合、文字
			      列 "0x" (変換子Xの場合は "0X")を前につける。

		    0 (zero)  ゼロパディングする。全ての変換に対し、変換された
			      値の左側を空白でなく0で埋める。数値変換(d, o, x,
			      X)に対して精度が指定されている場合はフラグ0は無
			      視される。

		    -	      負のフィールド幅を示す。変換値がフィールド境界に
			      左揃えされる。変換値の左に空白や0がつくのではな
			      く、変換値の右に空白がつく。
			      -と0を両方指定した場合は-が有効になる。

		    ' ' (space)  空白。符号付き変換(d)で作成される正の数値の前
			      に空白が残る。

		    +	      +文字。符号付き変換で作成される数値の前に常に符
			      号を付ける。+と' '(space)を両方指定した場合は+が
			      有効になる。

		フィールド幅
			10進数文字列(省略可)。最低フィールド幅を指定する。変換
			値のバイト数がこのフィールド幅より少ない場合、左に空白
			がついて(左揃えフラグを指定した場合は右に空白がついて)
			フィールドの幅に合わせられる。

		.精度
			ピリオド '.' の次に数字文字列がつづく形式の精度(省略
			可)。数字文字列を省略した場合、精度は0になる。d, o, x,
			X変換における最低桁数を指定する。また、s変換における最
			大バイト数を指定する。
			浮動小数点数の場合は小数点以下の桁数。

		型
			変換の型を指定する1文字。下記を参照。

		フィールド幅と精度には、数字文字列の代わりにアスタリスク '*'
		を指定できる。その場合、対応する数値の引数がフィールド幅または
		精度となる。負のフィールド幅を指定すると、絶対値がフィールド幅
		となり、左揃えフラグがオンになる。負の精度を指定すると、完全に
		無視される。例: >
			:echo printf("%d: %.*s", nr, width, line)
<		この例は、テキスト "line" の長さを "width" バイトに制限する。

		変換指示子の意味は以下の通り: 

				*printf-d* *printf-o* *printf-x* *printf-X*
		doxX    数値の引数を符号付き10進数(d)、符号なし8進数(o)、符号
			なし16進数(xまたはX)の書式に変換する。xの場合は
			"abcdef" と小文字を使い、Xの場合は "ABCDEF" と大文字を
			精度は出力する最小桁数を意味する。変換された値を出力す
			るのにそれ以下しか必要としない場合は、左側にゼロを加え
			て埋める。
			フィールド幅が存在しない場合や小さすぎる場合でも、数値
			の幅を切り詰めることは決してない。変換結果がフィールド
			幅より多くの桁を必要とする場合は、十分な幅に広げられる。

							*printf-c*
		c	引数の数値を1バイトに変換し、結果の文字列を書き出す。

							*printf-s*
		s	引数の文字列を出力する。精度を指定した場合、その数値以
			下のバイト数のみを書き出す。
		S	引数の文字列を出力する。精度を指定した場合、その数値以
			下の表示幅のみを書き出す。|+multi_byte| 機能がない場合
			は 's' と同じ動作になる。

							*printf-f* *E807*
		f	Float の引数を 123.456 の形式の文字列に変換する。精度
			は小数点以下の桁数を指定する。精度が 0 のときは小数点
			以下は省略される。精度を指定しないときは 6 桁となる。
			とてつもなく大きい数(範囲外またはゼロによる除算)のとき
			は "inf" となる。"0.0 / 0.0" は "nan" になる。
			例: >
				echo printf("%.2f", 12.115)
<				12.12
			丸めはシステムのライブラリに依存する。心配なときは
			|round()| を使うこと。

							*printf-e* *printf-E*
		e E	Float の引数を 1.234e+03 という形式('E' のときは
			1.234E+03)の文字列に変換する。精度は 'f' の場合と同じ
			く小数点以下の桁数を指定する。

							*printf-g* *printf-G*
		g G	0.001(を含む)から10000000.0(を除く)の間の場合は 'f' の
			形式で変換し、この間にない場合は 'g' は 'e'、'G' は 'E'
			の形式によって変換する。精度が指定されないときは余分な
			ゼロ(小数点の直後のゼロ以外)と '+' 記号は省かれる。よっ
			て 10000000.0 は 1.0e7 になる。

							*printf-%*
		%	単一の '%' を書き出す。引数は変換しない。完全な変換指
			定は "%%" となる。

		数値の引数を受け取る変換指示子には文字列を与えることもできる。
		変換は自動的に行われる。
		浮動小数点数または文字列の引数を受け取る変換指示子には、数値を
		与えることもできる。変換は自動的に行われる。
		それ以外の型の引数を与えるとエラーメッセージが表示される。

							*E766* *E767*
		{expr1}以降の引数の数と "%" 変換指示子の個数がちょうど一致しな
		ければならない。そうでない場合はエラーとなる。引数は最大18個ま
		で使える。


pumvisible()						*pumvisible()*
		ポップアップメニューが表示されているときには非0を返す。表示さ
		れていないときは0を返す。|ins-completion-menu|を参照。
		ポップアップメニューを消してしまうような操作を避けるために使わ
		れる。

							*E860*
py3eval({expr})						*py3eval()*
		Python の式 {expr} を評価して、結果を Vim のデータ形式にして返
		す。
		数値と文字列はそのまま返る (ただし文字列はコピーされ、ユニコー
		ドから 'encoding' に変換される)。
		リストは Vim の |List| 型に変換される。
		辞書は Vim の |Dictionary| 型に変換される。辞書のキーは文字列
		に変換される。
		{|+python3| 機能付きでコンパイルされたときのみ利用可能}

							*E858* *E859*
pyeval({expr})						*pyeval()*
		Python の式 {expr} を評価して、結果を Vim のデータ形式にして返
		す。
		数値と文字列はそのまま返る (ただし文字列はコピーされる)。
		リストは Vim の |List| 型に変換される。
		辞書は Vim の |Dictionary| 型に変換される。文字列ではない辞書
		のキーはエラーになる。
		{|+python| 機能付きでコンパイルされたときのみ利用可能}

							*E726* *E727*
range({expr} [, {max} [, {stride}]])				*range()*
		以下のような数値のリスト|List|を返す。
		- {expr}のみを指定したときは:  [0, 1, ..., {expr} - 1]
		- {max}を指定したときは: [{expr}, {expr} + 1, ..., {max}]
		- {stride}を指定したときは: [{expr}, {expr} + {stride}, ...,
		  {max}] ({max}を超えないように{expr}を{stride}ずつ増加させる)
		最大値が開始位置より1だけ前のときは空リストを返す。最大値が開
		始位置より1以上前のときはエラーになる。
		例: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" エラー!
<
							*readfile()*
readfile({fname} [, {binary} [, {max}]])
		ファイル{fname}を読み込み、各行を要素とするリスト|List|を返す。
		行はNL文字で終わるものとする。改行文字がCRであるMacintoshのファ
		イルは単一の長い行となる(どこかにNLが現れない限り)。
		すべての NUL 文字は NL 文字に置換される。
		{binary}が "b" に等しい場合、次のようにバイナリモードになる:
		- 最後の行がNLで終わるときは、リストの末尾に余分な空文字列が追
		  加される。
		- CR文字を除去しない。
		バイナリモードでない場合:
		- NLの前に現れるCR文字を除去する。
		- 最後の行がNLで終わるかどうかは関係ない。
		- 'encoding' がUnicodeのときは UTF-8 のバイトオーダーマークは
		  取り除かれる。
		{max}を指定すると、読み込む行数の最大値となる。ファイルの最初
		の10行をチェックするときに役に立つ: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		{max}が負の場合は、ファイルの最後から-{max}行を読み込んで返す。
		ファイルが{max}行以下の場合は全行を返す。
		{max}が0の場合は空リストを返す。
		Note {max}を指定しない場合はファイル全体をメモリに読み込む。エ
		ンコーディング判定も行わないことに注意。必要ならバッファに読み
		込むこと。
		ファイルを開けないときはエラーメッセージを表示し、空リストを返
		す。
		|writefile()|も参照。

reltime([{start} [, {end}]])				*reltime()*
		時刻値を表す値を返す。値の形式はシステムに依存する。この値を
		|reltimestr()|に渡すと文字列に変換できる。
		引数を指定しないと現在時刻を返す。
		1個の引数を指定すると、その引数で指定された時刻からの経過時間
		を返す。
		2個の引数を指定すると、{start}と{end}の間の経過時間を返す。
		{start}と{end}はreltime()で返される値でなければならない。
		{|+reltime| 機能付きでコンパイルされたときのみ利用可能}

reltimestr({time})				*reltimestr()*
		時刻値{time}を表現する文字列を返す。秒、ドット、マイクロ秒とい
		う形式になる。例: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		Note このコマンドにかかるオーバーヘッドがこの時間に加算される。
		精度はシステムに依存する。
		文字列をきれいに揃えるために、先頭にスペースが挿入される。この
		スペースを取り除くにはsplit()を使えばよい。 >
			echo split(reltimestr(reltime(start)))[0]
<		|profiling|も参照。
		{|+reltime| 機能付きでコンパイルされたときのみ利用可能}

							*remote_expr()* *E449*
remote_expr({server}, {string} [, {idvar}])
		{string}を{server}に送信する。{string}は式と見なされ、評価した
		結果が返ってくる。
		戻り値は文字列かリスト|List|でなければならない。リストの場合は
		要素を連結して文字列に変換される。要素間の区切りは改行文字とな
		る(join(expr, "\n")と同様)。
		{idvar}には変数名を指定する。後でremote_read()で使われる
		{serverid}がその変数に保存される。
		|clientserver|と|RemoteReply|も参照。
		|sandbox|の中ではこの関数は利用できない。
		{|+clientserver|機能付きでコンパイルされたときのみ利用可能}
		Note: なんらかのエラーが発生した場合は、ローカルでエラーメッセー
		ジが表示され、戻り値は空文字列となる。
		例: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<

remote_foreground({server})				*remote_foreground()*
		サーバ名{server}のVimをフォアグラウンドに移動させる。
		次を実行するのと同様である: >
			remote_expr({server}, "foreground()")
<		
		ただし、次の点が異なる: Win32では、OSが必ずしもサーバが自分自
		身をフォアグラウンドにすることを許可しないので、対応策としてク
		ライアントが仕事を行う。
		Note: foreground()と違い、最小化されていたウィンドウを復元しな
		い。
		|sandbox|の中ではこの関数は利用できない。
		{Win32, Athena, Motif, GTKのGUI版とWin32コンソール版でのみ利用
		可能}


remote_peek({serverid} [, {retvar}])		*remote_peek()*
		{serverid}から文字列を取得可能ならば正の数値を返す。変数
		{retvar}に返信文字列をコピーする。{retvar}は変数の名前を示す文
		字列でなければならない。
		取得できないならば0を返す。
		なんらかの異状のときは-1を返す。
		|clientserver|も参照。
		|sandbox|の中ではこの関数は利用できない。
		{|+clientserver|機能付きでコンパイルされたときのみ利用可能}
		例: >
			:let repl = ""
			:echo "PEEK: ".remote_peek(id, "repl").": ".repl

remote_read({serverid})				*remote_read()*
		{serverid}からの返信の中で最も古いものを取り出して返す。取り出
		した返信はキューから取り除かれる。キューに返信が入っていないと
		きは、返信を取り出せるようになるまで待機する。
		|clientserver|も参照。
		|sandbox|の中ではこの関数は利用できない。
		{|+clientserver|機能付きでコンパイルされたときのみ利用可能}
		例: >
			:echo remote_read(id)
<
							*remote_send()* *E241*
remote_send({server}, {string} [, {idvar}])
		{string}を{server}に送信する。{string}はキー入力として解釈され、
		この関数の呼び出しは即座に戻ってくる。Vimサーバにおいて、受け
		取ったキー入力はマッピング展開されない。|:map|
		{idvar}には変数名を指定する。後でremote_read()で使われる
		{serverid}がその変数に保存される。
		|clientserver|と|RemoteReply|も参照。
		|sandbox|の中ではこの関数は利用できない。
		{|+clientserver|機能付きでコンパイルされたときのみ利用可能}
		Note: なんらかのエラーが発生すると、サーバ側で報告され、表示が
		乱れてしまうかもしれない。
		例: >
		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo ".
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<
remove({list}, {idx} [, {end}])				*remove()*
		{end}を指定しなかった場合: リスト{list}から{idx}位置の要素を削
		除し、その要素を返す。
		{end}を指定した場合: {idx}から{end}まで(両端を含む)の要素を削
		除し、それらの要素からなるリストを返す。{idx}と{end}が同じ要素
		を指す場合、1個の要素からなるリストが返る。{end}が{idx}より前
		になる場合、エラーとなる。
		{idx}と{end}として指定できる値については|list-index|を参照。
		例: >
			:echo "last item: " . remove(mylist, -1)
			:call remove(mylist, 0, 9)
remove({dict}, {key})
		{dict}からキー{key}を持つ要素を削除する。例: >
			:echo "removed " . remove(dict, "one")
<		{dict}に{key}がない場合はエラーになる。

		ファイルを削除するには|delete()|を使う。

rename({from}, {to})					*rename()*
		ファイルの名前を{from}から{to}へ変える。ファイルシステムを越え
		てファイルを移動するのにも使用できる。結果は数値で、成功すれば
		0、失敗すれば非ゼロになる。
		NOTE: ファイル {to} がすでに存在する場合、警告なしに上書きされ
		る。
		|sandbox|の中ではこの関数は利用できない。

repeat({expr}, {count})					*repeat()*
		{expr}を{count}回繰り返し、連結して返す。例: >
			:let separator = repeat('-', 80)
<		{count}が0または負のときは空文字列を返す。{expr}がリスト
		|List|のときは{count}回連結した結果を返す。例: >
			:let longlist = repeat(['a', 'b'], 3)
<		結果は['a', 'b', 'a', 'b', 'a', 'b']となる。


resolve({filename})					*resolve()* *E655*
		MS-Windowsでは{filename}がショートカット(.lnkファイル)ならばそ
		の指す先を単純化した形式で返す。
		Unixではパス{filename}の中の全てのシンボリックリンクを解決し、
		単純化して返す。循環リンクがある場合に備えて、シンボリックリン
		クの解決は100回までに制限されている。
		その他のシステムでは{filename}を単純化して返す。
		単純化の手順は|simplify()|と同じである。
		resolve()は(結果も相対パスであるならば)カレントディレクトリを
		表す先頭のパスコンポーネントと、末尾のパス区切り文字をそのまま
		にする。

							*reverse()*
reverse({list})	{list}の要素の順序をその場で(in-place)反転させる。{list}そのも
		のを返す。
		リストを変更させないでおくには、最初にコピーを作る: >
			:let revlist = reverse(copy(mylist))

round({expr})							*round()*
		{expr} を最も近い整数に丸め、|Float| を返す。{expr} が二つの整
		数の真ん中にある場合、大きい方(0 から遠い方)になる。
		{訳注: つまり四捨五入になる}
		{expr} は |Float| または |Number| に評価されなければならない。
		例: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0
		{|+float| 機能つきでコンパイルされたときのみ有効}

screencol()							*screencol()*
		現在のカーソルのスクリーン列を数値で返す。一番左の列番号は 1。
		この関数は主にテスト用。

		Note: 常に現在のスクリーン列を返す。したがって、コマンドで使わ
		れた場合 (例えば ":echo screencol()") は、コマンドライン内の列
		を返す (つまりコマンドが実行されたときその値は 1)。ファイル内
		でのカーソル位置を取得するには次のようなマップを使用する: >
			nnoremap <expr> GG ":echom ".screencol()."\n"
			nnoremap <silent> GG :echom screencol()<CR>
<
screenrow()							*screenrow()*
		現在のカーソルのスクリーン行を数値で返す。一番上の行番号は 1。
		この関数は主にテスト用。

		Note: |screencol()| と同様の制約あり。

search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
		正規表現パターン{pattern}を検索する。検索はカーソル位置から開
		始する(検索位置を指定するには|cursor()|を使えばよい)。

		マッチが見つかった場合はその行番号を返す。
		マッチがない場合は0を返し、カーソルは移動しない。エラーメッ
		セージは表示されない。

		{flags} は以下のフラグ文字からなる文字列
		'b'	後方(上方)に検索する
		'c'     カーソル位置のマッチを受け入れる
		'e'	マッチの末尾へ移動する
		'n'	カーソルを移動させない
		'p'	部分パターン(後述)のマッチの番号を返す
		's'	以前のカーソル位置をマーク ' に記録する
		'w'	ファイルの末尾で循環する
		'W'	ファイルの末尾で循環しない
		'w' と 'W' の両方とも指定されない場合は 'wrapscan' が適用され
		る。

		フラグ 's' が指定された場合、カーソルが移動したときのみマーク'
		が設定される。フラグ 's' は 'n' と組み合わせることはできない。

		'ignorecase', 'smartcase', 'magic' が適用される。

		引数{stopline}が指定されたときはこの行を検索した後で検索を停止
		する。これは検索する行を制限するために有用である。例: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		{stopline}に0でない値が指定されたときは、暗黙にファイルの末尾
		で循環しなくなる。
		0 の値は、引数を省略したときと同じになる。

		{timeout} が指定された場合、そのミリ秒が経過したところで検索が
		停止する。つまり、{timeout} が 500 なら検索は 500 ミリ秒で停止
		する。
		この値は負であってはならない。0 の値は、引数を省略したときと同
		じになる。
		{|+reltime| 機能つきでコンパイルされたときのみ有効}

							*search()-sub-match*
		フラグ 'p' を指定すると、戻り値は \(\) によるグループ化のうち
		最初にマッチしたものの番号プラス 1 となる。パターン全体はマッ
		チしたがどのグループもマッチしなかったときは 1 を返す。
		桁番号を取得するには|searchpos()|を使う。

		フラグ 'n' が指定されていない場合、マッチ位置にカーソルが移動
		する。

		例 (引数リストの全ファイルにわたって検索して置換する): >
		    :let n = 1
		    :while n <= argc()   " arglist中の全ファイルに対してループ
		    :  exe "argument " . n
		    :  " ファイルの最後の文字から開始し、循環してファイルの
		    :  " 最初から検索する
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :    s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update	    " 修正されていればファイルを保存する
		    :  let n = n + 1
		    :endwhile
<
		フラグの使い方の例: >
		    :echo search('\<if\|\(else\)\|\(endif\)', 'ncpe')
<		このコマンドは、カーソル下の文字以降からキーワード "if",
		"else", "endif" のいずれかを検索する。フラグ 'p' により、どの
		キーワードが見つかったかに応じて1,2,3を返す。見つからなかった
		ときは0を返す。次の行の最初の単語にカーソルをおいて上のコマン
		ドを実行すると:
		    if (foo == 0) | let foo = foo + 1 | endif ~
		1が返る。フラグ 'c' を外すと "endif" にマッチし3を返すようにな
		る。カーソルを "if" の "f" の上におき、フラグ 'e' を外して実行
		しても同じく3が返る。フラグ 'n' によりカーソルは移動しない。


searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		{name}の宣言を検索する。

		{global}が0でないときは|gD|と同じようにファイル中の最初のマッ
		チを探す。そうでないときは|gd|と同じ動作になり、現在の関数内か
		ら最初のマッチを探す。

		{thisblock}が0でないときはカーソル位置より前の位置で閉じている
		{}ブロックを無視し、そのスコープ内でだけ有効な変数宣言にマッチ
		しないようになる。

		マッチを見つけるとその位置へカーソルを移動する。
		成功すると0を返し、失敗すると非0を返す。
		例: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
							*searchpair()*
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		ネストしたstart・endのペアを検索する。これを使うと、"if" に対
		応する "endif" を見つけることができる。それらの間にある他のif・
		endifのペアは無視される。
		検索はカーソル位置から開始する。デフォルトでは下方に検索する。
		{flags}に 'b' が含まれていると上方に検索する。
		マッチが見つかると、その位置へカーソルを移動し、行番号を返す。
		マッチが見つからなかったときは0または-1を返し、カーソルは移動
		しない。エラーメッセージは表示されない。

		{start}、{middle}、{end}は正規表現である。|pattern|を参照。こ
		の正規表現に \( \) のペアを含めてはならない。\%( \) は含めても
		よい。{middle}はネストしたstart・endペアの中にないときのみマッ
		チする。典型的な使用例: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		ここで{middle}を空にすると "else" をスキップするようになる。

		{flags}には|search()|と同様に 'b', 'c', 'n', 's', 'w', 'W' が
		使える。それに加えて以下のフラグが利用できる。
		'r'	それ以上マッチが見つからなくなるまで繰り返す。つまり最
			も外側のペアを探す。'W' も自動的にオンになる。
		'm'	マッチ位置の行番号でなくマッチの個数を返す。'r' を使っ
			ているときは > 1 となる。
		Note: ほとんど常に 'W' を使ってファイルの末尾で循環しないよう
		にするのがよい考えである。

		{start}、{middle}、{end}のマッチが見つかると、マッチの開始位置
		にカーソルを移動し、式{skip}を評価する。このマッチがコメントや
		文字列の内側にある場合など、無視したいものであれば式{skip}が
		非0を返すようにする。
		{skip}を省略した、または空のときはどのマッチも無視しない。
		{skip}を評価している最中にエラーが発生すると、検索は異常終了し
		-1を返す。

		{stopline} と {timeout} については|search()|を参照。

		'ignorecase' の値が適用される。'magic' の値は無視され、オンの
		ときと同じ様に動作する。

		検索はカーソル位置から開始する。検索方向の次の文字における
		{start}、{middle}、{end}のマッチが最初に見つかる。例: >
			if 1
			  if 2
			  endif 2
			endif 1
<		カーソルが "if 2" の "i" の上にある状態から下方に検索を開始す
		ると "endif 2" にマッチする。"if 2" の直前の文字の上から検索を
		開始すると "endif 1" にマッチする。これは、"if 2" が最初に見つ
		かり、"if 2" から "endif 2" までがネストしたペアと見なされるた
		めである。上方検索で、{end}が2文字以上であるときはパターンの最
		後に "\zs" をつけるとよいかもしれない。するとカーソルがendの
		マッチの内側にあるとき、対応するstartを見つけるようになる。

		例: Vimスクリプトの "endif" コマンドを見つけるには: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		これを使うには、マッチを見つけたい "if" の上、またはそれ以降に
		カーソルを置くこと。Note バックスラッシュを二重にしなくてもよ
		いようにシングルクォート文字列を使っている。式skipにより、コメ
		ントだけの行を無視するようにしている。コマンドの後のコメントは
		無視していない。また、行の途中の "en" や "if" という単語にマッ
		チしてしまう。
		もう1つの例: "}" に対応する "{" を検索する: >

	:echo searchpair('{', '', '}', 'bW')

<		これを使うには、マッチを見つけたい "}" の上、または前にカーソ
		ルを置くこと。構文ハイライトにより文字列と見なされるマッチを無
		視するには次のようにする: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
							*searchpairpos()*
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		|searchpair()|と同様だが、マッチの行番号と桁番号からなるリスト
		|List|を返す。このリストの最初の要素は行番号で、次の要素はマッ
		チの桁位置のバイトインデックスである。マッチが見つからなかった
		場合は[0, 0]を返す。 >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		より大規模で役に立つ例に関しては|match-parens|を参照。

searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
		|search()|と同様だが、マッチの行番号と桁番号からなるリスト
		|List|を返す。このリストの最初の要素は行番号で、次の要素はマッ
		チの桁位置のバイトインデックスである。マッチが見つからなかった
		場合は[0, 0]を返す。
		例: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		フラグ 'p' を指定すると、戻り値にサブパターンのマッチ番号を示
		す要素が加わる|search()-sub-match|。例: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		この例において、"submatch" は小文字|/\l|が見つかったとき2とな
		り、大文字|/\u|が見つかったとき3となる。

server2client( {clientid}, {string})			*server2client()*
		{clientid}に返信文字列を送る。最後に文字列を送った{clientid}は
		expand("<client>")で取得できる。
		{|+clientserver|機能付きでコンパイルしたときのみ利用可能}
		Note:
		このIDは次のコマンドを受け取る前に取得しなければならない。つま
		り、受け取ったコマンドから戻る前で、入力を待つコマンドを呼ぶ前。
		|clientserver|も参照。
		例: >
			:echo server2client(expand("<client>"), "HELLO")
<
serverlist()					*serverlist()*
		利用可能なサーバ名のリストを返す。1行に1つの形式。
		サーバが1つもないとき、または情報を取得できないときは空文字列
		を返す。|clientserver|も参照。
		{|+clientserver|機能付きでコンパイルしたときのみ利用可能}
		例: >
			:echo serverlist()
<
setbufvar({expr}, {varname}, {val})			*setbufvar()*
		バッファ{expr}のオプションまたはローカル変数{varname}に{val}を
		代入する。
		グローバル・ウィンドウローカルオプションに対しても動作するが、
		グローバル・ウィンドウローカル変数に対しては動作しない。
		ウィンドウローカルオプションの場合、グローバルな値は変更されな
		い。
		{expr}の解釈の仕方については|bufname()|を参照。
		Note 変数名には "b:" をつけてはならない。
		例: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		サンドボックスの中ではこの関数は使用できない。

setcmdpos({pos})					*setcmdpos()*
		コマンドラインの{pos}バイトの位置へカーソルを移動する。
		{pos}は1から始まる。
		現在の位置を取得するには|getcmdpos()|を使う。
		コマンドラインを編集している最中のみ機能する。よって、
		|c_CTRL-\_e|、|c_CTRL-R_=|、|c_CTRL-R_CTRL-R|＋ '=' と組み合
		わせて使うときだけ意味がある。|c_CTRL-\_e|と|c_CTRL-R_CTRL-R|
		＋ '=' の場合、コマンドラインにその式をセットした後でカーソル
		を移動する。|c_CTRL-R_=|の場合、式を評価した後、結果のテキスト
		を挿入する前にカーソルを移動する。
		{pos}が大きすぎるときは行末にカーソルを移動する。{pos}が1より
		小さいときの結果は未定義である。
		成功なら0、コマンドラインを編集しているとき以外には1を返す。

setline({lnum}, {text})					*setline()*
		カレントバッファの{lnum}行目を{text}にする。行を挿入したい場合
		は |append()| を使う。
		{lnum}は|getline()|のときと同じように解釈される。
		{lnum}が最後の行の次の行の場合、新規行として{text}を追加する。
		成功したら0を返す。失敗したら(大抵{lnum}が無効な値のとき)1を返
		す。例: >
			:call setline(5, strftime("%c"))
<		{text}がリスト|List|の場合、{lnum}行目とそれ以降の行にリストの
		要素をセットする。例: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		上の例は次と同値である: >
			:for [n, l] in [[5, 'aaa'], [6, 'bbb'], [7, 'ccc']]
			:  call setline(n, l)
			:endfor
<		Note: マーク '[ と '] はセットされない。

setloclist({nr}, {list} [, {action}])			*setloclist()*
		ウィンドウ{nr}のロケーションリストを作成・置き換え・追加する。
		{nr}が0のときはカレントウィンドウを対象にする。ロケーションリ
		ストウィンドウの場合、そこに表示しているロケーションリストが修
		正される。ウィンドウ番号{nr}が無効な場合、-1を返す。
		それ以外は|setqflist()|と同じ。
		|location-list| も参照。

setmatches({list})					*setmatches()*
		|getmatches()| で取得したマッチのリストを復元する。成功なら 
		0、失敗なら -1 を返す。リストを復元するに先立って、現在のマッ
		チはすべて消去される。|getmatches()| の例を参照。

							*setpos()*
setpos({expr}, {list})
		{expr}の位置を設定する。{expr}として有効な値は次の通り:
			.	カーソル位置
			'x	マーク x

		{list}は次の4個の要素を持つリスト|List|でなければならない:
		    [bufnum, lnum, col, off]

		"bufnum" はバッファ番号。0にするとカレントバッファを表す。カー
		ソル位置の設定はカレントバッファに対してのみ可能。他のバッファ
		のマークを設定するには、関数|bufnr()|を使ってファイル名をバッ
		ファ番号に変換する。
		ジャンプリストは変更されない。

		"lnum" と "col" はバッファ内の位置。桁番号は1から始まる。
		"lnum" を 0 にするとそのマークを削除する。"col" が 1 より小さ
		いときは 1 が使われる。

		数値 "off" は 'virtualedit' がオンのときのみ使われ、その文字の
		開始位置からの画面上の桁のオフセットとなる。例えば、<Tab>の中、
		または最後の文字より後に設定したいときに使う。

		位置をセットできたときは 0 を、そうでなければ -1 を返す。
		{expr} が無効なときはエラーメッセージが出る。

		|getpos()|も参照。

		縦方向に移動するときの望ましい桁を復元しない。それには
		|winrestview()|を参照。


setqflist({list} [, {action}])				*setqflist()*
		{list}の要素によりQuickFixリストを作成・置き換え・追加する。
		{list}の各要素は辞書であること。
		辞書でない{list}の要素は無視される。各辞書は以下の要素を
		持つ:

		    bufnr	バッファ番号。有効なバッファ番号でなければなら
				ない。
		    filename	ファイル名。"bufnr" がないとき、または無効であ
				るときのみ使われる。
		    lnum	ファイル中の行番号
		    pattern	エラーの位置を特定するための検索パターン
		    col		桁番号
		    vcol	0でない場合: "col" は表示上の桁
				0の場合: "col" はバイトインデックス
		    nr		エラー番号
		    text	エラーの説明
		    type	エラータイプを示す1文字。'E', 'W' など。

		辞書の要素 "col"、"vcol"、"nr"、"type"、"text" は省略可能であ
		る。"lnum" か "pattern" のどちらか一方のみがエラー行を特定する
		ために使われる。"filename" と "bufnr" の両方ともない場合、また
		は "lnum" と "pattern" の両方ともない場合、その要素はエラー行
		として扱われない。"pattern" と "lnum" の両方があるときは
		"pattern" が使われる。
		{list} に空のリストを指定すると QuickFix リストはクリアされ
		る。
		このリストは|getqflist()|が返すものと正確に同じではないことに
		注意。

		{action}が 'a' ならば{list}の要素を既存のQuickFixリストに追加
		する。QuickFixリストがまだ存在しない場合は新規に作成される。
		{action}が 'r' ならば{list}の要素で現在のQuickFixリストを置き
		換える。{action}が指定されないとき、または ' ' のときは新しい
		QuickFixリストを作成する。

		成功なら0、失敗なら-1を返す。

		この関数は 'errorformat' の設定とは無関係にQuickFixリストを作
		るために使える。その最初のエラーへジャンプするには ":cc 1" な
		どのコマンドを使う。


							*setreg()*
setreg({regname}, {value} [,{options}])
		レジスタ{regname}に{value}をセットする。
		{options}が "a" を含んでいるとき、または{regname}が大文字のと
		きは、その値に追加する。
		{options}は以下のレジスタの種類指定を含んでもよい:
		    "c" または "v"	      |characterwise| モード
		    "l" または "V"	      |linewise| モード
		    "b" または "<CTRL-V>"     |blockwise-visual| モード
		"b" または "<CTRL-V>" の直後に数値を続けると、それが選択範囲の
		幅となる。これを指定しない場合、選択範囲の幅は一番長い行の文字
		数となる(<Tab>は1文字と数えられる)。

		{options}にレジスタの設定が何も含まれていないとき、{value}が
		<NL>で終わっていない限り、デフォルトの文字指向モードが使われる。
		レジスタ '=' の値を設定することはできないが、これが使える: >
			:let @= = var_expr
<		成功なら0、失敗なら非0を返す。

		例: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')

<		次の例は、この関数を使ってレジスタを退避・復元する例である。 >
			:let var_a = getreg('a', 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)

<		空文字列を追加すると、レジスタの種類を変更することができる: >
			:call setreg('a', '', 'al')

settabvar({tabnr}, {varname}, {val})			*settabvar()*
		タブページ {tabnr} のタブローカル変数 {varname} を {val} に設
		定する。 |t:var|
		Note: 指定する変数名は "t:" を除いた名前。
		タブの番号は 1 から始まる。
		この関数はサンドボックス (|sandbox|) の中では使えない。

settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		ウィンドウ{winnr}のオプションやローカル変数{varname}の値を
		{val}にセットする。
		タブ番号は1から始まる。カレントタブページを対象とする場合は
		|setwinvar()|を使う。
		{winnr}が0のときはカレントウィンドウが対象となる。
		グローバルオプションやバッファローカルオプションを設定すること
		もできるが、グローバル変数やバッファローカル変数を設定すること
		はできない。
		バッファローカルオプションを設定した場合、グローバル値は変更さ
		れない。
		Note 変数名には "w:" をつけてはならない。
		例: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		この関数は|sandbox|の中では使用できない。

setwinvar({nr}, {varname}, {val})			*setwinvar()*
		|settabwinvar()|と同様。カレントタブページを対象とする。
		例: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")

sha256({string})						*sha256()*
		{string}のSHA256チェックサムを64文字の16進文字列で返す。
		{|+cryptv| 機能つきでコンパイルされたときのみ有効}

shellescape({string} [, {special}])			*shellescape()*
		シェルコマンドの引数として利用できるように{string}をエスケープ
		する。
		MS-WindowsとMS-DOSでは、'shellslash' が設定されていない場合、
		{string}をダブルクォートで囲み、{string}の中のダブルクォートを
		全て二重にする。
		他のシステムでは、{string}をシングルクォートで囲み、"'" を
		"'\''" で置き換える。
		{special} が指定され、0 でない数値または空でない文字列の場合
		(|non-zero-arg|)、"!", "%", "#", "<cword>" などの特殊なアイテ
		ムの前にはバックスラッシュがつく。コマンド |:!| によってその
		バックスラッシュは再び除かれる。
		'shell' の値の末尾が "csh" である場合、{special} が
		|non-zero-arg| ならば "!" の文字もエスケープされる。これは、
		cshと tcsh は シングルクォートの中であっても "!" を履歴置換と
		解釈するためである。
		<NL> 文字もエスケープされる。{special} が |non-zero-arg| であ
		り 'shell' の末尾が "csh" である場合、これは2回エスケープされ
		る。
		|:!| コマンドを使う場合の例: >
		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
<		これはカーソル下のファイルを dir コマンドで表示する。
		|system()| を使う場合の例: >
		    :call system("chmod +w -- " . shellescape(expand("%")))


shiftwidth()						*shiftwidth()*
		実際に使用される 'shiftwidth' の値を返す。'shiftwidth' がゼロ
		以外の場合はその値が返る。ゼロの場合は 'tabstop' の値が返る。
		インデントプラグインで後方互換性を保つには次のようにする: >
			if exists('*shiftwidth')
			  func s:sw()
			    return shiftwidth()
			  endfunc
			else
			  func s:sw()
			    return &sw
			  endfunc
			endif
<		そして、&sw の代わりに s:sw() を使う。


simplify({filename})					*simplify()*
		ファイル名を、意味を変えずにできるだけ簡略化する。MS-Windowsで
		のショートカットやUnixでのシンボリックリンクは解決される。
		{filename}の最初のパスコンポーネントがカレントディレクトリを指
		す場合、結果にそのまま残される。末尾のパス区切り文字も取り除か
		れない。
		例: >
			simplify("./dir/.././/file/") == "./file/"
<		Note: "dir/.." の組み合わせは、"dir" が検索可能なディレクトリ
		であるか、存在しないときのみ取り除かれる。Unixでは、"dir" が同
		じディレクトリ内にあるシンボリックリンクであるときも取り除かれ
		る。パス名を簡略化する前に全てのシンボリックリンクを解決させる
		には|resolve()|を使う。


sin({expr})						*sin()*
		{expr} の正弦(サイン)をラジアンで |Float| で返す。{expr} は
		|Float| または |Number| に評価されなければならない。
		例: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301
		{|+float| 機能つきでコンパイルされたときのみ有効}
		

sinh({expr})						*sinh()*
		{expr} の双曲線正弦 (ハイパボリックサイン) を返す。
		値は [-inf, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		例: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


sort({list} [, {func} [, {dict}]])			*sort()* *E702*
		{list}の要素をその場で(in-place)ソートする。{list}を返す。リス
		トを変更したくない場合は、最初にコピーを作っておくこと: >
			:let sortedlist = sort(copy(mylist))
<		ソートの際には、各要素の文字列表現を使う。
		数値は文字列より後になり、リストは数値より後になる。
		カレントバッファのテキストをソートするには|:sort|を使うこと。
		{func}に1を指定すると、大文字・小文字を区別しなくなる。
		{dict} は "dict" 属性付きの関数と一緒に使う。値はローカル変数
		"self" として使われる。 |Dictionary-function|
		{func}に|Funcref|または関数名を指定すると、その関数を使って要
		素を比較する。その関数は2つの要素を引数として受け取り、それら
		が等しいときは0、1番目の引数を2番目より後にするなら1以上、1番
		目の方を前にするなら-1以下を返す。例: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sortedlist = sort(mylist, "MyCompare")
<		この例の場合、より短く次のように書くことができる。ただしオーバー
		フローは無視される: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<
							*soundfold()*
soundfold({word})
		{word}と同値でsound-foldされた単語を返す。カレントウィンドウの
		'spelllang' で設定された言語のうち、soundfoldingに対応する最初
		の言語が使用される。'spell' がオンでなければならない。
		soundfoldingができない場合、{word}がそのまま返される。
		この関数はスペリング候補を作るために使われる。Note この方法は
		とても遅くなる可能性がある。

							*spellbadword()*
spellbadword([{sentence}])
		引数なしの場合: カーソル下またはカーソル以降のスペルミスした単
		語を返す。その単語の先頭へカーソルを移動する。カレント行にスペ
		ルミスした単語が見つからない場合は空文字列を返し、カーソルは移
		動しない。

		引数ありの場合: {sentence}の中のスペルミスしている最初の単語を
		返す。スペルミスしている単語がない場合は空文字列を返す。

		戻り値は、次の2個の要素を持つリスト:
		- スペルミスした単語または空文字列
		- スペルミスの種類:
			"bad"		スペルミス
			"rare"		頻度の低い単語
			"local"		他の地域でのみ有効な単語
			"caps"		大文字で始めるべき単語
		例: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		カレントウィンドウに対するスペリング情報が適用される。オプショ
		ン 'spell' がオンでなければならない。'spelllang' の値が使用さ
		れる。

							*spellsuggest()*
spellsuggest({word} [, {max} [, {capital}]])
		{word}の正しいスペルの候補のリストを返す。{max}を指定すると、
		候補の数の最大値となる。{max}を指定しないと、25個までの候補を
		返す。

		{capital}に0でない値を指定すると、先頭が大文字の候補だけを返す。
		これは 'spellcapcheck' とのマッチの後に使う。

		{word}はスペルの間違った単語で、後に他のテキストが続いてもよい。
		これにより、分割された2つの単語を連結することができる。候補も
		また続きのテキストを含んでいるので、これによって行を置き換える
		ことができる。

		{word}は正しい単語でもよい。すると似た単語が返ってくるだろう。
		{word}自身は候補に含まれないが、大文字化されたものが含まれてい
		ることはある。

		カレントウィンドウのスペリング情報が使われる。オプション
		'spell' がオンでなければならず、'spelllang' と 'spellsuggest'
		の値が適用される。


split({expr} [, {pattern} [, {keepempty}]])			*split()*
		{expr}を分割して|List|にする。{pattern}を省略した場合、または
		{pattern}が空文字列の場合は、{expr}を空白文字で区切った各文字
		列が要素となる。
		{pattern}を指定すると、{pattern}がマッチする位置で文字列を分割
		する。マッチした文字列は削除される。'ignorecase' はここでは適
		用されないので大文字小文字を無視するには \c を使う。 |/\c|
		{keepempty}に非0を指定しない限り、最初または最後の要素が空文字
		列ならばリストから取り除かれる。
		それ以外の空文字列は、{pattern}が1文字以上にマッチすれば、また
		は{keepempty}が非0ならばそのままリストの要素となる。
		例: >
			:let words = split(getline('.'), '\W\+')
<		文字列を各文字に分割するには: >
			:for c in split(mystring, '\zs')
<		区切り文字を削除せず、そのままにしておきたい場合は、'\zs' を
		使えばよい: >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		最初の要素が空であるかもしれないテーブルを分割するには: >
			:let items = split(line, ':', 1)
<		これの逆を行う関数は|join()|である。


sqrt({expr})						*sqrt()*
		浮動小数点数 {expr} の非負平方根を |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならな
		い。{expr} が負の場合、結果は NaN (Not a Number) になる。
		例: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
		"nan" はシステムのライブラリに依存するので、異なるかもしれな
		い。
		{|+float| 機能つきでコンパイルされたときのみ有効}
		

str2float( {expr})					*str2float()*
		文字列 {expr} を浮動小数点数に変換する。これは式の中で浮動小数
		点数を使っているときと同じように働く (|floating-point-format|
		を参照)。しかしこちらの方がゆるやかである。例えばこちらでは
		"1e40" も許されるが、式の中では "1.0e+40" と書かなければならな
		い。
		数値の後ろにある文字列は黙って無視される。
		小数点数はロケールの設定に関わらず常に '.' である。コンマを発
		見すると、そこで数値は終わりになる。つまり "12,345.67" は 12.0
		に変換される。3桁ごとのカンマ区切りを取り除くには
		   |substitute()| が使える: >
			let f = str2float(substitute(text, ',', '', 'g'))
<		{|+float| 機能つきでコンパイルされたときのみ有効}

str2nr( {expr} [, {base}])				*str2nr()*
		文字列{expr}を数値に変換する。
		{base}は変換の底。8、10、16のいずれか。
		{base}を省略すると10となる。そのため、文字列の先頭に0があると
		き、デフォルトの文字列・数値変換とは異なり、8進数とは解釈され
		ない。
		{base}が16のとき、文字列の先頭の "0x" と "0X" は無視される。そ
		れ以外の底の場合は0となる。
		数値の後のテキストは暗黙に無視される。

strchars({expr})					*strchars()*
		文字列 {expr} 内の文字の数を返す。合成文字は別々にカウントされ
		る。
		|strlen()|, |strdisplaywidth()|, |strwidth()| も参照。

strdisplaywidth({expr}[, {col}])			*strdisplaywidth()*
		文字列 {expr} のスクリーン上での表示セル幅を返す。
		{col} が省略されたときはゼロが使われる。{col} には計算を開始す
		るスクリーン上の列の位置を指定する。これはタブ文字の幅の計算に
		影響する。
		計算にはカレントウィンドウのオプションが使用される。'tabstop'
		や 'display' のような表示を変更するようなオプションが影響す
		る。
		{expr} に幅が曖昧 (Ambiguous) な東アジアの文字が含まれていると
		きは、文字幅は 'ambiwidth' の設定に依存する。
		|strlen()|, |strwidth()|, |strchars()| も参照。

							*strftime()*
strftime({format} [, {time}])
		結果は文字列で、{format}に従って日付や時間がフォーマットされた
		ものになる。{time}が与えられた場合にはそれを使うが、省略された
		場合には現在時刻を使用する。受け付け可能な文字列{format}は使用
		するシステムに依存するので、ポータブルとは言えない。フォーマッ
		トについてはCの関数strftime()のマニュアルを参照。結果は最大80
		文字に制限される。|localtime()|と|getftime()|も参照。
		ここで使われる言語はコマンド|:language|で変更できる。
		例: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   file.cの更新時刻を表示
<		この関数はどのシステムでも利用できるとは限らない。利用できるか
		チェックするには次のようにする: >
			:if exists("*strftime")

stridx({haystack}, {needle} [, {start}])		*stridx()*
		結果は数値で、{heystack}の中で文字列{needle}が最初に現れる位置
		のバイトインデックスを表す。{start}を指定すると、インデックス
		{start}の位置から検索を開始する。
		2番目のマッチを探すには次のようにする: >
			:let colon1 = stridx(line, ":")
			:let colon2 = stridx(line, ":", colon1 + 1)
<		検索は大文字・小文字を区別する。
		検索パターンについては|match()|を使う。
		{haystack}の中に{needle}がないときは-1を返す。
		|strridx()|も参照。
		例: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<						*strstr()* *strchr()*
		stridx()はCの関数strstr()と同じように動作する。{needle}が1文字
		のときはstrchr()と同じように動作する。

							*string()*
string({expr})	{expr}を文字列に変換して返す。{expr}が数値、浮動小数点数、文字
		列、それらの複合の場合は、この戻り値を|eval()|でパースして復元
		できる。
			{expr} 型	結果 ~
			文字列		'string'
			数値		123
			浮動小数点数	123.123456 or 1.123456e8
			Funcref		function('name')
			リスト		[item, item]
			辞書		{key: value, key: value}
		Note 文字列中のシングルクォート(')は二重化される。
		|strtrans()|も参照。

							*strlen()*
strlen({expr})	結果は数値で、文字列{expr}の長さ。
		マルチバイト文字の個数を数えるには次のようなことをする(合成文
		字は数えない): >

			:let len = strlen(substitute(str, ".", "x", "g"))
<
		引数が数値の場合は、まず文字列に変換される。
		それ以外の型の場合はエラーとなる。
		|len()|, |strchars()|, |strdisplaywidth()|, |strwidth()| も参
		照。


							*strpart()*
strpart({src}, {start}, {len})
		結果は文字列で、{src}の{start}番目の文字から始まる、長さ{len}
		の部分文字列。存在しない文字を含むように範囲を指定しても、エ
		ラーにはならない。単に文字が省略されるだけである。
		{len}を省略すると、{start}から{src}の末尾までの部分文字列を返
		す。 >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)       == "defg"
<		Note: 文字列の最初の文字を指定するためには、{start}は0でなけれ
		ばならない。カーソルのある位置から3文字を取得する例: >
			strpart(getline("."), col(".") - 1, 3)
<
strridx({haystack}, {needle} [, {start}])			*strridx()*
		結果は数値で、{haystack}の中で文字列{needle}が最後に現れる位置
		のバイトインデックスとなる。
		{start}を指定すると、そのインデックス以降でのマッチは無視され
		る。前のマッチより前にあるものを見つけるには次のようにする: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		検索は大文字・小文字を区別する。
		検索パターンについては|match()|を使う。
		{haystack}の中に{needle}がないときは-1を返す。
		{needle}が空文字列のときは{haystack}の長さを返す。
		|stridx()|も参照。例: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		{needle}が1文字の場合はCの関数strrchr()と同じように動作する。

							*strtrans()*
strtrans({expr})
		結果は文字列で、{expr}内の表示不可能な文字を|'isprint'|で指定
		される、表示可能な文字に変換したもの。ウィンドウに表示すること
		ができるようになる。例: >
			echo strtrans(@a)
<		これはレジスタの中の改行を、改行として表示する代わりに "^@" と
		表示する。

strwidth({expr})					*strwidth()*
		文字列 {expr} のスクリーン上での表示セル幅を返す。タブ文字の幅
		は 1 として数えられる (タブ文字の幅も考慮したい場合は
		|strdisplaywidth()| を使うこと)。
		{expr} に幅が曖昧 (Ambiguous) な東アジアの文字が含まれていると
		きは、文字幅は 'ambiwidth' の設定に依存する。
		|strlen()|, |strdisplaywidth()|, |strchars()| も参照。

submatch({nr})						*submatch()*
		|:substitute| や substitute() 関数の中の式でのみ使われる。
		マッチしたテキストの{nr} 番目の部分マッチを返す。{nr}が0のとき
		はマッチしたテキスト全体を返す。
		|sub-replace-expression| も参照。
		例: >
			:s/\d\+/\=submatch(0) + 1/
<		この例は、行の中で最初の数値を検索し、それに1を加える。改行は
		改行文字として含まれる。

							*substitute()*
substitute({expr}, {pat}, {sub}, {flags})
		結果は文字列で、{expr}内で最初に{pat}にマッチした部分を{sub}に
		置換えたコピーになる。
		{flags} が "g" なら、{expr} 内の {pat} にマッチした部分をすべ
		て置換する。そうしたくない場合は {flags} は "" にすべきであ
		る。

		これはコマンド ":substitute" (一切のフラグ無し) のように働く。
		しかしマッチングは常にオプション 'magic' が設定され、オプショ
		ン 'cpoptions' は空にして実行される(スクリプトをポータブルにす
		るため)。'ignorecase' は適用される。'ignorecase' の設定に関わ
		らず大文字小文字を区別するかしないか固定するには |/\c| か
		|/\C| を使う。 'smartcase' は適用されない。{pat}がどう扱われる
		かについては|string-match|を参照。

		また、{sub}内の "~" は前回の{sub}に置換されない。
		{sub}内の幾つかのコードには|sub-replace-special|の特殊な意味
		があることに注意。例えば、何かの文字列をリテラルの "\n" に置換
		えるためには、"\\\\n" か '\\n' を使う必要がある。

		{pat}が{expr}の何処にもマッチしなければ、{expr}が何の変更も受
		けずに返される。

		例: >
			:let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		これはオプション 'path' の最後のコンポーネントを削除する。 >
			:echo substitute("testing", ".*", "\\U\\0", "")
<		結果は "TESTING" となる。

		{sub} が "\=" で開始している場合は、その後ろの文字列は式として
		解釈される。|sub-replace-expression| 参照。例: >
			:echo substitute(s, '%\(\x\x\)',
			   \ '\=nr2char("0x" . submatch(1))', 'g')

synID({lnum}, {col}, {trans})				*synID()*
		結果は数値で、現在のウィンドウ内での位置{lnum}と{col}の位置の
		構文ID。
		構文IDは|synIDattr()|と|synIDtrans()|に渡すことで、テキストに
		ついての構文情報を取得するのに使用できる。
		
		最左のカラムを指定するには{col}に1を、最初の行を指定するには
		{line}に1を指定する。'synmaxcol' が適用され、長すぎる行では0が
		返ってくる。

		{trans}が非ゼロならば、透過属性のアイテムは省略され、実際に表
		示されているアイテムが評価対象になる。これは実際に有効になって
		いるカラーを知りたい時に役に立つ。{trans}がゼロならば、透過属
		性のアイテムが返される。これはどの構文アイテムが有効になってい
		るかを知りたい時に役に立つ(例:カッコの中とか)。
		警告: この関数は非常に遅い。ファイルを順方向に走査する時にだけ
		ベストなスピードが得られる。

		例(カーソルの下の構文アイテムの名前を表示する): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<

							*synIDattr()*
synIDattr({synID}, {what} [, {mode}])
		結果は文字列で、{synID}の属性{what}の内容を示す。これは構文
		アイテムの情報を取得するのに使用できる。
		{mode}には取得したいモードの属性に応じて、"gui" か "cterm" か
		"term" が指定できる。{mode}が省略されるか、無効な値が指定され
		た場合、現在有効になっているハイライトモードが使用される (GUI、
		cterm、termのどれか)。
		ハイライトグループにリンクされた属性を取得するにはsynIDtrans()
		を使用する。
		{what}		結果
		"name"		構文アイテムの名前
		"fg"		前景色(GUI:カラー名、cterm:文字列としてのカ
				ラー番号、term空文字列)
		"bg"		背景色("fg" 同様)
		"font"		フォント名 (GUI でのみ利用可)
				|highlight-font|
		"sp"		特殊な色 ("fg" 同様) |highlight-guisp|
		"fg#"		"fg" 同様だが、"#RRGGBB" のフォーマットで
		"bg#"		"bg" 同様だが、"#RRGGBB" のフォーマットで
		"sp#"		"sp" 同様だが、"#RRGGBB" のフォーマットで
		"bold"		太字なら "1"
		"italic"	斜体なら "1"
		"reverse"	反転なら "1"
		"inverse"	反転(原文inverse)なら "1" (reverseと等価)
		"standout"	強調 (standout) なら "1"
		"underline"	下線付きなら "1"
		"undercurl"	波線付きなら "1"

		例(カーソルの下の構文アイテムの名前を表示する): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<
							*synIDtrans()*
synIDtrans({synID})
		結果は数値で、{synID}を構文IDに変換したもの。キャラク
		タをハイライト表示している構文グループのIDである。
		":highlight link" によって与えられるハイライトのリンクはこれに
		従っている。

synconcealed({lnum}, {col})				*synconcealed()*
		リストを返す。リストの 1 番目のアイテムは、{lnum} と {col} が
		指す位置の文字が Conceal 可能リージョン の中にあるなら 1、そう
		でないなら 0。リストの 2 番目のアイテムは文字列で、最初のアイ
		テムが 1 なら、代わりに表示される Conceal テキスト が入る (実
		行時の 'conceallevel' の設定に依存)。リストの 3 番目のアイテム
		は、どのシンタックスリージョンにマッチしたかを示すユニーク番
		号。これは同じ置換文字を持つ二つのリージョンが連続していた場合
		にその区切りを識別できるようにするため。
		使用例は $VIMRUNTIME/syntax/2html.vim を参照。


synstack({lnum}, {col})					*synstack()*
		カレントウィンドウの {lnum}, {col} の位置の構文アイテムのス
		タックを |List| にして返す。このリストの要素は |synID()|が
		返すのと同じ種類の ID である。
		リストの最初の要素が一番外側の領域で、続く要素がその中に内包さ
		れている。アイテム全体がハイライトされている、または最後の要素
		が transparent なアイテムである場合を除き、最後の要素が
		|synID()| が返すものである。
		この関数は構文ファイルをデバッグするのに役に立つ。
		例(カーソル下の構文スタックを表示する): >
			for id in synstack(line("."), col("."))
			   echo synIDattr(id, "name")
			endfor
<		{lnum} と {col} が不正な場所を指しているときは返り値なし。行の
		最後の文字の一つ後ろと空行の一番目の列は有効な位置である。

system({expr} [, {input}])				*system()* *E677*
		シェルコマンド{expr}の実行結果を得る。
		{input}が与えられた場合は、この文字列はファイルに書き出され、
		コマンドの標準入力として渡される。この文字列はそのまま(as-is)
		書き出され、正しい改行文字を使うよう自分自身で気を付けなければ
		ならない。パイプは使われない。
		Note: |shellescape()| を使ってコマンドの引数をエスケープするこ
		と。{expr}内に改行が含まれるとコマンドが失敗する可能性がある。
		'shellquote' と 'shellxquote' に入っている文字は問題を引き起こ
		すかもしれない。
		対話的なコマンドを使用することはできない。
		戻り値は文字列。例: >
		    :let files = system("ls " .  shellescape(expand('%:h')))

<		システムに依存しないような戻り値にするために、シェルの出力を
		フィルタリングし、マッキントッシュにおいては<CR>を<NL>に変換
		し、DOS系のシステムにおいては<CR><NL>を<NL>に変換している。
		実行されるコマンドはいくつかのオプションを適用して構成される:
	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
		({tmp}は自動的に生成されるファイル名)
		UnixとOS/2ではコマンドの連結ができるように{expr}の両側に波括弧
		が置かれる。

		コマンドは「coocked」モードで実行される。そのためCTRL-Cでコマ
		ンドを中断できる(少なくともUnixでは)。

		エラーコードは|v:shell_error|に格納される。
		この関数は|restricted-mode|では失敗する。

		Note 上記のオプションに不正な値が入っていると、この関数の呼び
		出しが失敗する可能性がある。セキュリティエージェントアプリケー
		ションを使っていると失敗することがあるとも報告されている。
		":!cmd" とは違い、ファイルが変更されているかのチェックは行わな
		い。
		明示的にチェックさせるには|:checktime|を使う。

tabpagebuflist([{arg}])					*tabpagebuflist()*
		カレントタブページ内の各ウィンドウに表示されているバッファの番
		号を要素とするリスト|List|を返す。{arg}は対象とするタブページ
		の番号を指定する。省略したときはカレントタブページを対象とする。
		{arg}が無効なときは数値0を返す。
		全タブページ中の全バッファのリストを得るには次のようにする: >
			let buflist = []
			for i in range(tabpagenr('$'))
			   call extend(buflist, tabpagebuflist(i + 1))
			endfor
<		1つのバッファが複数のウィンドウに表示されている場合があること
		に注意。


tabpagenr([{arg}])					*tabpagenr()*
		結果は数値で、カレントタブページの番号。最初のタブページの番号
		は1となる。
		省略可能な引数{arg}に指定できる値は "$" のみであり、最後のタブ
		ページの番号(つまりタブページの個数)を返す。
		この番号はコマンド|:tab|で指定できるものと同じである。


tabpagewinnr({tabarg}, [{arg}])				*tabpagewinnr()*
		|winnr()|と同様だが、タブページ{tabarg}を対象とする。
		{tabarg}は対象とするタブページの番号を指定する。
		{arg}は|winnr()|の場合と同じように扱われる。すなわち:
		- 省略するとカレントウィンドウの番号を返す。これは、このタブペー
		  ジに入るとき使われるウィンドウである。
		- "$" とするとウィンドウ番号を返す。
		- "#" とすると前のウィンドウ番号を返す。
		役に立つ例: >
		    tabpagewinnr(1)	    " タブぺージ1のカレントウィンドウ
		    tabpagewinnr(4, '$')    " タブページ4内のウィンドウの個数
<		{tabarg}が無効なときは0を返す。

							*tagfiles()*
tagfiles()	カレントバッファにおいて、タグを検索するときに使うファイルの名
		前からなるリスト|List|を返す。オプション 'tags' を展開したもので
		ある。


taglist({expr})							*taglist()*
		正規表現{expr}にマッチするタグのリストを返す。そのリストの各要
		素は辞書であり、少なくとも次の要素を持つ:
			name		タグの名前。
			filename	タグの定義があるファイルの名前。カレン
					トディレクトリからの相対パス、またはフ
					ルパスである。
			cmd		そのファイルの中でタグの位置を特定する
					ために使うexコマンド。
			kind		タグの種類。種類は言語に依存する。この
					要素は、Exuberant ctagsかhdrtagによって
					生成されたタグファイルを使っているとき
					のみ使用できる。
			static		ファイル固有のタグ。より詳しくは
					|static-tag|を参照。
		タグファイルの内容によってはこれ以上の要素が存在することもある。
		例: アクセス、実装、継承、シグネチャ。これらのフィールドについ
		ての情報はctagsのドキュメントを参照。Cのソースにおいては、
		フィールド "struct"、"class"、"enum" が現れることがある。これ
		らは、タグを含んでいるものの名前を示す。

		exコマンド 'cmd' は検索パターンか、行番号か、行番号とバイト番
		号のいずれかである。

		マッチするタグがない場合は空リストを返す。

		完全一致するタグを取得するには、{expr}にアンカー '^' と '$' を
		つけること。これは関数の動作を速くすることにもなる。タグ検索の
		正規表現についてより詳しいことは |tag-regexp|を参照。

		Vimが使用するタグファイルについては |'tags'| を参照。様々な
		ctagsによって生成されるタグファイルのフォーマットについては
		|tags-file-format|を参照。

						*tempname()* *temp-file-name*
tempname()
		結果は文字列で、存在しないファイルのファイル名を示す。これはテ
		ンポラリファイルの名前として使用可能である。少なくとも連続26回
		の呼出しまでは違う名前を生成することが保証される。例: >
			:let tmpfile = tempname()
			:exe "redir > " . tmpfile
<		Unix では、ファイルはプライベートなディレクトリに置かれる。
		|tempfile|
		MS-Windowsでは、'shellslash' がオンのときか 'shellcmdflag' が
		'-' で始まるときはスラッシュが使われる。


tan({expr})						*tan()*
		{expr} の正接 (タンジェント) をラジアンで返す。
		値は [-inf, inf] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		例: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


tanh({expr})						*tanh()*
		{expr} の双曲線正接 (ハイパボリックタンジェント) を返す。
		値は [-1, 1] の範囲の浮動小数点数 (|Float|)。
		{expr} は浮動小数点数 (|Float|) か数値 (|Number|) でなければな
		らない。
		例: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594
		{|+float| 機能を有効にしてコンパイルしたときのみ有効}


tolower({expr})						*tolower()*
		引数の文字列の大文字を小文字に変換してできた文字列を返す(文字
		列に|gu|を適用するのとちょうど同じ)。

toupper({expr})						*toupper()*
		引数の文字列の小文字を大文字に変換してできた文字列を返す(文字
		列に|gU|を適用するのとちょうど同じ)。

tr({src}, {fromstr}, {tostr})				*tr()*
		文字列{src}の中で、{fromstr}に含まれる全ての文字を{tostr}の対
		応する文字で置き換えた文字列を返す。つまり、{fromstr}の最初の
		文字が{tostr}の最初の文字に置き換えられる。2文字目以降も同様。
		Unixのコマンド "tr" とちょうど同じである。
		マルチバイト文字も正しく扱える。

		例: >
			echo tr("hello there", "ht", "HT")
<		戻り値は "Hello THere" となる。 >
			echo tr("<blob>", "<>", "{}")
<		戻り値は "{blob}" となる。

trunc({expr})							*trunc()*
		{expr} をゼロ方向に切りつめた整数を |Float| で返す。
		{expr} は |Float| または |Number| に評価されなければならない。
		例: >
		Examples: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0
		{|+float| 機能つきでコンパイルされたときのみ有効}
		
							*type()*
type({expr})	{expr}の型を示す数値を返す:
			数値:	      0
			文字列:	      1
			Funcref:      2
			リスト:	      3
			辞書:	      4
			浮動小数点数: 5
		マジックナンバーを使わずに、次のような使い方をすべきである: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)

undofile({name})					*undofile()*
		{name} という名前のファイルの保存時に使用されるアンドゥファイ
		ルの名前を返す。'undodir' オプションが使用され、存在するディレ
		クトリが検索される。アンドゥファイルが存在するかどうかはチェッ
		クされない。
		{name} は常に絶対パスに展開される (内部では絶対パスを使ってい
		るため)。
		{name} が空の場合 undofile() は空文字列を返す。ファイル名のな
		いバッファはアンドゥファイルを書かないからである。
		|:wundo| や |:rundo| と組み合わせて使うと便利だろう。
		+persistent_undo オプションを無効にしてコンパイルされた場合は
		この関数は常に空文字列を返す。

undotree()						*undotree()*
		アンドゥツリーの現在の状態を辞書で返す。辞書の内容は次のとお
		り:
		  "seq_last"	使用されたアンドゥシーケンス番号の最大値。
		  "seq_cur"	アンドゥツリーの現在のシーケンス番号。いくつか
				の変更がアンドゥされた状態だと "seq_last" と違
				う値になる。
		  "time_cur"	最後に |:earlier| 系のコマンドが使われた時間。
				読みやすい形式に変換するには |strftime()| を使
				う。
		  "save_last"	最後にファイルが保存された番号。保存がまだなら
				ゼロになる。
		  "save_cur"	アンドゥツリー内の現在位置の番号。
		  "synced"	最後のアンドゥブロックが同期されていれば非ゼ
				ロ。これはユーザーからの入力を待機しているとき
				に起こる。|undo-blocks| 参照。
		  "entries"	アンドゥブロックの情報を表す辞書のリスト。

		"entries" リストの 1 番目にはもっとも古いアンドゥアイテムが
		入っている。リストの各アイテムは次のような情報を持った辞書であ
		る:
		  "seq"		アンドゥシーケンス番号。|:undolist| で表示され
				るものと同じ。
		  "time"	変更が起こった時間。読みやすい形式に変換するに
				は |strftime()| を使う。
		  "newhead"	この項目は最後に追加されたアイテムにのみある。
				これは最後の変更を示し、次の変更を追加する場所
				を示す。
		  "curhead"	この項目は最後にアンドゥされたアイテムにのみあ
				る。これはアンドゥツリーの現在位置を示し、次に
				リドゥコマンドによって使われるブロックを示す。
				最後に変更を加えてからアンドゥを一度も実行して
				いないときはこの項目はどこにも現れない。
		  "save"	この項目はファイルが保存される前の最後のブロッ
				クにのみある。番号は保存回数を示す。最初の保存
				は 1 で、最後のものは "save_last" と同じ。
		  "alt"		切り替えエントリ。同じアンドゥブロックのリスト
				が入れ子にされている。それぞれのアイテムはさら
				に "alt" アイテムを持っていることがある。

values({dict})						*values()*
		{dict}の全ての値からなるリスト|List|を返す。このリストの順序は
		不定である。

virtcol({expr})						*virtcol()*
		結果は数値で、{expr}で与えられるファイルの位置の、スクリーン上
		での桁の位置を示す。返る値は、指定された位置にある文字の末尾が、
		スクリーン座標(の桁)でどこに存在するかである。<Tab>(タブ文字)
		が指定した位置にあった場合には、戻り値はそのタブの最後のカラム
		(桁)位置になる。具体的に、'ts' が8に設定された状態で第1桁に
		<Tab>があった場合、戻り値は8になる。|conceal| は無視される。
		バイト位置については |col()| を使う。
		{expr}の解釈の仕方については|col()|を参照。
		'virtualedit' がオンのときは[lnum, col, off]というリストを指定
		することもできる。"off" は文字の開始位置からのスクリーン座標で
		のオフセットである。例えば、<Tab>の中の位置や、行の最後の文字
		以降の位置を示すために使う。"off" が省略された場合はゼロが使わ
		れる。
		現在のモードに対して仮想編集がオンのときは、行末を越えた位置が
		返ってくることもある。|'virtualedit'|
		可能な位置指定:
		    .	    カーソルの位置
		    $	    カーソル行の末尾(カーソル行に表示されている文字数
			    +1となる)
		    'x	    マークxの位置(マークが設定されていない場合、0が返
			    る)
		現在のファイルに対して設定されているマークだけが使用可能なこと
		に注意。
		例: >
  virtcol(".")	   "foo^Lbar" の "^L" の位置にカーソル、戻り値5
  virtcol("$")	   "foo^Lbar" に対し、戻り値9
  virtcol("'t")    "    there" の 'h' に 't を設定、戻り値6
<		最初の桁は1となる。エラーの場合は0が返る。
		より高度な例(全ての行の長さの最大値を返す): >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))

visualmode([expr])						*visualmode()*
		結果は文字列で、カレントバッファ内で最後に使われたビジュアルモー
		ドを教えてくれる。初期状態では単に空文字列を返すだけだが、一度
		でもビジュアルモードが使われた場合、その種類によって "v" か
		"V" か "<CTRL-V>" (CTRL-Vの文字が1文字で) 返される。これはそれ
		ぞれ文字選択、行選択、ブロック選択を意味している。
		例: >
			exe "normal " . visualmode()
<		これは最後に使われたのと同じビジュアルモードに入る。また、スク
		リプトの動作を、最後に使われたビジュアルモードに応じて変更した
		い場合にも便利だろう。
		ビジュアルモードにいるときは |mode()| を使ってビジュアルモード
		の種類を取得できる。(|:vmap| などの中などで)

							*non-zero-arg*
		{expr}に0以外の数値か空文字列以外の文字列を指定した場合は、ビ
		ジュアルモードがクリアされ、以前の値を返す。Note " " と "0" は
		空文字列ではないことに注意。よってモードがクリアされる。リス
		ト、辞書、浮動小数点数は数値でも文字列でもないのでモードはクリ
		アされない。

wildmenumode()					*wildmenumode()*
		wildmenuが有効な場合は0以外を返し、そうでなければ0を返す。
		'wildmenu' と 'wildmode' を参照。
		マッピングの中で 'wildcharm' オプションを有効に扱うために使用
		できる。(|mapmode-c|マッピングの場合のみ意味をなす。)

		例えば、wildmodeで<c-j>が<down>と同じように動作するようにする
		には: >
    :cnoremap <expr> <C-j> wildmenumode() ? "\<Down>\<Tab>" : "\<c-j>"
<
		(Note 'wildcharm' オプションが適切に設定されている必要がある。)


							*winbufnr()*
winbufnr({nr})	結果は数値で、{nr}番目のウィンドウに関連付けられているバッファ
		の番号。{nr}が0の場合、現在のウィンドウに関連付けられている
		バッファの番号が返る。{nr}で存在しないウィンドウを指定した場合
		には-1が返る。
		例: >
  :echo "The file in the current window is " . bufname(winbufnr(0))
<
							*wincol()*
wincol()	結果は数値で、ウィンドウの中でカーソルがある位置の仮想桁番号を
		表す。これはウィンドウの左側から数えたスクリーン上の桁である。
		一番左の桁は1となる。

winheight({nr})						*winheight()*
		結果は数値で、{nr}で示されるウィンドウの高さ(行数)を示す。{nr}
		が0ならば、現在のウィンドウの高さが返る。{nr}というウィンドウ
		が存在しない場合、-1が返る。存在しているウィンドウは、絶対に0
		かそれ以上の高さを持っている。
		例: >
  :echo "The current window has " . winheight(0) . " lines."
<

							*winline()*
winline()	結果は数値で、ウィンドウの最上行から数えた行番号を返す。ウィン
		ドウでの最上行が1となる。
		カーソルが移動するとファイルの表示が更新され、それによってスク
		ロールが引き起こされることがある。

							*winnr()*
winnr([{arg}])	結果は現在のウィンドウを示す数値。最上位のウィンドウは1であ
		る。
		省略可能な引数{arg}に "$" を設定すると、最後のウィンドウの番号
		が返る (つまりウィンドウの個数)。 >
			let window_count = winnr('$')
<		{arg}に "#" を設定すると、最後にアクセスしたウィンドウの番号を
		返す (|CTRL-W_p|で移動するウィンドウと同じ)。
		以前のウィンドウがない場合、またはそれが他のタブページにある場
		合は0を返す。
		この番号は|CTRL-W_w|と ":wincmd w" で使える。|:wincmd|
		|tabpagewinnr()|も参照。

							*winrestcmd()*
winrestcmd()	現在のウィンドウサイズを復元するための一連の|:resize|コマンド
		を返す。これが返すコマンドは、ウィンドウを開閉せず、カレントウィ
		ンドウとカレントタブページが変更されていないときのみ正しく動作
		する。
		例: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
winrestview({dict})
		|winsaveview()|が返す辞書|Dictionary|を使ってカレントウィンド
		ウの表示状態を復元する。
		この値を手動で変更した場合、結果は予測できない。
		ウィンドウサイズが変更されていると、結果は必ずしも元通りになら
		ない。

							*winsaveview()*
winsaveview()	カレントウィンドウの表示状態を復元するための情報を持つ辞書
		|Dictionary|を返す。この表示状態を復元するには|winrestview()|
		を使う。
		マッピング内でジャンプして、元の表示状態を戻したいときに使われ
		る。
		折り畳み情報は保存しない。オプション 'foldenable' によって一時
		的に折り畳みをオフにし、移動中に折り畳みが開かれないようにする
		こと。
		戻り値は以下のキーを持つ:
			lnum		カーソルの行番号
			col		カーソルの桁番号
			coladd		カーソル位置の桁オフセット。
					'virtualedit' がオンのとき使われる。
			curswant	垂直移動するときの桁
			topline		ウィンドウの最上行
			topfill		削除行。差分モードでのみ
			leftcol		表示されている最初の桁
			skipcol		スキップされている桁
		Note オプションの値は保存されない。


winwidth({nr})						*winwidth()*
		結果は数値で、ウィンドウ{nr}の幅。{nr}が0のときはカレントウィ
		ンドウの幅を返す。ウィンドウ{nr}が存在しないときは-1を返す。
		ウィンドウは必ず0以上の幅を持つ。
		例: >
  :echo "The current window has " . winwidth(0) . " columns."
  :if winwidth(0) <= 50
  :  exe "normal 50\<C-W>|"
  :endif
<
							*writefile()*
writefile({list}, {fname} [, {binary}])
		|List| {list}をファイル{fname}に書き込む。リストの各要素は改行
		文字(NL)で区切られる。各要素は文字列か数値でなければならない。
		{binary}が "b" のときはバイナリモードとなり、最後の要素の後に
		NLが追加されない。最後の要素が空であると、ファイルの最後の行が
		NLで終わるようになる。
		NL文字はNUL文字に置換される。
		CR文字を加えるには、{list}をwritefile()に渡す前に行わねばなら
		ない。
		既存のファイルは上書きされる(上書き可能ならば)。
		書き込みが失敗したときは-1を返す。そうでなければ0を返す。ファ
		イルを作成できないときや、書き込みが失敗したときはエラーメッ
		セージが表示される。
		|readfile()|も参照。
		バイト単位でファイルをコピーするには次のようにする: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")


xor({expr}, {expr})					*xor()*
		二つの引数のビット排他的論理和。引数は数値に変換される。リス
		ト、辞書、浮動小数点数を指定するとエラーになる。
		例: >
			:let bits = xor(bits, 0x80)
<

							*feature-list*
機能は大別して3つの系統に分けられる:
1.  コンパイル時に|+feature-list|とした時にだけサポートされる機能。例: >
		:if has("cindent")
2.  ある状態の時にだけサポートされる機能。例: >
		:if has("gui_running")
<							*has-patch*
3.  適用済みパッチ。最初に|v:version|によってVimのバージョンを確認する。
    機能 "patch123" はパッチ123が適用されていることを示す。例 (バージョン
    6.2.148以降であることを確認する): >
	:if v:version > 602 || v:version == 602 && has("patch148")
<   Note 148が適用されていても、147が抜けていることもありうるので注意。

all_builtin_terms	全ての組込みターミナルを有効にしてコンパイル
amiga			AMIGAバージョン
arabic			アラビア語をサポート |Arabic|
arp			ARPをサポート (Amiga)
autocmd			オートコマンドをサポート |autocommand|
balloon_eval		|balloon-eval| をサポート
balloon_multiline	複数行バルーンをサポート
beos			BeOSバージョン
browse			|:browse|をサポートし、browseが恐らく動作する
browsefilter		|browsefilter| をサポート
builtin_terms		幾つかの組込みターミナルが有効
byte_offset		'statusline' において 'o' がサポートされる
cindent			'cindent' をサポート
clientserver		リモート呼び出しをサポート |clientserver|
clipboard		'clipboard' をサポート
cmdline_compl		|cmdline-completion| コマンドライン補完をサポート
cmdline_hist		|cmdline-history| コマンドライン履歴をサポート
cmdline_info		'showcmd' と 'ruler' をサポート
comments		|'comments'| をサポート
compatible		Vi互換度を非常に高めてコンパイルされている
cryptv			暗号化をサポート |encryption|
cscope			|cscope|をサポート
debug			デバッグバージョンである
dialog_con		コンソールダイアログのサポート
dialog_gui		GUIダイアログのサポート
diff			|vimdiff| と 'diff' のサポート
digraphs		ダイグラフをサポート
dnd			レジスタ "~ をサポート |quote_~|
dos16			16ビットDOSバージョン
dos32			32ビットDOSバージョン (DJGPP)
ebcdic			EBCDIC文字集合のマシン用
emacs_tags		Emacs式のタグファイルをサポート
eval			式評価をサポート。もちろん常に真。
ex_extra		拡張exコマンドをサポート |+ex_extra|
extra_search		|'incsearch'| と |'hlsearch'| をサポート
farsi			|farsi|をサポート
file_in_path		|gf|と|<cfile>|をサポート
filterpipe		'shelltemp' がオフのとき、シェルの読み込み・書き込み・
			フィルタコマンドにパイプを使う。
find_in_path		includeファイル内の検索をサポート |+find_in_path|
float			浮動小数点数 |Float| サポート
fname_case		ファイル名の大文字小文字が区別される(Amiga,MS-DOS,
			そしてWindowsでは区別されないので偽)
folding			|folding| 折り畳みをサポート
footer			GUIのフッタをサポート |gui-footer|
fork			system()の代わりにfork()/exec()を用いている
gettext			翻訳メッセージをサポート |multi-lang|
gui			GUIが有効である
gui_athena		AthenaのGUIが有効である
gui_gnome		Gnomeサポート(gui_gtkも定義される)
gui_gtk			GTK+のGUIが有効である
gui_gtk2		GTK+ 2のGUIが有効である (gui_gtkも定義される)
gui_mac			マッキントッシュのGUIが有効である
gui_motif		MotifのGUIが有効である
gui_photon		PhotonのGUIが有効である
gui_running		VimがGUIモードで起動している、もしくは間もなくする
gui_win32		Win32のGUIが有効である
gui_win32s		Win32sのGUIが有効である (Windows 3.1)
hangul_input		ハングル入力サポート
iconv			iconv()をサポート
insert_expand		挿入モード時にCTRL-Xの展開がサポートされる
jumplist		|jumplist| をサポート
keymap			'keymap' をサポート
langmap			'langmap' サポート
libcall			|libcall()| をサポート
linebreak		'linebreak', 'breakat' そして 'showbreak' をサポート
lispindent		lisp式のインデントをサポート
listcmds		バッファリスト用のコマンド|:files|と引数リスト用のコマ
			ンド|arglist|をサポート
localmap		ローカルなマッピングと短縮入力をサポート|:map-local|
lua			Lua インターフェースをサポート |Lua|
mac			マッキントッシュバージョン
macunix			Unixファイル用のマッキントッシュバージョン(OS-X)
menu			|:menu|をサポート
mksession		|:mksession|をサポート
modify_fname		ファイル名変換子をサポート |filename-modifiers|
mouse			マウスをサポート
mouse_dec		DECのターミナルマウスをサポート
mouse_gpm		gpmをサポート (Linuxのコンソールマウス)
mouse_netterm		nettermのマウスをサポート
mouse_pterm		qnx ptermのマウスをサポート
mouse_sysmouse		sysmouse (*BSD コンソールマウス)をサポート
mouse_sgr		sgrのマウスをサポート
mouse_urxvt		urxvtのマウスをサポート
mouse_xterm		xtermのマウスをサポート
mouseshape		'mouseshape' をサポート
multi_byte		'encoding' をサポート
multi_byte_encoding	'encoding' がマルチバイトエンコーディングになる
multi_byte_ime		IMEによる入力をサポート
multi_lang		複数言語をサポート
mzscheme		MzSchemeインターフェイスをサポート |mzscheme|
netbeans_enabled	|netbeans|をサポートし、現在接続している
netbeans_intg		|netbeans|をサポート
ole			Win32にてOLEオートメーションをサポート
os2			OS/2バージョン
path_extra		'path' と 'tags' の上方・下方検索をサポート
perl			Perlインターフェイスをサポート
persistent_undo		永続アンドゥをサポート
postscript		PostScriptファイルの印刷をサポート
printer			|:hardcopy| をサポート
profile			|:profile| をサポート
python			Python 2.x インターフェースをサポート |has-python|
python3			Python 3.x インターフェースをサポート |has-python|
qnx			QNXバージョン
quickfix		|quickfix|をサポート
reltime			|reltime()|をサポート
rightleft		'rightleft' をサポート
ruby			Rubyインターフェイスをサポート
scrollbind		'scrollbind' をサポート
showcmd			'showcmd' をサポート
signs			|:sign|をサポート
smartindent		'smartindent' をサポート
sniff			SniFFインターフェイスをサポート
spell			スペルチェックをサポート |spell|
startuptime		|--startuptime| をサポート
statusline		'statusline', 'rulerformat' そして 'titlestring' と
			'iconstring' の特殊フォーマットをサポート
sun_workshop		Sun |workshop|をサポート
syntax			構文ハイライトをサポート
syntax_items		現在のバッファに有効なシンタックスが設定されている
system			fork()/exec()の代わりにsystem()が使用されている
tag_binary		タグファイル内のバイナリサーチ |tag-binary-search|
tag_old_static		旧式の静的tagsをサポート |tag-old-static|
tag_any_white		タグファイル内の空白文字をサポート |tag-any-white|
tcl			TCLインターフェースをサポート
terminfo		termcapの代わりにterminfoをサポート
termresponse		|t_RV|と|v:termresponse|をサポート
textobjects		|text-objects|をサポート
tgetent			tgetentをサポート。termcapかterminfoファイルが使用可能
title			ウィンドウタイトルをサポート |'title'|
toolbar			|gui-toolbar|をサポート
unix			UNIXバージョン
user_commands		ユーザ定義コマンドをサポート
vertsplit		ウィンドウの垂直分割をサポート |:vsplit|
vim_starting		Vimの初期化プロセス中は真となる。|startup|
viminfo			viminfoをサポート
virtualedit		オプション 'virtualedit' をサポート
visual			ビジュアルモードをサポート
visualextra		拡張ビジュアルモードをサポート |blockwise-operators|
vms			VMSバージョン
vreplace		コマンド|gR|と|gr|をサポート
wildignore		オプション 'wildignore' をサポート
wildmenu		オプション 'wildmenu' を指定してコンパイル
win16			Win16バージョン(MS-Windows 3.1)
win32			Win32バージョン(MS-Windows 95 以上の 32 or 64 ビット)
win32unix		Win32バージョン。Unixファイルを使用 (Cygwin)
win64			Win64バージョン(MS-Windows 64 bit)
win95			Win32バージョン。MS-Windows 95/98/ME用。
winaltkeys		オプション 'winaltkeys' を指定してコンパイル
windows			複数ウィンドウをサポート
writebackup		オプション 'writebackup' が起動時にonになる
xfontset		X fontsetをサポート |xfontset|
xim			XIMをサポート |xim|
xpm_w32			Win32 で pixmap をサポート
xsmp			Xセッションマネージメントをサポート
xsmp_interact		対話的Xセッションマネージメントをサポート
xterm_clipboard		xtermのクリップボードサポート
xterm_save		xtermのスクリーンの保存復帰をサポート
x11			X11をサポート

							*string-match*
文字列内でのパターンマッチング

|pattern|で説明されている正規表現パターンは通常、バッファ内の行に対してマッチ
を検索するために使われる。文字列内でマッチを見つけるために使うときも、ほとんど
は同じように動作する。違いは、文字列が1つの行であるかのように扱われる事である。
文字列が文字 "\n" だけを含むとき、これは改行とはみなされない。この "\n" はパ
ターン内の "\n" や "." にマッチする。例: >
	:let a = "aaaa\nxxxx"
	:echo matchstr(a, "..\n..")
	aa
	xx
	:echo matchstr(a, "a.x")
	a
	x

"^" は文字列の最初の文字でだけマッチし、"$" は最後の文字でだけマッチすることに
注意。"\n" の前後にはマッチしない。

==============================================================================
5. 関数定義						*user-functions*

ユーザは自分で新しい関数を定義することができる。その関数は組込み関数とまったく
同じように呼び出せる。関数は一連のExコマンドを実行する。ノーマルモードコマンド
はコマンド|:normal|によって実行できる。

関数名は組込み関数との混同を避ける為、大文字で始まらなければならない。他のスク
リプトで同じ関数名を使用してしまうことを避ける為に、露骨に短い名前は避けるべき
である。関数名を例えば "HTMLcolor()" のように、スクリプトの名前から始めるとい
うのは良い習慣である。

波括弧変数というものもある(|curly-braces-names|を参照)。また、オートロード
|autoload|機構を使うと、関数が呼ばれたときだけ定義することができる。

							*local-function*
スクリプトローカルな関数の名前は "s:" で始めなければならない。スクリプトローカ
ルな関数は、そのスクリプトの中の関数から、またはそのスクリプト内で定義された
ユーザ定義コマンド、オートコマンドからしか呼ぶことができない。そのスクリプト内
で定義されたマッピングにより呼ぶこともできるが、スクリプトの外部でマッピングが
展開された場合は "s:" の代わりに |<SID>| をつけなければならない。

					*:fu* *:function* *E128* *E129* *E123*
:fu[nction]		全ての関数と、その引数を表示する。

:fu[nction] {name}	関数{name}の定義を表示する。
			{name}は辞書|Dictionary|の要素の|Funcref|であってもよ
			い: >
				:function dict.init

:fu[nction] /{pattern}	{pattern}にマッチする名前の関数を表示する。"File" で終
			わる関数を全て表示する例: >
				:function /File$
<
							*:function-verbose*
'verbose' が 0 でないとき、これらのコマンドで関数を表示すると、それがどこで定
義されたかも表示する。例: >

    :verbose function SetFileTypeSH
	function SetFileTypeSH(name)
	    Last set from /usr/share/vim/vim-7.0/filetype.vim
<
より詳しくは|:verbose-cmd|を参照。

							*E124* *E125* *E853*
:fu[nction][!] {name}([arguments]) [range] [abort] [dict]
			{name}という名前で新しい関数を定義する。関数名はアル
			ファベットと数字と '_' からなり、通常の関数はアルファ
			ベットの大文字、スクリプトローカル関数は "s:" で始まら
			なければならない。

			{name}は辞書|Dictionary|の要素の|Funcref|であってもよ
			い: >
				:function dict.init(arg)
<			"dict" は既に定義されている辞書でなければならない。そ
			の要素 "init" がまだ存在しないならば追加される。存在す
			る場合は、既存の関数を上書きするためには [!] をつけな
			ければならない。この値は番号つきの関数を指す|Funcref|
			である。この関数は|Funcref|を通してのみ呼ぶことができ、
			そこへの参照がなくなると削除される。
								*E127* *E122*
			この名前で定義される関数が既に定義済みで [!] が使用さ
			れなかった場合、エラーとなる。[!] が使用されていれば、
			それまで存在していた関数は、速やかに新しいものへ置換え
			られる。

			引数{arguments}については|function-argument|を参照。

						*a:firstline* *a:lastline*
			引数[range]を追加した場合、関数は「範囲」を管理するこ
			とができる。「範囲」は "a:firstline" と "a:lastline"
			によって渡される。[range]がなかった場合、
			":{range}call" が「範囲」を指定されて実行されると、1行
			1行について、カーソルをその行の先頭に置いた状態で関数
			を呼び出すことになる。|function-range-example|を参照。
			他の Ex コマンドと同様に、カーソルは選択範囲の最初の行
			に移動される。

			引数[abort]を追加すると、関数の実行中にエラーに遭遇し
			次第、即関数は中断される。

			引数[dict]を追加すると、この関数は辞書|Dictionary|の要
			素を通してしか呼べなくなる。そしてその辞書にローカル変
			数 "self" が定義される。|Dictionary-function|を参照。

						*function-search-undo*
			関数の実行によって、最後に使用されたサーチパターン、及
			びredoコマンドの "." の内容は変更されない。したがって、
			関数内で|:nohlsearch| を行っても、関数から戻ると検索結
			果のハイライトが元に戻ることになる。

					*:endf* *:endfunction* *E126* *E193*
:endf[unction]		関数定義の終了。このコマンド1つで1行とすること。他のコ
			マンドをいっしょに書いてはならない。

					*:delf* *:delfunction* *E130* *E131*
:delf[unction] {name}	関数{name}を削除する。
			{name}は辞書|Dictionary|の要素の|Funcref|であってもよ
			い: >
				:delfunc dict.init
<			この例は "dict" から要素 "init" を削除する。この関数へ
			の参照がなくなると、関数は削除される。
							*:retu* *:return* *E133*
:retu[rn] [expr]	関数から戻る。"[expr]" が与えられた場合、それは評価さ
			れ関数の戻り値として呼出し側に渡される。"[expr]" が与
			えられない場合、数値0が呼出し側に渡される。
			関数内に実行されない命令があるかどうかはチェックされな
			いことに留意すること。つまり、たとえ ":return" 命令の
			後に何か命令があったとしても、警告も何も与えられない。

			|:try|と|:finally|の間で ":return" が実行された場合、
			":finally" から対応する|:endtry|までのコマンドがまず実
			行される。":try" がネストしている場合、それらの全てに
			対してこのプロセスが適用される。そして最も外側の
			":endtry" にて関数を抜ける。

						*function-argument* *a:var*
引数は、与えられた名前によって定義される。関数のなかでは "a:name" ("a:" を引数
に接頭)のようにして参照することができる。
					*a:0* *a:1* *a:000* *E740* *...*
引数はカンマで区切ることで、最大20まで与えることができる。最後の引数を "..."
にすることで、可変長の引数を使用できる。関数の中では "a:1" や "a:2" のようにし
て可変長の引数にアクセスできる。"a:0" は可変長引数が幾つあるかを示している (0
であること、つまり引数がそれ以上ないこともある)。"a:000" は全引数を持つリスト
|List|を示している。Note "a:1" は "a:000[0]" と同じである。
								*E742*
a: のスコープとこの変数は固定されており、変更できない。
しかしリスト|List|か辞書|Dictionary|の場合は、その要素を変更できる。よって関数
にリスト|List|を渡し、そこに要素を追加させることができる。関数にリストや辞書を
変更させたくない場合は|:lockvar|を使うこと。

"..." が使われていない時は、引数の数は名前付きの引数の個数を示す。"..." を使っ
た時には引数の数は大きくなるだろう。

関数を引数無しで定義することも可能である。その時でも()は付けなければならない。
関数の本体は、宣言の次の行から始まり、対応する|:endfunction|までになる。関数の
中で別の関数を定義することも可能である。


							*local-variables*
関数の中で変数を使うこともできる。これらは関数から戻ると消滅するローカル変数と
して振舞う。グローバル変数にアクセスするためには "g:" を付ける必要がある。

例: >
  :function Table(title, ...)
  :  echohl Title
  :  echo a:title
  :  echohl None
  :  echo a:0 . " items:"
  :  for s in a:000
  :    echon ' ' . s
  :  endfor
  :endfunction 

この関数は次のように呼ぶことが出きる: >
  let lines = Table("Table", "line1", "line2")
  let lines = Table("Empty Table")

一つ以上の値を返したい場合には、グローバル変数の名前を渡すようにする: >
  :function Compute(n1, n2)
  :  if a:n2 == 0
  :    return ["fail", 0]
  :  endif
  :  return ["ok", a:n1 / a:n2]
  :endfunction

この関数は次のように呼ぶことができる: >
  :let [success, div] = Compute(102, 6)
  :if success == "ok"
  :  echo div
  :endif
<

						*:cal* *:call* *E107* *E117*
:[range]cal[l] {name}([arguments])
		関数を呼び出す。関数の名前と引数は|:function|によって指定され
		るものである。引数は最大20まで使用可能。戻り値は破棄される。
		「範囲」を受け付ける関数に「範囲」を指定しなかった場合、関数は
		カーソルの現在位置について一度だけ呼び出される。
		「範囲」を受け付けない関数に「範囲」を指定した場合、その範囲の
		一行ずつについて関数が呼び出される。その時カーソルは当該行の先
		頭に設定される。カーソルは「範囲」の最下行の左端になる(恐らく
		最後の関数呼出しの結果、動いた先である)。引数は各呼出しについ
		て繰り返し評価される。それは次の例で確かめることができる:
						*function-range-example*  >
	:function Mynumber(arg)
	:  echo line(".") . " " . a:arg
	:endfunction
	:1,5call Mynumber(getline("."))
<
		"a:firstline" と "a:lastline" はとにかく定義されるので、「範
		囲」の最初や最後で何か違った事をするのにも用いることができる。

		「範囲」自身を扱っている関数の例: >

	:function Cont() range
	:  execute (a:firstline + 1) . "," . a:lastline . 's/^/\t\\ '
	:endfunction
	:4,8call Cont()
< 
		この関数は「範囲」の最初の行を除いた全ての行の先頭に、継続のた
		めの文字 "\" を挿入する。

		この関数の戻り値からさらに間接参照が行われる場合、その参照先に
		は範囲が渡されない。例: >
	:4,8call GetDict().method()
<		GetDict()には範囲が渡されるが、method()には渡されない。

								*E132*
関数の再帰的な使用はオプション |'maxfuncdepth'| によって制限することができる。

自動的に読み込まれる関数 ~
							*autoload-functions*
たくさんの関数または巨大な関数を使うときは、それらが使用されたときだけ自動的に
定義されるようにすることができる。これには2つの方法がある: オートコマンドによ
る方法と、'runtimepath' 内の "autoload" ディレクトリによる方法である。


オートコマンドを使う方法 ~

これはユーザマニュアルのセクション|41.14|で説明されている。

オートコマンドは、長いVimスクリプトファイルのプラグインに対して有用である。自動
コマンドを定義し、すぐに|:finish|でそのスクリプトを抜ける。こうするとVimの起動
が速くなる。その後オートコマンドにより|:finish|コマンドをスキップする変数を定義
し、そのファイルが再び読み込まれる。

定義すべき関数名にマッチするパターンを指定してオートコマンドイベント
FuncUndefinedを使う。例: >

	:au FuncUndefined BufNet* source ~/vim/bufnetfuncs.vim

ファイル "~/vim/bufnetfuncs.vim" は "BufNet" で始まる関数を定義しなければなら
ない。|FuncUndefined|も参照。


オートロードスクリプトの使い方 ~
							*autoload* *E746*
これはユーザマニュアルのセクション|41.15|で説明されている。

"autoload" ディレクトリのスクリプトを使う方法はより簡単である。しかし完全に正
しいファイル名を使う必要がある。オートロードされる関数は次のような名前を持つ: >

	:call filename#funcname()

このような関数が呼ばれ、それがまだ定義されていなかった場合、Vimは 'runtimepath'
内の "autoload" ディレクトリから "filename.vim" というスクリプトファイルを探
す。例えば "~/.vim/autoload/filename.vim" のように。そしてこのファイルは次のよ
うな関数を定義していなければならない: >

	function filename#funcname()
	   echo "Done!"
	endfunction

このファイル名と関数の # の前の部分は完全に一致しなければならない。そして定義
された関数は呼ばれた関数と完全に同じ名前でなければならない。

サブディレクトリを使うこともできる。関数名の中の # はパスのセパレータのように
解釈される。つまり、次の関数を呼ぶと: >

	:call foo#bar#func()

Vimは 'runtimepath' からファイル "autoload/foo/bar.vim" を探す。

これはまだ定義されていない変数を参照するときにも使える: >

	:let l = foo#bar#lvar

しかしこのオートロードスクリプトがすでに読み込まれている場合、未知の変数があっ
てもこのスクリプトは再読み込みされない。

この変数に値を代入するときは、何も特別なことはない。この方法は、オートロードス
クリプトが読み込まれる前に設定を渡すために使うことができる: >

	:let foo#bar#toggle = 1
	:call foo#bar#func()

オートロードスクリプト内で定義されるはずの関数を呼んだがスクリプト内で関数が定
義されなかった場合、その関数を呼ぶたびにそのスクリプトがsourceされる。そして毎
回エラーメッセージが表示される。

また、2つのスクリプト間で、互いに自分が定義される前に相手を呼ぶような関数があ
ると、これは動作しない。
トップレベルでオートロード機能を使うのは避けること。

Hint: たくさんのファイルからなるスクリプトを配布する場合には、|vimball|ユーティ
リティを使うとそれらをまとめることができる。ユーザマニュアルの
|distribute-script|も参照。

==============================================================================
6. 波括弧変数						*curly-braces-names*

変数を使用可能なほとんどの文脈では「波括弧」変数を使うことができる。これは有効
な変数名であり、次のように、1個以上の式を波括弧{}で囲む: >
	my_{adjective}_variable

Vimはこれを見つけると、まず波括弧の中の式を評価し、その値をもとの位置に置きか
え、全体を変数名として再解釈する。よって上の例では、変数 "adjective" に
"noisy" が代入されていたとすると、この変数は "my_noisy_variable" となる。ある
いは、"adjective" に "quiet" が代入されていたとすれば "my_quiet_variable" とな
る。

これの応用の1つは、オプション値によって支配される変数の集合を作ることである。
例えば次の文 >
	echo my_{&background}_message

は現在の 'background' の値に応じて "my_dark_message" か "my_light_message" の
中身を表示する。

波括弧を複数使うこともできる: >
	echo my_{adverb}_{adjective}_message
ネストさせることもできる: >
	echo my_{ad{end_of_word}}_message
ここで "end_of_word" は "verb" か "jective" のどちらかである。

しかし、波括弧の中の式を評価した結果が有効な変数名とならなければならない。
つまり、次は無効である: >
	:let foo='a + b'
	:echo c{foo}d
というのは、展開の結果が "ca + bd" となるからで、これは有効な名前ではない。

						*curly-braces-function-names*
同様の方法で評価した名前により関数を定義したり呼び出したりできる。
例: >
	:let func_end='whizz'
	:call my_func_{func_end}(parameter)

この例は関数 "my_func_whizz(parameter)" を呼びだす。

これらは機能しない: >
  :let i = 3
  :let @{i} = ''  " error
  :echo @{i}      " error

==============================================================================
7. コマンド						*expression-commands*

:let {var-name} = {expr1}				*:let*
			内部変数{var-name}に式{expr1}の結果をセットする。変数
			の型は{expr1}によって決定される。{var-name}という変数
			がまだ存在しない場合、新たに作成される。

:let {var-name}[{idx}] = {expr1}			*E689*
			リストの要素に式{expr1}の結果をセットする。{var-name}
			はリストを参照し、{idx}はそのリストの有効なインデック
			スでなければならない。ネストしたリストに対してはイン
			デックスを繰り返すことができる。
			このコマンドはリストに要素を追加するためには使えない。
			文字列の i バイト目をセットするためにも使えない。それ
			には次のようにする: >
				:let var = var[0:2] . 'X' . var[4:]
<

							*E711* *E719*
:let {var-name}[{idx1}:{idx2}] = {expr1}		*E708* *E709* *E710*
			リスト|List|の一部を式{expr}の値で置き換える。{expr}の
			値は正しい個数の要素を持つリストでなければならない。
			{idx1}を省略すると0となる。
			{idx2}を省略するとリストの末尾となる。
			指定された範囲の一部がリストの末尾を越える場合、要素が
			追加される。

					*:let+=* *:let-=* *:let.=* *E734*
:let {var} += {expr1}	":let {var} = {var} + {expr1}" と同様。
:let {var} -= {expr1}	":let {var} = {var} - {expr1}" と同様。
:let {var} .= {expr1}	":let {var} = {var} . {expr1}" と同様。
			{var}がセットされていないときや、{var}と{expr1}の型が
			演算子に合わないときは失敗する。


:let ${env-name} = {expr1}			*:let-environment* *:let-$*
			環境変数{env-name}に式{expr1}の結果をセットする。型は
			常に文字列。
:let ${env-name} .= {expr1}
			環境変数{env-name}に{expr1}を付け加える。その環境変数
			が存在しないときは "=" と同様に働く。

:let @{reg-name} = {expr1}			*:let-register* *:let-@*
			式{expr1}の結果をレジスタ{reg-name}に書きこむ。
			{reg-name}は単一の文字でかつ、書きこむことのできるレジ
			スタでなければならない(|registers|を参照)。"@@" は名前
			無しレジスタとして使用でき、"@/" はサーチパターンとし
			て使用できる。
			{expr1}の結果が<CR>か<NL>で終了していた場合、レジスタ
			は行単位で設定され、そうでなければキャラクタ単位で設定
			される。
			次のコマンドにより最後に検索したパターンをクリアするこ
			とができる: >
				:let @/ = ""
<			これは空文字列を検索するのとは異なる。空文字列を検索す
			ると、いたるところでマッチする。

:let @{reg-name} .= {expr1}
			レジスタ{reg-name}に{expr1}を付け加える。このレジスタ
			が空のときは、そこに{expr1}をセットする。

:let &{option-name} = {expr1}			*:let-option* *:let-&*
			オプション{option-name}に式{expr}の値をセットする。文
			字列や数値の値はそのオプションの型に変換される。
			ウィンドウやバッファについてローカルなオプションに対し
			ては、その効果は|:set|コマンドを使ったときと同様で、ロー
			カルな値とグローバルな値の両方が変更される。
			例: >
				:let &path = &path . ',/usr/local/include'

:let &{option-name} .= {expr1}
			文字列のオプションの場合: その値に{expr}を付け加える。
			|:set+=|とは違い、コンマを挿入しない。

:let &{option-name} += {expr1}
:let &{option-name} -= {expr1}
			数値または切替のオプションの場合: {expr1}を足す・引く。 

:let &l:{option-name} = {expr1}
:let &l:{option-name} .= {expr1}
:let &l:{option-name} += {expr1}
:let &l:{option-name} -= {expr1}
			上と同様だが、オプションのローカルな値だけをセットする
			(ローカルな値があるならば)。|:setlocal|と同様に働く。

:let &g:{option-name} = {expr1}
:let &g:{option-name} .= {expr1}
:let &g:{option-name} += {expr1}
:let &g:{option-name} -= {expr1}
			上と同様だが、オプションのグローバルな値だけをセットす
			る(グローバルな値があるならば)。|:setglobal|と同様に働
			く。

:let [{name1}, {name2}, ...] = {expr1}		*:let-unpack* *E687* *E688*
			{expr1}の値はリスト|List|でなければならない。そのリス
			トの最初の要素が{name1}に代入され、2番目の要素が
			{name2}に代入される。以下同様。
			nameの個数がリスト|List|の要素の個数に一致しなければな
			らない。
			前述のように各nameは ":let" コマンドの要素の1つになる
			ことができる。
			例: >
				:let [s, item] = GetItem(s)
<			詳細: 最初に{expr1}が評価され、それから順番に代入が行
			われる。{name2}が{name1}に依存するかどうかは問題になる。
			例: >
				:let x = [0, 1]
				:let i = 0
				:let [i, x[i]] = [1, 2]
				:echo x
<			子の結果は[0, 2]となる。

:let [{name1}, {name2}, ...] .= {expr1}
:let [{name1}, {name2}, ...] += {expr1}
:let [{name1}, {name2}, ...] -= {expr1}
			上と同様だが、リスト|List|の各要素に対し連結・足し算・
			引き算を行う。

:let [{name}, ..., ; {lastname}] = {expr1}
			|:let-unpack|と同様だが、リスト|List|の要素数がnamesの
			数より多くてもよい。余った要素のリストが{lastname}に代
			入される。要素の余りがないとき{lastname}は空リストにな
			る。
			例: >
				:let [a, b; rest] = ["aval", "bval", 3, 4]
<
:let [{name}, ..., ; {lastname}] .= {expr1}
:let [{name}, ..., ; {lastname}] += {expr1}
:let [{name}, ..., ; {lastname}] -= {expr1}
			上と同様だが、リスト|List|の各要素に対して連結・足し算
			・引き算を行う。

								*E121*
:let {var-name}	..	変数{var-name}の値を一覧表示する。変数の名前を複数指定
			することができる。以下の特別な名前が認識される:	*E738*
			  g:	グローバル変数
			  b:	バッファローカル変数
			  w:	ウィンドウローカル変数
			  t:	タブページローカル変数
			  s:	スクリプトローカル変数
			  l:	関数ローカル変数
			  v:	Vimの変数

:let			全変数の値を一覧表示する。値の前に変数の型が示される:
			    <nothing>	文字列
				#	数値
				*	Funcref


:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
			内部変数{name}を削除する。複数の変数名を指定すると、そ
			れらが全て削除される。名前はリスト|List|や辞書
			|Dictionary|の要素でもよい。
			[!]をつけると存在しない変数に対するエラーメッセージを
			表示しない。
			リスト|List|から1個以上の要素を削除することができる: >
				:unlet list[3]	  " 4番目の要素を削除
				:unlet list[3:]   " 4番目から最後までの要素を
						    削除
<			辞書からは一度に1個の要素を削除することができる: >
				:unlet dict['two']
				:unlet dict.two
			グローバル変数とスクリプトローカル変数をクリーンアップ
			するために特に便利である(これらはスクリプト終了時に検
			出されない)。関数ローカルな関数は、その関数から抜ける
			ときに自動的に削除される。

:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
			内部変数{name}をロックする。ロックすると、それ以降変更
			ができなくなる(アンロックするまで)。
			ロックされた変数を削除することはできる: >
				:lockvar v
				:let v = 'asdf'		" 失敗!
				:unlet v
<							*E741*
			ロックされた変数を変更しようとするとエラーメッセージ
			"E741: Value of {name} is locked" が表示される。

			[depth]はリスト|List|や辞書|Dictionary|をロックすると
			きに意味がある。どれだけ深くロックするかを指定する:
				1	リストや辞書それ自身をロックする。要素
					を追加したり削除はできないが、要素の値
					を変えることはできる。
				2	要素の値もロックする。その要素がリスト
					や辞書である場合、その中の要素の追加や
					削除はできないが、値の変更はできる。
				3	2と同様だが、リスト・辞書内のリスト・
					辞書に対してもあてはまる。1レベル深い。
			[depth]の既定値は2であり、{name}がリストまたは辞書であ
			る場合、その値は変更できない。
								*E743*
			深さを無限にするには[!]を使い、[depth]を省略する。しか
			しループを捕捉するために深さの最大値は100に設定されて
			いる。

			Note 2つの変数が同じリスト|List|を参照している場合、片
			方の変数をロックすると、もう一方の変数を介してアクセス
			した場合もロックされている。
			例: >
				:let l = [0, 1, 2, 3]
				:let cl = l
				:lockvar l
				:let cl[1] = 99		" 代入できない!
<			
			これを回避するにはリストのコピーを作るとよい。
			|deepcopy()|を参照。


:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
			内部変数{name}をアンロックする。|:lockvar|の逆を行う。


:if {expr1}						*:if* *:endif* *:en*
:en[dif]		{expr1}が非ゼロと評価された場合に、対応する ":else" か
			":endif" までの命令を実行する。

			バージョン4.5から5.0まで間のVimは、":if" と ":endif"
			の間の全てのExコマンドは無視する。この2つのコマンドは
			将来の拡張性を、下位互換と同時に提供するためのものであ
			る。ネスティング (入れ子) が可能である。":else" や
			":elseif" は無視され、"else" 部分は一切実行されないこ
			とに注意。

			あなたはこれを、旧バージョンとの互換性を保ったまま使用
			することができる: >
				:if version >= 500
				:  version-5-specific-commands
				:endif
<			しかしそれでも "endif" を見つけるために後続のコマンド
			をパースする必要がある。古いVimで新しいコマンドを使う
			と問題が起こることがある。例えば ":silent" が
			":substitute" コマンドと認識されるなど。その場合には、
			":execute" を使うと問題を避けることができる: >
				:if version >= 600
				:  execute "silent 1,$delete"
				:endif
<
			NOTE: ":append" と ":insert" コマンドは ":if" と
			":endif" の間では正しく動かない。

						*:else* *:el* *E581* *E583*
:el[se]			対応する ":if" ブロックが実行されなかった場合には、こ
			れに対応する ":else" か ":endif" までのコマンドが実行
			される。

					*:elseif* *:elsei* *E582* *E584*
:elsei[f] {expr1}	":else" ":if" の省略形。":endif" を付け加える (入れ子に
			する) 手間を省くことができる。

:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
						*E170* *E585* *E588* *E733*
:endw[hile]		{expr1}が非ゼロとして評価される間、":while" と
			":endwhile" の間のコマンドを繰り返し実行する。
			ループの内側でエラーが生じた場合、endwhileの直後から実
			行が再開される。
			例: >
				:let lnum = 1
				:while lnum <= line("$")
				   :call FixLine(lnum)
				   :let lnum = lnum + 1
				:endwhile
<
		NOTE: ":append" や ":insert" コマンドは ":while" ループの内側
		では正しく動かない。

:for {var} in {list}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
			{list}の各要素に対し、":for" と ":endfor" の間のコマン
			ドを繰り返す。変数{var}に各要素の値がセットされる。
			ループの内側のコマンドでエラーが検出されたときは
			"endfor" の後から実行が継続される。
			ループの内側で{list}を変更するとどの要素が使われるかに
			影響を与える。それを望まない場合はコピーを作ること: >
				:for item in copy(mylist)
<			コピーを作らないと、Vimは現在の要素に対してコマンドを
			実行する前に、リストの次の要素への参照を保存する。その
			ため副作用なしに現在の要素を削除することができる。それ
			以降の要素を変更すると、それが見つからなくなる。つまり
			以下の例は動作する(リストを空にする非効率な方法): >
				for item in mylist
				   call remove(mylist, 0)
				endfor
<			Note リストを並べ替える(例えばsort()やreverse()で)と予
			期しない結果になることがある。
			Note {var}の型が変わってしまうのを避けるために、リスト
			の各要素の型は同じでなければならない。ループの末尾でこ
			の変数をunletすれば要素の型が同一でなくてもよくなる: >
				for item in ["foo", ["bar"]]
				   echo item
				   unlet item  " これがないと E706 になる
				endfor

:for [{var1}, {var2}, ...] in {listlist}
:endfo[r]
			上の ":for" と同様だが、{listlist}の各要素がリストでな
			ければならない点が異なる。そのリストの各要素が{var1},
			{var2}などに代入される。例: >
				:for [lnum, col] in [[1, 3], [2, 5], [3, 8]]
				   :echo getline(lnum)[col]
				:endfor
<
						*:continue* *:con* *E586*
:con[tinue]		":while" または ":for" ループの内側で使われたときは、
			そのループの開始位置まで戻る。
			ループの内側の|:try|と|:finally|の間で使われた場合、
			|:finally|から|:endtry|までの間のコマンドがまず実行さ
			れる。ループの内側で ":try" がネストしている場合、全て
			の ":try" に対してこのプロセスが適用される。最も外側の
			":endtry" の後ループの開始位置まで戻る。

						*:break* *:brea* *E587*
:brea[k]		":while" または ":for" ループの内側で使われたときは、
			対応する ":endwhile" または ":endfor" の後のコマンドま
			でスキップする。
			ループの内側の|:try|と|:finally|の間で使われた場合、
			|:finally|から|:endtry|までの間のコマンドがまず実行さ
			れる。ループの内側で ":try" がネストしている場合、全て
			の ":try" に対してこのプロセスが適用される。最も外側の
			":endtry" の後ループの後までジャンプする。

:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		":try" と ":endtry" の間のコマンド (":source" コマン
			ド、関数呼び出し、オートコマンド実行を含めた全てのコマ
			ンド実行) のエラー制御を変更する。

			エラーや割り込みが検出された場合、後に|:finally|コマン
			ドがあるならば、":finally" の後から実行が継続される。
			そうでければ、または ":endtry" に達した後は次の動的に
			囲んでいる ":try" に対応する ":finally" などが探され
			る。その後スクリプトは実行を停止する。(関数定義に引数
			"abort" がついているかどうかは関係ない)
			例: >
		:try | edit too much | finally | echo "cleanup" | endtry
		:echo "impossible"	" 実行されない。上のコマンドにより
					" スクリプトは停止する。
<
			さらに、(動的に) ":try" と ":endtry" の内側にあるエラー
			や割り込みは例外に変換される。そしてそれは|:throw|コマ
			ンドによって投げたときと同様に捕捉できる(|:catch|を参
			照)。この場合はスクリプトの実行は停止しない。

			割り込み例外には "Vim:Interrupt" という値が使われる。
			Vimコマンドにおけるエラーは "Vim({command}):{errmsg}"
			という形式の値に変換される。その他のエラーは
			"Vim:{errmsg}" という形式のエラーに変換される。ここで
			{command}はコマンドの完全な名前であり、{errmsg}はその
			例外が捕捉されなかった場合に表示されるメッセージで、常
			にエラー番号で始まる。
			例: >
		:try | sleep 100 | catch /^Vim:Interrupt$/ | endtry
		:try | edit | catch /^Vim(edit):E\d\+/ | echo "error" | endtry
<
					*:cat* *:catch* *E603* *E604* *E605*
:cat[ch] /{pattern}/	{pattern}にマッチする例外が発生し、より前の|:catch|
			で捕捉されなかった場合、このコマンドから次の|:catch|,
			|:finally|, |:endtry|までのコマンドが実行される。その
			ような例外が発生しなかった場合、そのコマンドはスキップ
			される。
			{pattern}が省略された場合は全てのエラーが捕捉される。
			例: >
		:catch /^Vim:Interrupt$/	" 割り込み (CTRL-C) を捕捉
		:catch /^Vim\%((\a\+)\)\=:E/	" 全Vimエラーを捕捉
		:catch /^Vim\%((\a\+)\)\=:/	" 例外と割り込みを捕捉
		:catch /^Vim(write):/		" :writeにおける全エラーを捕捉
		:catch /^Vim\%((\a\+)\)\=:E123/	" エラーE123を捕捉
		:catch /my-exception/		" ユーザ定義例外を捕捉
		:catch /.*/			" 全てを捕捉
		:catch				" /.*/と同じ
<
			{pattern}を囲むのに/以外の文字を使うことができる。ただ
			しその文字は特別な意味(例: '|' や '"' など)を持ってい
			てはならず、{pattern}の内側に現れてはならない。
			NOTE: エラーメッセージの本文によって ":catch" すること
			は確実ではない。メッセージはロケールによって異なるから
			である。

					*:fina* *:finally* *E606* *E607*
:fina[lly]		|:try|と ":finally" の間を抜ける前に必ず、このコマンド
			から対応する|:endtry|の間のコマンドが実行される。つま
			り正常に進んだ場合、|:continue|, |:break|, |:finish|,
			|:return|を使った場合、エラー・割り込み・例外が発生し
			た場合(|:throw|を参照)のいずれの場合でも。

							*:th* *:throw* *E608*
:th[row] {expr1}	{expr1}を評価し、例外として投げる。|:try|と|:catch|の
			間で ":throw" が使われた場合、{expr1}にマッチする最初
			の|:catch|までのコマンドはスキップされる。そのような
			":catch" がない場合、または ":catch" と|:finally|の間
			で ":throw" が使われた場合、":finally" から|:endtry|ま
			でのコマンドが実行される。":throw" が ":finally" の後
			で実行された場合、":endtry" までのコマンドはスキップさ
			れる。
			":endtry" において、動的に囲んでいる次の ":try" (これ
			は関数呼び出しやスクリプトsourceも含めて探される) から
			対応する ":catch" までに対しこのプロセスが再び適用され
			る。例外が捕捉されない場合、コマンドの処理は終了する。
			例: >
		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
<			Note: エラーによって行のパースがスキップされ、"|" によ
			るコマンド区切りが解釈されないような場合は "catch" は
			行を分けて書く必要がある。

							*:ec* *:echo*
:ec[ho] {expr1} ..	各{expr1}をスペースで区切って表示する。最初の{expr1}の
			表示は、常に新しい行から始まる。
			|:comment|も参照。
			改行が必要な場合 "\n" を使用する。カーソルを第1桁に
			持って行くには "\r" を使用する。
			色強調を行うにはコマンド|:echohl|を使用する。
			コメント文を同じ行に続けることはできない。
			例: >
		:echo "the value of 'shell' is" &shell
<							*:echo-redraw*
			このコマンドの後、再描画を行うと表示したメッセージが消
			えてしまう。Vim は一連のコマンドが完了するまで再描画を
			後回しにするため、この現象は頻繁に発生する。例えば、
			":echo" より前に実行したコマンドが後で再描画を引き起こ
			し、メッセージが消えてしまうということがある(再描画は
			しばしばユーザが何か入力するまで後回しにされる)。この
			問題を避けるには、|:redraw| を使って強制的に再描画する
			こと。例: >
		:new | redraw | echo "there is a new window"
<

							*:echon*
:echon {expr1} ..	改行を付けずに、{expr1}を表示する。|:comment|も参照。
			色強調を行うにはコマンド|:echohl|を使用する。
			コメント文を同じ行に続けることはできない。
			例: >
				:echon "the value of 'shell' is " &shell
<
			Vimコマンドの ":echo" と、外部のシェルコマンドである
			":!echo" との違いに注意: >
		:!echo %		--> filename
<			":!" の引数は展開される。|:_%|を参照。 >
		:!echo "%"		--> filename or "filename"
<			前の例のように働く。ダブルクォートが表示されるかどうか
			は、使用している 'shell' に依存する。 >
		:echo %			--> 何も表示されない
<			'%' は式として不当な文字である。 >
		:echo "%"		--> %
<			単に文字 '%' を表示する。 >
		:echo expand("%")	--> filename
<			'%' を展開するために関数expand()を呼び出している。

							*:echoh* *:echohl*
:echoh[l] {name}	次の |:echo|, |:echon|, |:echomsg| コマンドから、ハイ
			ライトグループ{name}を適用する。|input()|のプロンプト
			に対しても適用される。例: >
		:echohl WarningMsg | echo "Don't panic!" | echohl None
<			使用した後にはグループを "None" に戻すことを忘れないよ
			うに。さもないとそれ以降のechoの表示全てがハイライトさ
			れてしまう。

							*:echom* *:echomsg*
:echom[sg] {expr1} ..	式を本当のメッセージとして表示し、そのメッセージをメッ
			セージ履歴|message-history|に保存する。
			|:echo|コマンド同様に、引数の間にスペースが挿入される。
			しかし印字不可能な文字は解釈されずに表示される。
			|:echo|とはかなり異なり、むしろ|:execute|に近い方法で
			解析がされる。なんらかを表示する前に、まず最初に全ての
			式が評価し、連結する。式を評価した値は数値か文字列でな
			ければならない。辞書やリストはエラーとなる。
			強調を行うには|:echohl|コマンドを使う。
			例: >
		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
<			画面を再描画したときメッセージが消去されてしまうのを避
			ける方法については|:echo-redraw|を参照。
							*:echoe* *:echoerr*
:echoe[rr] {expr1} ..	式をエラーメッセージとして表示し、そのメッセージを
			メッセージ履歴|message-history|に保存する。スクリプト
			や関数の中で使用されたときは行番号が付け加えられる。
			|:echo|コマンドと同様に引数の間にスペースが挿入される。
			try条件文の中で使用されたときは、このメッセージがエ
			ラー例外として投げられる。(|try-echoerr|を参照)
			例: >
		:echoerr "This script just failed!"
<			
			単にメッセージを強調させたい場合には|:echohl|を使うこ
			と。ビープを鳴らしたいときには次のようにする: >
		:exe "normal \<Esc>"
<
							*:exe* *:execute*
:exe[cute] {expr1} ..	{expr1}の評価結果の文字列をExコマンドとして実行する。
			複数の引数は連結され、間にスペースが挿入される。余計な
			スペースを入れたくない場合は "." オペレータを使って文
			字列を連結すること。
			{expr1}は処理されたコマンドとして扱われ、コマンドライ
			ン編集用のキーは認識されない。
			コメント文を同じ行に続けることはできない。
			例: >
		:execute "buffer" nextbuf
		:execute "normal" count . "w"
<
			":execute" は '|' を受けつけないコマンドに、次のコマン
			ドを続けて実行させるのにも使用できる。例: >
		:execute '!ls' | echo "theend"
<			{訳注: 普通の使い方では ":!ls" の後には '|' を使って、
			Exコマンドを続けることはできない}
			また ":execute" は、Vimスクリプト内でコマンド ":normal"
			の引数に制御文字を書くことを避けるために役に立つ。 >
		:execute "normal ixxx\<Esc>"
<			これで<Esc>文字を表す。|expr-string|を参照。

			ファイル名の中の特殊文字を正しくエスケープするように
			注意すること。Vim コマンドに与えるファイル名をエス
			ケープするには |fnameescape()| を使う。|:!| コマンドに
			与えるときは |shellescape()| を使う。
			例: >
		:execute "e " . fnameescape(filename)
		:execute "!ls " . shellescape(expand('%:h'), 1)
<
			Note: executeに渡す文字列としては、"while" や "for"
			や "if" コマンドが始まったり終ったりするだけのようなも
			のは不適格である。よって次のような例は認められない: >
		:execute 'while i > 5'
		:execute 'echo "test" | break'
<
			文字列の中に完全な "while" や "if" コマンドが含まれる
			ことが求められる: >
		:execute 'while i < 5 | echo i | let i = i + 1 | endwhile'
<

							*:exe-comment*
			":execute" や ":echo" そして ":echon" は、同一行に直接
			コメントを続けることはできない。何故ならそれらのコマン
			ドにとって '"' は文字列の始まりに見えてしまうからであ
			る。しかし '|' の後にコメントを書くことは可能である。
			例: >
		:echo "foo" | "this is a comment

==============================================================================
8. 例外処理					*exception-handling*

Vimスクリプト言語は例外処理機構を備えている。この節では例外処理をどのように行
うかについて説明する。

例外はエラー発生時や割り込み発生時にVimによって投げられる。それについては
|catch-errors|と|catch-interrupt|を参照。ユーザはコマンド|:throw|によって明示
的に例外を投げることができる。|throw-catch|を参照。


TRY 条件文					*try-conditionals*

例外を捕捉したり、例外を引き金として後始末のコードを実行することができる。try
条件文を使う事によってcatch節(これが例外を捕捉する)やfinally節(後始末のために
実行される)を指定する事ができる。
try条件文はコマンド|:try|によって始まり、対応するコマンド|:endtry|によって終了
する。その間でコマンド|:catch|によりcatch節を定めたり、コマンド|:finally|に
よってfinally節を定めることができる。catch節は1個もなかったり、複数個あっても
よい。しかしfinally節は1個までしか持てない。finally節の後にcatch節があってはな
らない。catch節とfinally節の前の部分はtryブロックと呼ばれる。

     :try
     :  ...
     :  ...				try ブロック
     :  ...
     :catch /{pattern}/
     :  ...
     :  ...				catch 節
     :  ...
     :catch /{pattern}/
     :  ...
     :  ...				catch 節
     :  ...
     :finally
     :  ...
     :  ...				finally 節
     :  ...
     :endtry

try条件文により、コードから発生する例外を監視したり、適切な対応を取ることがで
きる。tryブロック内で発生した例外は捕捉される。tryブロックとcatch節内で発生し
た例外は捕捉され、後始末が行われる。
tryブロックの実行中に例外が発生しなかった場合は、制御は (もしあれば) finally節
に移動する。その実行後に、スクリプトは ":endtry" の後の行から実行を継続する。
tryブロックの実行中に例外が発生した場合は、tryブロックの残りの行はスキップされ
る。例外はコマンド ":catch" の引数として指定された正規表現に照合される。最初に
マッチした ":catch" の後のcatch節が実行される。他のcatch節は実行されない。
catch節は次に ":catch", ":finally", ":endtry" が現れたところで終了する (どれで
もよい)。
":endtry" に達すると、スクリプトは次の行から通常通り実行が続けられる。
発生した例外が、コマンド ":catch" で指定されたどの正規表現にもマッチしないとき、
その例外はそのtry条件文で捕捉されず、どのcatch節も実行されない。finally節があ
るならば実行される。finally節の実行中は例外は後回しにされ、":endtry" のときに実
行される。そして ":endtry" の後のコマンドは実行されず、例外は他のどこかで捕捉さ
れる。|try-nesting|を参照。
catch節の実行中に新たな例外が発生した場合は、そのcatch節の残りの行は実行されな
い。新しい例外は同じtry条件文のどの ":catch" コマンドの正規表現にも照合されず、
どのcatch節も実行されない。しかしfinally節があるならばそこが実行され、その間そ
の例外は保留される。":endtry" の後のコマンドは実行されない。新しい例外は他のど
こかで捕捉される。|try-nesting|を参照。
finally節の実行中に例外が発生した場合は、そのfinally節の残りの行は実行されない。
tryブロックやそのcatch節のどこかで例外が発生してからそのfinally節が実行されて
いた場合は、元の(保留されていた)例外は破棄される。":endtry" の後のコマンドは実
行されない。finally節で発生した例外は伝播し、他のどこかで捕捉される。
|try-nesting|を参照。

完全なtry条件文を囲む ":while" ループ内で、tryブロックやcatch節において
":break" や ":continue" が実行されたときもfinally節が実行される。
また、関数の中やsourceされたスクリプト中で、tryブロックやtry条件文のcatch節に
おいて ":return" や ":finish" が実行されたときもfinally節が実行される。finally
節の実行中は ":break", ":continue", ":return", ":finish" は保留され、":endtry"
に達したとき再開される。しかしこれらは、そのfinally節内で例外が発生したときは
破棄される。
完全なtry条件節を囲む ":while" ループ内での ":break" や ":continue"、または
finally節内で ":return" や ":finish" に出会ったときは、finally節の残りはスキッ
プされ、通常通り ":break", "continue", ":return", "finish" が実行される。もし
そのfinally節の前に、tryブロックやcatch節内で例外が発生したり、":break",
":continue", ":return", ":finally" が行われていた場合は、それらの保留されてい
た例外やコマンドは破棄される。

例として |throw-catch| と |try-finally| を参照。


try条件文のネスト					*try-nesting*

try条件文は任意にネストされられる。つまり、try条件文のtryブロック・catch節・
finally節のなかに別の完全なtry条件文を書くことができる。内側のtry条件文がtryブ
ロックで発生した例外を捕捉しなかったときや、catch節・finally節で新たな例外が発
生したときは、外側のtry条件文がそのルールにしたがって例外を捕捉する。内側の
try条件文が外側の条件文のtryブロックの中にある場合はcatch節が判定されるが、そ
うでない場合はfinally節のみが実行される。これはネストの仕方には関係ない。つま
り、内側のtry条件文が直接外側のtry条件文に含まれていてもよいし、外側がスクリプ
トをsourceしたり、内側のtry条件文を含む関数を呼び出していてもよい。

有効なtry条件文のどれも例外を捕捉しなかったときは、それらのfinally節が実行され
る。その後、スクリプトの実行は停止する。":throw" コマンドにより明示的に投げら
れた例外が捕捉されなかった場合は、エラーメッセージが表示される。Vimによって暗
黙的に投げられたエラーや割り込み例外については、通常通りエラーメッセージや割り
込みメッセージが表示される。

例として |throw-catch| を参照。


例外処理コードの検査					*except-examine*

例外処理のコードはトリッキーになりがちである。何が起こっているか知りたいときは
スクリプトファイルをsourceするときに 'verbose' を13に設定するか、コマンド修飾
子 ":13verbose" を使う。すると例外が発生・破棄・捕捉・完了したときには表示され
るようになる。冗長度のレベルを14以上にすると、finally節において保留されている
ものも表示されるようになる。この情報はデバッグモードでも表示される
(|debug-scripts|を参照)。


例外の生成と捕捉					*throw-catch*

任意の数値や文字列を例外として投げることができる。コマンド|:throw|を使い、投げ
られる値を引数に渡す: >
	:throw 4711
	:throw "string"
<							*throw-expression*
式を引数に指定することもできる。まずその式が評価され、その結果が投げられる: >
	:throw 4705 + strlen("string")
	:throw strpart("strings", 0, 6)

":throw" コマンドの引数を評価している最中に例外が発生することもありうる。その
例外が捕捉されない限り、その式の評価は破棄される。
よって、その ":throw" コマンドは例外を投げることができない。
   例: >

	:function! Foo(arg)
	:  try
	:    throw a:arg
	:  catch /foo/
	:  endtry
	:  return 1
	:endfunction
	:
	:function! Bar()
	:  echo "in Bar"
	:  return 4710
	:endfunction
	:
	:throw Foo("arrgh") + Bar()

この例を実行すると "arrgh" が投げられ、Bar()が実行されないため "in Bar" は表示
されない。しかし次のようにすると >
	:throw Foo("foo") + Bar()
"in Bar" を表示し、4711を投げる。

式を引数として受け取る他のコマンドでも、式の評価中に捕捉されない例外が発生する
とコマンドが破棄される。そして例外はそのコマンドを呼び出した位置へ伝播する。
   例: >

	:if Foo("arrgh")
	:  echo "then"
	:else
	:  echo "else"
	:endif

この例で、"then" と "else" のどちらも表示されない。

							*catch-order*
例外は、1個以上の|:catch|コマンドを持つtry条件文で捕捉することができる。これに
ついては|try-conditionals|を参照。各 ":catch" コマンドで捕捉される値は、引数に
て正規表現で指定できる。マッチする例外が捕捉されると、その後に続くcatch節が実
行される。
   例: >

	:function! Foo(value)
	:  try
	:    throw a:value
	:  catch /^\d\+$/
	:    echo "Number thrown"
	:  catch /.*/
	:    echo "String thrown"
	:  endtry
	:endfunction
	:
	:call Foo(0x1267)
	:call Foo('string')

最初のFoo()の呼び出しは "Number thrown" を表示し、2番目の呼び出しは "String
thrown" を表示する。例外は、順番に ":catch" コマンドに照合される。最初にマッチ
したcatch節だけが実行される。そのため、より限定的な ":catch" を先に書くべきで
ある。次の順序で書くと無意味になってしまう: >

	:  catch /.*/
	:    echo "String thrown"
	:  catch /^\d\+$/
	:    echo "Number thrown"

最初の ":catch" は常にマッチするため、2番目のcatch節は決して実行されない。

							*throw-variables*
一般的な正規表現により例外を捕捉した場合、その正確な値には変数|v:exception|に
よりアクセスできる: >

	:  catch /^\d\+$/
	:    echo "Number thrown.  Value is" v:exception

また、どこで例外が発生したかも知りたいだろう。これは|v:throwpoint|に保持されて
いる。Note "v:exception" と "v:throwpoint" は最も直近に捕捉された例外に対し、
それが終了するまで有効である。
   例: >

	:function! Caught()
	:  if v:exception != ""
	:    echo 'Caught "' . v:exception . '" in ' . v:throwpoint
	:  else
	:    echo 'Nothing caught'
	:  endif
	:endfunction
	:
	:function! Foo()
	:  try
	:    try
	:      try
	:	 throw 4711
	:      finally
	:	 call Caught()
	:      endtry
	:    catch /.*/
	:      call Caught()
	:      throw "oops"
	:    endtry
	:  catch /.*/
	:    call Caught()
	:  finally
	:    call Caught()
	:  endtry
	:endfunction
	:
	:call Foo()

上の例は次のように表示する  >

	Nothing caught
	Caught "4711" in function Foo, line 4
	Caught "oops" in function Foo, line 10
	Nothing caught

実用的な例:  次のコマンド ":LineNumber" は、それが呼び出されたスクリプトや関数
中の行番号を表示する: >

	:function! LineNumber()
	:    return substitute(v:throwpoint, '.*\D\(\d\+\).*', '\1', "")
	:endfunction
	:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry
<
							*try-nested*
try条件文によって捕捉されない例外はそれを囲むtry条件文によって捕捉することがで
きる: >

	:try
	:  try
	:    throw "foo"
	:  catch /foobar/
	:    echo "foobar"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch /foo/
	:  echo "foo"
	:endtry

内側のtry条件文はこの例外を捕捉せず、finally節が実行されるだけである。そしてこ
の例外は外側のtry条件文で捕捉される。この例を実行すると "inner finally" と
"foo" が表示される。

							*throw-from-catch*
例外を捕捉した後、新しい例外を投げて他のcatch節で捕捉させることができる: >

	:function! Foo()
	:  throw "foo"
	:endfunction
	:
	:function! Bar()
	:  try
	:    call Foo()
	:  catch /foo/
	:    echo "Caught foo, throw bar"
	:    throw "bar"
	:  endtry
	:endfunction
	:
	:try
	:  call Bar()
	:catch /.*/
	:  echo "Caught" v:exception
	:endtry

これを実行すると "Caught foo, throw bar" と "Caught bar" が表示される。

							*rethrow*
Vimスクリプト言語には本物のrethrowはないが、代わりに "v:exception" を使うこと
ができる: >

	:function! Bar()
	:  try
	:    call Foo()
	:  catch /.*/
	:    echo "Rethrow" v:exception
	:    throw v:exception
	:  endtry
	:endfunction
<							*try-echoerr*
Note この方法はVimのエラーや割り込み例外を "rethrow" するためには使えない。Vim
の内部例外を偽装することはできないからである。それを行おうとするとエラー例外が
発生する。その状況を表す自分自身の例外を投げるべきである。独自のエラー例外値を
含むVimのエラー例外を発生させたい場合には、コマンド|:echoerr|を使うことができ
る: >

	:try
	:  try
	:    asdf
	:  catch /.*/
	:    echoerr v:exception
	:  endtry
	:catch /.*/
	:  echo v:exception
	:endtry

このコードを実行すると次が表示される

	Vim(echoerr):Vim:E492: Not an editor command:   asdf ~


後始末処理						*try-finally*

しばしばスクリプト中でグローバルな設定を変更し、最後に元の設定を復元することが
ある。しかしユーザがCTRL-Cを押してスクリプトを中断すると、設定が一貫しない状態
になってしまう。スクリプトの開発段階においても、エラーが発生したり、明示的に例
外を投げたが捕捉されなかった場合に、同じことが起こりうる。この問題は、try条件
文を使ってfinally節で設定を復元することで解決できる。finally節は、通常の制御フ
ロー・エラー時・明示的な ":throw" 時・割り込み時に実行されることが保証されてい
る。(Note try条件文の内側で発生したエラーと割り込みは例外に変換される。これら
が捕捉されなかったときには、finally節の実行の後にスクリプトの実行が停止する。)
例: >

	:try
	:  let s:saved_ts = &ts
	:  set ts=17
	:
	:  " Do the hard work here.
	:
	:finally
	:  let &ts = s:saved_ts
	:  unlet s:saved_ts
	:endtry

関数やスクリプトの一部でグローバルな設定を変更し、その関数・スクリプトの失敗時・
通常終了時に設定を復元する必要があるときは、必ず局所的にこの手法を使うべきであ
る。

							*break-finally*
":continue", ":break", ":return", ":finish" などによってtryブロックやcatch節を
抜けるときも後始末処理が働く。
   例: >

	:let first = 1
	:while 1
	:  try
	:    if first
	:      echo "first"
	:      let first = 0
	:      continue
	:    else
	:      throw "second"
	:    endif
	:  catch /.*/
	:    echo v:exception
	:    break
	:  finally
	:    echo "cleanup"
	:  endtry
	:  echo "still in while"
	:endwhile
	:echo "end"

上の例を実行すると "first", "cleanup", "second", "cleanup", "end" と表示される:
>
	:function! Foo()
	:  try
	:    return 4711
	:  finally
	:    echo "cleanup\n"
	:  endtry
	:  echo "Foo still active"
	:endfunction
	:
	:echo Foo() "returned by Foo"

上の例を実行すると "cleanup" と "4711 returned by Foo" が表示される。finally節
に余計な ":return" を書く必要はない。(そうすると戻り値が上書きされてしまう)

							*except-from-finally*
finally節で ":continue", ":break", ":return", ":finish", ":throw" を使うことは
可能である。しかしそうするとtry条件文の後始末を破棄してしまうことになるので推
奨されていない。しかし、当然、finally節の中で割り込みとエラー例外が発生するこ
とはありうる。
finally節におけるエラーにより、割り込みが正しく動作しなくなる例: >

	:try
	:  try
	:    echo "Press CTRL-C for interrupt"
	:    while 1
	:    endwhile
	:  finally
	:    unlet novar
	:  endtry
	:catch /novar/
	:endtry
	:echo "Script still running"
	:sleep 1

失敗する可能性のあるコマンドをfinally節に書く必要があるときは、それらのコマン
ドにより発生するエラーを捕捉したり無視したりすることについて考えること。
|catch-errors| と |ignore-errors| を参照。


エラーを変更する					*catch-errors*

特定のエラーを捕捉するには、監視したいコードをtryブロックに入れ、そのエラー
メッセージに対するcatch節を加えるだけでよい。try条件節が存在すると全てのエラー
は例外に変換される。そのため、メッセージはまったく表示されず、|v:errmsg|は設定
されない。":catch" コマンドに対する正しい正規表現を作るには、エラー例外のフォー
マットがどのようなものか知っていなければならない。
   エラー例外は次のフォーマットを持つ: >

	Vim({cmdname}):{errmsg}
または >
	Vim:{errmsg}

{cmdname}は失敗したコマンド名である。2番目の形式はコマンド名が不明のとき用いら
れる。{errmsg}は、そのエラーがtry条件文の外で発生したときに通常表示されるエラー
メッセージである。エラーメッセージは必ず大文字の "E" で始まり、その後に2,3桁の
エラー番号、コロン、スペースが続く。

例:

次のコマンドを実行すると、 >
	:unlet novar
通常次のエラーメッセージが表示される  >
	E108: No such variable: "novar"
これはtry条件文の中では例外に変換される >
	Vim(unlet):E108: No such variable: "novar"

次のコマンドを実行すると、 >
	:dwim
通常次のエラーメッセージが表示される  >
	E492: Not an editor command: dwim
これはtry条件文の中では例外に変換される >
	Vim:E492: Not an editor command: dwim

":unlet" の全てのエラーを次によって捕捉できる >
	:catch /^Vim(unlet):/
また、全てのミススペルされたコマンドのエラーは次で捕捉できる  >
	:catch /^Vim:E492:/

複数のコマンドによって同一のエラーメッセージが表示される場合もある: >
	:function nofunc
と  >
	:delfunction nofunc
は両方とも次のエラーメッセージを表示する。
	E128: Function name must start with a capital: nofunc
これはtry条件節の中では例外に変換される。それぞれ >
	Vim(function):E128: Function name must start with a capital: nofunc
または  >
	Vim(delfunction):E128: Function name must start with a capital: nofunc
となる。どのコマンドによって発生したかに関係なくこのエラーを捕捉するには、次の
正規表現を使う: >
	:catch /^Vim(\a\+):E128:/

複数のエラーメッセージを表示するコマンドもある:  >
	:let x = novar
は次のエラーメッセージを表示する: >
	E121: Undefined variable: novar
	E15: Invalid expression:  novar
最初のエラーメッセージのみが例外の値として使われる。それが最も限定的なメッセー
ジだからである(|except-several-errors|を参照)。これは次のようにして捕捉できる
>
	:catch /^Vim(\a\+):E121:/

"nofunc" という名前に関係したエラー全てを捕捉するには >
	:catch /\<nofunc\>/

コマンド ":write" と ":read" による全てのVimエラーを捕捉するには >
	:catch /^Vim(\(write\|read\)):E\d\+:/

全てのVimエラーを捕捉するには次の正規表現を使う >
	:catch /^Vim\((\a\+)\)\=:E\d\+:/
<
							*catch-text*
NOTE: エラーメッセージの本文によって捕捉しようとしてはならない >
	:catch /No such variable/
こうすると英語の環境では動作するが、コマンド |:language|により他の言語を使って
いるユーザの環境では動作しなくなる。しかし、コメントとしてメッセージテキストを
引用することは役に立つ: >
	:catch /^Vim(\a\+):E108:/   " No such variable

エラーを無視する					*ignore-errors*

特定のコマンドで発生したエラーを捕捉すれば、エラーを無視することができる: >

	:try
	:  write
	:catch
	:endtry

しかしこの単純な形は使わないよう強く推奨されている。なぜなら、これはあなたが望
むより多くの例外を捕捉してしまうからである。":write" コマンドを使うと自動コマ
ンドが実行され、書き込みとは関係ないエラーが発生する可能性がある。例えば: >

	:au BufWritePre * unlet novar

このようなエラーの中には、スクリプトの作者が責任を負わないものもある: つまり、
スクリプトのユーザがそのようなオートコマンドを定義している場合である。その
場合、上の例のようにすると、ユーザからエラーを隠してしまうことになる。エラーを
無視するには、次のようにした方がよい >

	:try
	:  write
	:catch /^Vim(write):/
	:endtry

これは書き込みエラーだけを捕捉する。つまり、あなたが意図的に無視したいエラーだ
けである。

オートコマンドを発生させないような1つのコマンドに対しては、":silent!" を使えば
エラーを例外に変換すること自体を抑制させることができる: >
	:silent! nunmap k
これはtry条件文が有効なときも機能する。


割り込みを捕捉する					*catch-interrupt*

有効なtry条件文内では、割り込み(CTRL-C)は例外 "Vim:Interrupt" に変換される。こ
れを他の例外と同様に捕捉することができる。するとそのスクリプトは停止しない。
   例: >

	:function! TASK1()
	:  sleep 10
	:endfunction

	:function! TASK2()
	:  sleep 20
	:endfunction

	:while 1
	:  let command = input("Type a command: ")
	:  try
	:    if command == ""
	:      continue
	:    elseif command == "END"
	:      break
	:    elseif command == "TASK1"
	:      call TASK1()
	:    elseif command == "TASK2"
	:      call TASK2()
	:    else
	:      echo "\nIllegal command:" command
	:      continue
	:    endif
	:  catch /^Vim:Interrupt$/
	:    echo "\nCommand interrupted"
	:    " 例外捕捉。次のプロンプトから継続する。
	:  endtry
	:endwhile

ここでCTRL-Cを押すとタスクに割り込むことができる。その後スクリプトは新しいコマ
ンドを要求する。プロンプトでCTRL-Cを押すとスクリプトが終了する。

スクリプト中の特定の行でCTRL-Cが押されたとき何が起こるかをテストするにはデバッ
グモードを使い、その行の上で|>quit|や|>interrupt|コマンドを使う。
|debug-scripts|を参照。


全てを捕捉する						*catch-all*

次のコマンド >

	:catch /.*/
	:catch //
	:catch

は全てをエラー例外・割り込み例外・|:throw|コマンドにより明示的に投げられた例外
の捕捉する。これは、スクリプトのトップレベルで、予期しないことを捕捉するために
役に立つ。
   例: >

	:try
	:
	:  " ここで難しいことをする
	:
	:catch /MyException/
	:
	:  " 既知の問題を制御する
	:
	:catch /^Vim:Interrupt$/
	:    echo "Script interrupted"
	:catch /.*/
	:  echo "Internal error (" . v:exception . ")"
	:  echo " - occurred at " . v:throwpoint
	:endtry
	:" スクリプトの終わり

Note: 全てを捕捉すると、期待していた以上のものを捕捉してしまうかもしれない。そ
れゆえ、":catch" コマンドの引数に正規表現を指定することにより、自分が本当に制
御できる問題だけを捕捉することが強く推奨されている。
全てを捕捉してしまうと、CTRL-C を押してスクリプトを中断することがほぼ不可能に
なってしまうことがある。その例: >

	:while 1
	:  try
	:    sleep 1
	:  catch
	:  endtry
	:endwhile


例外とオートコマンド				*except-autocmd*

オートコマンドの実行中に例外を使うこともできる。例: >

	:autocmd User x try
	:autocmd User x   throw "Oops!"
	:autocmd User x catch
	:autocmd User x   echo v:exception
	:autocmd User x endtry
	:autocmd User x throw "Arrgh!"
	:autocmd User x echo "Should not be displayed"
	:
	:try
	:  doautocmd User x
	:catch
	:  echo v:exception
	:endtry

上の例を実行すると "Oops!" と "Arrgh!" が表示される。

							*except-autocmd-Pre*
いくつかのコマンドでは、それ自身が実行される前にオートコマンドが実行される。
例外が発生し、それが一連のオートコマンドの中で捕捉されない場合、一連の自動コマ
ンドと、その引き金となったコマンドは破棄され、例外がそのコマンドを呼んだ位置へ
伝播する。
   例: >

	:autocmd BufWritePre * throw "FAIL"
	:autocmd BufWritePre * echo "Should not be displayed"
	:
	:try
	:  write
	:catch
	:  echo "Caught:" v:exception "from" v:throwpoint
	:endtry

ここで ":write" コマンドは現在編集しているファイルを書き込まない ('modified'
を確認すればわかる)。BufWritePreのオートコマンドで発生した例外により、":write"
が破棄されたためである。そしてその例外は捕捉され、次を表示する: >

	Caught: FAIL from BufWrite Auto commands for "*"
<
							*except-autocmd-Post*
いくつかのコマンドでは、それ自身が実行された後でオートコマンドが実行される。引
き金となったコマンド自身が失敗して、それが有効なtry条件文の内側にあった場合、
自動コマンドはスキップされ、エラー例外が発生する。その例外は、コマンドを呼んだ
位置で捕捉することができる。
   例: >

	:autocmd BufWritePost * echo "File successfully written!"
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  echo v:exception
	:endtry

この例は次を表示する: >

	Vim(write):E212: Can't open file for writing (/i/m/p/o/s/s/i/b/l/e)

引き金となったコマンドが失敗したときでさえもオートコマンドを実行したいという場
合は、catch節の中でそのイベントを引き起こすことできる。
   例: >

	:autocmd BufWritePre  * set noreadonly
	:autocmd BufWritePost * set readonly
	:
	:try
	:  write /i/m/p/o/s/s/i/b/l/e
	:catch
	:  doautocmd BufWritePost /i/m/p/o/s/s/i/b/l/e
	:endtry
<
":silent!" を使うこともできる: >

	:let x = "ok"
	:let v:errmsg = ""
	:autocmd BufWritePost * if v:errmsg != ""
	:autocmd BufWritePost *   let x = "after fail"
	:autocmd BufWritePost * endif
	:try
	:  silent! write /i/m/p/o/s/s/i/b/l/e
	:catch
	:endtry
	:echo x

上の例は "after fail" を表示する。

引き金となったコマンドが失敗しなかった場合、オートコマンドから発生した例外は、
元のコマンドを呼んだ位置から捕捉できる: >

	:autocmd BufWritePost * throw ":-("
	:autocmd BufWritePost * echo "Should not be displayed"
	:
	:try
	:  write
	:catch
	:  echo v:exception
	:endtry
<
							*except-autocmd-Cmd*
いくつかのコマンドでは、通常の処理を一連のオートコマンドで置き換えることができ
る。そのコマンド列で発生した例外は元のコマンドの呼び出し位置で捕捉できる。
   例: ":write" コマンドでは、例外が発生したとき、呼び出し側は実際にファイルが
書き込まれたのかどうかを知ることができない。これを教える必要があるときは、なん
らかの手段を使わねばならない。 >

	:if !exists("cnt")
	:  let cnt = 0
	:
	:  autocmd BufWriteCmd * if &modified
	:  autocmd BufWriteCmd *   let cnt = cnt + 1
	:  autocmd BufWriteCmd *   if cnt % 3 == 2
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   write | set nomodified
	:  autocmd BufWriteCmd *   if cnt % 3 == 0
	:  autocmd BufWriteCmd *     throw "BufWriteCmdError"
	:  autocmd BufWriteCmd *   endif
	:  autocmd BufWriteCmd *   echo "File successfully written!"
	:  autocmd BufWriteCmd * endif
	:endif
	:
	:try
	:	write
	:catch /^BufWriteCmdError$/
	:  if &modified
	:    echo "Error on writing (file contents not changed)"
	:  else
	:    echo "Error after writing"
	:  endif
	:catch /^Vim(write):/
	:    echo "Error on writing"
	:endtry

バッファに変更を行った後でこのスクリプトを数回sourceすると、1回目は次のように
表示される >
	File successfully written!
2回目は >
	Error on writing (file contents not changed)
3回目は >
	Error after writing
以下同様。

							*except-autocmd-ill*
異なるイベントに対するオートコマンドにわたってtry条件文を展開することはできな
い。以下のコードは不正である: >

	:autocmd BufWritePre  * try
	:
	:autocmd BufWritePost * catch
	:autocmd BufWritePost *   echo v:exception
	:autocmd BufWritePost * endtry
	:
	:write


例外の階層と付加情報つき例外				*except-hier-param*

プログラミング言語の中には例外クラスを階層化したり、例外クラスのオブジェクトに
付加的な情報を渡すことができるものがある。これと似たことをVimでもできる。
階層構造を持った例外を投げるには、各部分をコロンで区切った完全なクラス名を投げ
ればよい。例えば、数学ライブラリ内でオーバーフローが発生したときに
"EXCEPT:MATHERR:OVERFLOW" を投げる。
例外クラスに付加的な情報を与えたいときは、それを括弧の中に書く。例えば、
"myfile" の書き込み中にエラーが発生したときに文字列 "EXCEPT:IO:WRITEERR(myfile)"
を投げる。
":catch" コマンドにおいて適切な正規表現を使えば、階層の基底クラスや派生クラスを
捕捉できる。括弧の中の付加情報は、":substitute" コマンドを使って|v:exception|か
ら切り出すことができる。
例: >

	:function! CheckRange(a, func)
	:  if a:a < 0
	:    throw "EXCEPT:MATHERR:RANGE(" . a:func . ")"
	:  endif
	:endfunction
	:
	:function! Add(a, b)
	:  call CheckRange(a:a, "Add")
	:  call CheckRange(a:b, "Add")
	:  let c = a:a + a:b
	:  if c < 0
	:    throw "EXCEPT:MATHERR:OVERFLOW"
	:  endif
	:  return c
	:endfunction
	:
	:function! Div(a, b)
	:  call CheckRange(a:a, "Div")
	:  call CheckRange(a:b, "Div")
	:  if (a:b == 0)
	:    throw "EXCEPT:MATHERR:ZERODIV"
	:  endif
	:  return a:a / a:b
	:endfunction
	:
	:function! Write(file)
	:  try
	:    execute "write" fnameescape(a:file)
	:  catch /^Vim(write):/
	:    throw "EXCEPT:IO(" . getcwd() . ", " . a:file . "):WRITEERR"
	:  endtry
	:endfunction
	:
	:try
	:
	:  " 計算やI/Oを行う
	:
	:catch /^EXCEPT:MATHERR:RANGE/
	:  let function = substitute(v:exception, '.*(\(\a\+\)).*', '\1', "")
	:  echo "Range error in" function
	:
	:catch /^EXCEPT:MATHERR/	" catches OVERFLOW and ZERODIV
	:  echo "Math error"
	:
	:catch /^EXCEPT:IO/
	:  let dir = substitute(v:exception, '.*(\(.\+\),\s*.\+).*', '\1', "")
	:  let file = substitute(v:exception, '.*(.\+,\s*\(.\+\)).*', '\1', "")
	:  if file !~ '^/'
	:    let file = dir . "/" . file
	:  endif
	:  echo 'I/O error for "' . file . '"'
	:
	:catch /^EXCEPT/
	:  echo "Unspecified error"
	:
	:endtry

エラー時やCTRL-Cを押したときにVim自身によって投げられる例外は平坦な階層になっ
ている: つまりこれらは全て "Vim" クラスに入っている。ユーザは接頭辞 "Vim" をつ
けた例外を投げることはできない。これらはVim用に予約されている。
Vimのエラー例外は失敗したコマンドの名前(わかっているならば)という付加情報がつ
いている。|catch-errors|を参照。


変わった特性
							*except-compat*
例外制御のコンセプトは、例外を引き起こしたコマンドは即座に異常終了し、制御が
finally節またはcatch節に移るという前提に基づいている。

Vimスクリプト言語では、エラーの後もスクリプトや関数が処理を続行する場合がある。
"abort" フラグのない関数や、":silent!" をつけて実行されたコマンドでは、制御は
次の行、そして関数の外へ移り、制御フローは最外側の ":endwhile" や ":endif" の
次の行へ移る。一方、エラーは例外と同様に捕捉できるべきである (つまり、即座に異
常終了することが要求される)。

この問題は、try条件文が有効なときだけエラーを例外に変換し、(":silent!" で抑制
されていない限り)即座に異常終了することで解決される。(エラー)例外は有効なtry条
件文でのみ捕捉可能であるため、これはなんら制約とはならない。エラーを捕捉せずに
即座に終了してほしいなら、単にcatch節を持たないtry条件文を使えばよい。(finally
節を指定すれば、終了の前に後始末処理を行うことができる)

有効なtry条件文がないとき、即座の異常終了でなく、通常の異常終了と継続が行われ
る。これによってVim6.1以前用に書かれたスクリプトの互換性を保証している。

しかし、有効なtry条件文の中から、例外処理コマンドを使っていない既存のスクリプ
トをsourceする(またはその関数の1つを呼ぶ)と、エラー発生時に既存のスクリプトの
制御フローが変わるかもしれない。エラー発生時に即座に異常終了し、新しい方のスク
リプト内でエラーを捕捉できる。しかしsourceされたスクリプトが ":silent!" コマン
ドでエラーメッセージを抑制していた場合(それが適切なスクリプトなら|v:errmsg|を
見ることでエラーを確認している)、実行パスは変わらない。そのエラーは例外に変換
されない(|:silent|を参照)。これが起こる残りのただ1つの原因は、エラーに関心を
払っていなく、エラーメッセージを表示させるスクリプトである。おそらく新しいスク
リプトからそのようなコードを使いたいとは思わないだろう。

							*except-syntax-err*
例外処理コマンドにおける構文エラーは、それが属するtry条件文のどの ":catch" コ
マンドでも決して捕捉されない。しかしfinally節は実行される。
   例: >

	:try
	:  try
	:    throw 4711
	:  catch /\(/
	:    echo "in catch with syntax error"
	:  catch
	:    echo "inner catch-all"
	:  finally
	:    echo "inner finally"
	:  endtry
	:catch
	:  echo 'outer catch-all caught "' . v:exception . '"'
	:  finally
	:    echo "outer finally"
	:endtry

上の例を実行すると次が表示される: >
    inner finally
    outer catch-all caught "Vim(catch):E54: Unmatched \("
    outer finally
元の例外は破棄され、代わりにエラー例外が投げられる。

{訳注: throw 4711により例外が発生したが、その後の catch /\(/ に構文エラーがある
       ためエラー例外が発生し、最初の例外は破棄された。}

							*except-single-line*
コマンド ":try", ":catch", ":finally", ":endtry" は1行の中に書くことができる。
しかし構文エラーがあったとき "catch" の行を認識するのが難しくなるので、避けた
方がよい。
   例: >
	:try | unlet! foo # | catch | endtry
この例は ":unlet!" の後に余計な文字があるためエラー例外を発生させる。そして
":catch" と ":endtry" が認識されないため、この例外は破棄され、"E488: Trailing
characters" のメッセージが表示される。

							*except-several-errors*
1つのコマンドにより複数のエラーが発生した場合、普通は最初のエラーメッセージが
最も限定的であるため、それがエラー例外に変換される。
   例: >
	echo novar
は次を発生させる: >
	E121: Undefined variable: novar
	E15: Invalid expression: novar
try条件文の中のエラー例外の値は次になる: >
	Vim(echo):E121: Undefined variable: novar
<							*except-syntax-error*
しかし、同じコマンドにおいて通常のエラーの後に構文エラーが検出されたときは、構
文エラーが例外として投げられる。
   例: >
	unlet novar #
これは次を発生させる: >
	E108: No such variable: "novar"
	E488: Trailing characters 
try条件文の中のエラー例外の値は次になる: >
	Vim(unlet):E488: Trailing characters
この理由は、構文エラーによってユーザが予期していない実行パスになってしまうかも
しれないためである。例: >
	try
	    try | unlet novar # | catch | echo v:exception | endtry
	catch /.*/
	    echo "outer catch:" v:exception
	endtry
これは "outer catch: Vim(unlet):E488: Trailing characters" を表示し、次にエラー
メッセージ "E600: Missing :endtry" が表示される。|except-single-line|を参照。

==============================================================================
9. 例							    *eval-examples*

16進数で表示する ~
>
  :" 関数 Nr2Bin() は数値の2進文字列表現を返す。
  :func Nr2Bin(nr)
  :  let n = a:nr
  :  let r = ""
  :  while n
  :    let r = '01'[n % 2] . r
  :    let n = n / 2
  :  endwhile
  :  return r
  :endfunc

  :" 関数 String2Bin() は文字列中の各文字を2進文字列に変換して、ハイフン(-)で
  :" 区切って返す。
  :func String2Bin(str)
  :  let out = ''
  :  for ix in range(strlen(a:str))
  :    let out = out . '-' . Nr2Bin(char2nr(a:str[ix]))
  :  endfor
  :  return out[1:]
  :endfunc

使い方の例: >
  :echo Nr2Bin(32)
結果: "100000" >
  :echo String2Bin("32")
結果: "110011-110010"



行をソート(並べ替え)する (by Robert Webb) ~

以下は、指定した比較関数を使って行をソートする例である。 >

  :func SortBuffer()
  :  let lines = getline(1, '$')
  :  call sort(lines, function("Strcmp"))
  :  call setline(1, lines)
  :endfunction

ワンライナーにすると次のようになる: >
  :call setline(1, sort(getline(1, '$'), function("Strcmp")))

scanf() の代替 ~
							*sscanf*
Vimにはsscanf()に相当する関数が無い。行の一部を取り出す必要がある場合には、
matchstr()やsubstitute()を使えば実現できる。以下の例は、"foobar.txt, 123, 45"
というような行から、ファイル名と行番号とカラム番号を取り出す方法を示している。
>
   :" 正規表現を設定
   :let mx='\(\f\+\),\s*\(\d\+\),\s*\(\d\+\)'
   :" 正規表現全体にマッチする部分を取り出す
   :let l = matchstr(line, mx)
   :" マッチ結果から各要素を取り出す
   :let file = substitute(l, mx, '\1', '')
   :let lnum = substitute(l, mx, '\2', '')
   :let col = substitute(l, mx, '\3', '')

入力は変数 "line"、結果は "file" と "lnum" と "col" に格納される(このアイデア
はMichael Geddesによる)。


辞書からscriptnamesを取り出す ~
						*scriptnames-dictionary*
コマンド|:scriptnames|により今までにsourceされた全てのスクリプトファイルのリス
トを取得することができる。これと等価な関数や変数は存在しない(めったに必要にな
らないからである)。そのような場合には次のコードが利用できる: >
    " ":scriptnames" の出力を変数scriptnames_outputに入れる。
    let scriptnames_output = ''
    redir => scriptnames_output
    silent scriptnames
    redir END
    
    " 出力を行のリストに分割し、各行をパースする。辞書 "scripts" に要素を追加
    " する。
    let scripts = {}
    for line in split(scriptnames_output, "\n")
      " 空行以外に対して実行
      if line =~ '\S'
	" 行内の最初の番号を取得
        let nr = matchstr(line, '\d\+')
	" ファイル名を取得。スクリプト番号" 123: "を削除。
        let name = substitute(line, '.\+:\s*', '', '')
	" 辞書に要素を追加
        let scripts[nr] = name
      endif
    endfor
    unlet scriptnames_output

==============================================================================
10. +eval機能が無効					*no-eval-feature*

コンパイル時に|+eval|機能が無効とされている場合、全ての式評価(eval)コマンドは
提供されない。その場合、Vimスクリプトが全ての種類のエラーを引き起こすことを避
ける為、":if" と ":endif" は解釈される。":if" とそれに対応する ":endif" に挟ま
れた内容は無視される。":if" の後に続く引数も無視される。この ":if" コマンドは
ネスティングが可能である。しかし必ず行の先頭に書かれている必要がある。":else"
コマンドは認識されない。

|+eval|機能が存在しなかった場合、どのようにコマンドが実行を免れるかの例: >

	:if 1
	:  echo "Expression evaluation is compiled in"
	:else
	:  echo "You will _never_ see this message"
	:endif

==============================================================================
11. サンドボックス				*eval-sandbox* *sandbox* *E48*

オプション 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr',
'statusline', 'foldtext' はサンドボックスの中で評価される。これによって、悪質
な副作用を持つ式からの保護がなされている。これによって、これらのオプションが
モードラインから設定された場合にある種の安全性がもたらされている。tagsファイル
からのコマンドが実行されたときとコマンドラインでのCTRL-R =に対してもサンドボッ
クスが使われる。
コマンド|:sandbox|に対してもサンドボックスが使われる。

サンドボックス内では以下の事が禁止される:
	- バッファの変更
	- マッピング、オートコマンド、関数、ユーザ定義コマンドの定義・変更
	- ある種のオプションの設定 (|option-summary|を参照)
	- ある種のVim定義済変数(v:)の設定 (|v:var|を参照)  *E794*
	- シェルコマンドの実行
	- ファイルの読み書き
	- 他のバッファへの移動・ファイルを開く
	- Python, Perl等のコマンドの実行
これは100%安全と保証するものではない。しかし、ある種の攻撃を防ぐ事はできるはずで
ある。

							*:san* *:sandbox*
:san[dbox] {cmd}	サンドボックス内で{cmd}を実行する。モードラインから設
			定された可能性のあるオプションを評価するために使える。
			例: 'foldexpr'.

							*sandbox-option*
いくつかのオプションは式を含んでいる。その式を評価するときはセキュリティ上の危
険性を回避するためにサンドボックス内で行わねばならない。しかしサンドボックスに
は制限があるので、これはそのオプションが安全でない場所で設定されたときのみ行わ
れる。ここで「安全でない」とは次の場合をいう:
- カレントディレクトリの .vimrc や .exrc を source するとき
- サンドボックス内で実行している最中
- モードラインから設定された値

Note サンドボックス内でオプションの値を退避し、それから復元した場合、そのオプ
ションはやはりサンドボックス内で設定されたものとマークされる。

==============================================================================
12. テキストロック						*textlock*

いくつか状況においては、バッファを変更する・他のウィンドウへジャンプするなど、
Vimの現在の処理を混乱させたり破壊してしまうような動作は禁止される。これはVimが
実際に他の何かをしているときに起こることに対して当てはまる。例えば、
'balloonexpr' の評価は、マウスカーソルがある位置に留まっているどんなときにでも
起こりうる。

テキストロックが有効になっているときは、以下の事が禁止される:
	- バッファの変更
	- 他のバッファやウィンドウへの移動
	- 他のファイルを開く
	- ウィンドウを閉じる。Vimを終了する。
	- など。


 vim:tw=78:ts=8:ft=help:norl:
