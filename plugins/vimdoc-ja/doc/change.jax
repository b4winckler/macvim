*change.txt*    For Vim バージョン 7.3.  Last change: 2013 Mar 19


		  VIMリファレンスマニュアル    by Bram Moolenaar


このファイルでは、テキストを削除したり変更するコマンドの説明をする。この文章の
中では、「テキストを変更する」とは、一つのコマンドでテキストを削除し、別のテキ
ストに置き換えることを意味する。これらのコマンドは全てアンドゥできる。非Exコマ
ンドはコマンド "." で繰り返すことができる。

1. テキストの削除		|deleting|
2. 削除と挿入			|delete-insert|
3. 単純な変更			|simple-change|		*changing*
4. 複雑な変更			|complex-change|
   4.1 フィルタコマンド		   |filter|
   4.2 置換			   |:substitute|
   4.3 検索と置換		   |search-replace|
   4.4 タブの変換		   |change-tabs|
5. テキストのコピーと移動	|copy-move|
6. テキストの整形		|formatting|
7. テキストのソート             |sorting|

テキストの挿入に関しては |insert.txt| を参照。

==============================================================================
1. テキストの削除					*deleting* *E470*

["x]<Del>	または					*<Del>* *x* *dl*
["x]x			カーソル下から後の [count] 文字を [レジスタ x に入れ]
			削除する (行単位ではない|linewise|)。"dl" と同じであ
                        る。<Del> キーには [count] が使えない。代わりに、
                        [count] の最後の文字を削除する {訳注: 123<Del>と押すと
                        3が消え12になる}。<Del> キーが思ったように動作しない
			ときは、|:fixdel| を参照。<EOL> の削除 (行の連結) につ
			いては、'whichwrap' を参照。 {Vi では <Del> が使えない}

							*X* *dh*
["x]X			カーソルから前の [count] 文字を [レジスタ x に入れ] 削
			除する (行単位ではない|linewise|)。"dh" と同じである。
                        'whichwrap' も参照。

							*d*
["x]d{motion}		{motion} でカーソルが動く範囲のテキストを [レジスタ x
			に入れ] 削除する。例外については以下を参照。

							*dd*
["x]dd			[count] 行を [レジスタ x に入れ] 削除する (行単位
			|linewise|)。

							*D*
["x]D			カーソル下から行の最後までの文字と、[count]-1 行を、
			[レジスタ x に入れ] 削除する。"d$" と同義
			(行単位ではない|linewise|)。
			'cpoptions' にフラグ '#' が入っているとカウントは無視
			される。

{Visual}["x]x	または					*v_x* *v_d* *v_<Del>*
{Visual}["x]d	または
{Visual}["x]<Del>	ビジュアル選択されたテキストを [レジスタ x に入れ] 削
			除する({Visual} については |Visual-mode| を参照)。{Vi
			にはない}

{Visual}["x]CTRL-H   または				*v_CTRL-H* *v_<BS>*
{Visual}["x]<BS>	選択モード内で: ビジュアル選択されたテキストを [レジス
			タ x に入れ] 削除する。

{Visual}["x]X	または					*v_X* *v_D* *v_b_D*
{Visual}["x]D		ビジュアル選択された行を [レジスタ x に入れ] 削除する
			({Visual} については |Visual-mode| を参照)。矩形ビジュ
			アルモードでは、"D" はビジュアル選択されたテキストと行
			末までの全てのテキストを削除する。 {Vi にはない}

					*:d* *:de* *:del* *:delete* *:dl*
:[range]d[elete] [x]	[range] 行 (既定値: 現在行) を [レジスタ x に入れ] 削
			除する。

:[range]d[elete] [x] {count}
			[range] 行目 (既定: 現在行 |cmdline-ranges|) から
			{count} 行を [レジスタ x に入れ] 削除する。

これらのコマンドはテキストを削除する。これらは (`:d` を除いて) コマンド `.` で
繰り返したり、アンドゥできる。テキストのブロックを削除するには、ビジュアルモー
ドを使う。レジスタの説明については、|registers| を参照。

コマンド "d{motion}" に関する例外: 移動が行単位でなく、移動の開始点と終了点が
同じ行になく、移動の開始点の前と終了点の後に空白しかない場合には、削除は行単位
となる。このときユーザは空白のみの行が残ると思うかもしれないが、共に削除され
る。削除を文字単位に強制したい場合は |o_v| を使うこと。

オプション 'cpoptions' がフラグ 'E' を含んでいるときは、テキストの空の範囲を削
除しようとすると (例えば、1列目での "d0")、エラーになる。

							*J*
J			[count] 行を連結する (最低は 2 行)。インデントを削除し、
			空白を最大 2 個まで挿入する (以下を参照)。

							*v_J*
{Visual}J		ビジュアル選択された行を連結する (最低は 2 行)。インデ
			ントを削除し、空白を最大 2 個まで挿入する (以下を参照)
			{Vi にはない}

							*gJ*
gJ			[count] 行を連結する (最低は 2 行)。空白の挿入や削除を
			行わない。 {Vi にはない}

							*v_gJ*
{Visual}gJ		ビジュアル選択された行を連結する (最低は 2 行)。空白の
			挿入や削除を行わない。 {Vi にはない}

							*:j* *:join*
:[range]j[oin][!] [flags]
                        [range] 行を連結する。"J" と同様だが、[!] と共に使うと
			空白の挿入や削除を行わない。[range] の開始点と終了点が
			同じときは、このコマンドは何もしない。既定の動作では、
			現在行を次行と連結する。 {Vi にはない}
                        [flags]については|ex-flags|を参照。

:[range]j[oin][!] {count} [flags]
			[range] 行目 (既定では現在行 |cmdline-ranges|) からの
			{count} 行を連結する。"J" と同様だが、[!] と共に使うと
			空白の挿入や削除を行わない。 {Vi にはない}
                        [flags]については|ex-flags|を参照。

これらのコマンドは、行の間の <EOL> を削除する。この結果、複数行が1行に連結され
る。これらのコマンド (`:j` 以外) は、繰り返しやアンドゥができる。

これらのコマンド ("gJ" 以外) は <EOL> の場所に空白を1個挿入する。ただし行末に
空白が付いていたり、次の行が ')' で始まるときは挿入しない。これらのコマンド
("gJ" 以外) は次行の先頭あたりにある空白を全て削除する。オプション
'joinspaces' がオンのときは、これらのコマンドは '.', '!', '?' の後に2個の空白
を挿入する (しかし 'cpoptions' がフラグ 'j' を含んでいるときは、2個の空白は
'.' の後にしか挿入しない)。
'formatoptions' のフラグ 'M' と 'B' は、マルチバイト文字の前後に空白を挿入する
ときの動作を変更する |fo-table|。


==============================================================================
2. 削除と挿入					*delete-insert* *replacing*

							*R*
R			置換モードに入る。打ち込んだ文字がカーソル下の既存の文
			字をどんどん置き換えていく。入力されたテキストを
			[count]-1 回繰り返す。詳細は |Replace-mode| を参照。

							*gR*
gR			仮想置換モードに入る。打ち込んだ文字が画面上の既存の文
			字をどんどん置き換えていく。そのため <Tab> は数文字を
			一回で置き換えることができる。入力されたテキストを
			[count]-1 回繰り返す。詳細は |Virtual-Replace-mode| を
			参照。
			{Vimが |+vreplace| 機能付きでコンパイルされたときのみ
			有効}

							*c*
["x]c{motion}		{motion} のテキストを [レジスタ x にいれ] 削除し、挿入
			を始める。'cpoptions' がフラグ 'E' を含むときは、削除
			すべきテキストがないと (例えば、"cTx" でカーソルが 'x'
			の直後にあるとき)、エラーが発生し挿入モードは始まらな
			い (これはVi互換である)。
			'cpoptions' がフラグ 'E' を含まないときは、コマンド
			"c" は削除すべきテキストがなくても、必ず挿入モードを始
			める。

							*cc*
["x]cc			[count] 行を [レジスタ x に入れ] 削除し、挿入を始める
			(行単位|linewise|)。'autoindent' がオンのとき、最初の
			行のインデントを保持する。

							*C*
["x]C			カーソル位置から行の終わりまでと、[count]-1 行を [レジ
			スタ x に入れ] 削除し、挿入を始める。"c$" と同義である
			(行単位でない|linewise|)。

							*s*
["x]s			[count] 文字を [レジスタ x に入れ] 削除し、挿入を始め
			る (s は Substitute --置換 を意味する)。"cl" と同義で
			ある (行単位でない|linewise|)。

							*S*
["x]S			[count] 行を [レジスタ x に入れ] 削除し、挿入を始める。
			"cc" と同義である (行単位|linewise|)。

{Visual}["x]c	または					*v_c* *v_s*
{Visual}["x]s		ビジュアル選択されたテキストを [レジスタ x に入れ] 削
			除し、挿入を始める ({Visual} については |Visual-mode|
			を参照)。{Vi にはない}

							*v_r*
{Visual}["x]r{char}	ビジュアル選択されたテキストを全て {char} に置き換える。

							*v_C*
{Visual}["x]C		ビジュアル選択された行を [レジスタ x に入れ] 削除し、
			挿入を始める。矩形ビジュアルモードでは少し動作が違う
			|v_b_C|。
			{Vi にはない}
							*v_S*
{Visual}["x]S		ビジュアル選択された行を [レジスタ x に入れ] 削除し、
			挿入を始める ({Visual} については |Visual-mode| を参
			照)。{Vi にはない}
							*v_R*
{Visual}["x]R		現在のところ {Visual}["x]S と同じである。次のバージョ
			ンでは動作が変わるかもしれない。 {Vi にはない}

Note:
- 挿入モード、置換モードは <Esc> で終了できる。
- これらのモードでの他の特殊文字については、「テキストの挿入と置換」の章
  |mode-ins-repl| を参照。
- [count] の効果は、Vimが挿入モードや置換モードを抜けた後で発生する。
- 'cpoptions' がフラグ '$' を含んでいて、変更が1行以内である場合、Vimは削除さ
  れるテキストを表示しつづけ、最後に削除された文字の位置に '$' を置く。

レジスタに関する説明は |registers| を参照。

置換モードは挿入モードと似ているが、文字を打ち込むたびに一文字ずつ削除される点
が違う。行の最後に達すると、Vimはそれ以降は (挿入モードと同様に) 文字を追加す
る。置換モードでは、バックスペースキーは (もしあれば) 以前のテキストを復元する
(「テキストの挿入と置換」の章 |mode-ins-repl| を参照すること)。

						*cw* *cW*
特別な場合: "cw" と "cW" は、カーソルが単語の上にあるとき、単語のあとにつづく
空白を含めず、単語の末尾までを変更する("ce" と "cE" と同じ働きをする)。これは
Vimが "cw" を単語の変更(change-word)として解釈し、また「単語」にはあとに続く空
白は含まれないからである。 {Vi: あとに空白が続く空白上での "cw" は、最初の空白
のみを変更する。これは多分バグである。"dw" は全ての空白を削除するからだ。とに
かく、Vi風に動作させるときには 'cpoptions' にフラグ 'w' を含めること}

"cw" の変更範囲に単語の後の空白も含めたいときは、次のマップを使うこと。 >
	:map cw dwi
または "caw" を使う(|aw| を参照)。

							*:c* *:ch* *:change*
:{range}c[hange][!]	テキストを行単位で別のテキストと置き換える。
			"." のみを含む行を打ち込むことで置換を終了する。
			{range} なしの場合、現在行のみを変更する。
                        [!]をつけると、このコマンドを実行するときだけ
                        'autoindent' をトグルする。

==============================================================================
3. 単純な変更						*simple-change*

							*r*
r{char}			カーソル下の文字を {char} に置き換える。
			{char} が <CR> か <NL> のとき、文字は改行に置き換わる。
			文字を本当の <CR> に置き換えるには、CTRL-V <CR> を使う。
			CTRL-V <NL> は文字を <Nul> に置き換える。
			{Vi: CTRL-V <CR> は改行に置き換わり、何かの文字を <CR>
			に置き換えることはできない}

			{char} が CTRL-E または CTRL-Y のとき、ちょうど
			|i_CTRL-E| と |i_CTRL-Y| と同じように、下の行または上
			の行の文字が使われる。回数も指定することができるため、
			`10r<C-E>` は下の行から 10 文字をコピーすることになる。

			[count] を指定すると、[count] 文字が [count] 個の
			{char} に置き換わる。しかし {char} が <CR> か <NL> の
			場合、挿入される <CR> はただ1個である。"5r<CR>" は5文
			字を1個の改行に置き換える。
			{char} が <CR> か <NL> のとき、Vimは自動インデントを行
			う。これは置き換えるべき文字を削除した後 "i<CR><Esc>"
			を実行したような動作になる。
			{char} はダイグラフでもよい |digraph-arg|。
			|:lmap| のマッピングは {char} に適用される。Inlertモー
			ドでは、コマンド CTRL-^ を使ってマッピングを切り替えら
			れる |i_CTRL-^|。オプション 'encoding' がUnicodeの一種
			のときに composing character を使うことについては
			|utf-8-char-arg| を参照。

							*gr*
gr{char}		カーソル下の仮想文字を {char} に置き換える。このコマン
			ドはファイル上の空白ではなく、画面上の空白を置き換える。
			詳細は |gR| と |Virtual-Replace-mode| を参照。|r| と同
			様、回数を指定できる。
			{char} の入力方法は |r| と同様である。
			{Vimが |+vreplace| 機能付きでコンパイルされたときのみ
			有効}

							*digraph-arg*
|r| や |t| 等のノーマルモードコマンドの引数は、1個の文字である。オプション
'cpoptions' がフラグ 'D' を含まないとき、この文字はダイグラフ |digraphs| と同
様に入力できる。まず CTRL-K を打ち込み、次にダイグラフの2文字を入力する。
{Vimが |+digraphs| 機能付きでコンパイルされたときのみ有効}

							*case*
以下のコマンドは、アルファベットの大文字／小文字を切り替える。現在有効なロケー
ル |locale| が使われる。|:language| を参照。環境変数 LC_CTYPE の値に影響される。

							*~*
~			オプション 'tildeop' がオフのとき: カーソル下の文字の
			大文字／小文字を切り替え、カーソルを右に移動させる。
			[count] が指定されたときは、[count] 文字に作用する。
			{Vi: カウントが使えない}

~{motion}		オプション 'tildeop' がオンのとき: {motion} のテキスト
			の大文字／小文字を切り替える。 {Vi: チルダは operator
			として使用できない}

							*g~*
g~{motion}		{motion} のテキストの大文字／小文字を切り替える。
			{Vi にはない}

g~g~							*g~g~* *g~~*
g~~			現在行の大文字／小文字を切り替える。 {Vi にはない}

							*v_~*
{Visual}~		ビジュアル選択されたテキストの大文字／小文字を切り替え
			る({Visual} については |Visual-mode| を参照)。
			{Vi にはない}

							*v_U*
{Visual}U		ビジュアル選択されたテキストを大文字にする ({Visual}
			については |Visual-mode| を参照)。 {Vi にはない}

							*gU* *uppercase*
gU{motion}		{motion} のテキストを大文字にする。{Vi にはない}
			例: >
				:map! <C-F> <Esc>gUcw`]a
<			これは挿入モードで機能する。カーソルの前の単語を大文字
			にするときに CTRL-F を打ち込めばよい。単語は小文字で入
			力し、後から大文字にする方が楽だ。


gUgU							*gUgU* *gUU*
gUU			現在行を大文字にする。 {Vi にはない}

							*v_u*
{Visual}u		ビジュアル選択されたテキストを小文字にする ({Visual}
			については |Visual-mode| を参照)。 {Vi にはない}

							*gu* *lowercase*
gu{motion}		{motion} のテキストを小文字にする。 {Vi にはない}

gugu							*gugu* *guu*
guu			現在行を小文字にする。 {Vi にはない}

							*g?* *rot13*
g?{motion}		{motion} のテキストをRot13エンコードする。{Vi にはない}

							*v_g?*
{Visual}g?		ビジュアル選択されたテキストをRot13エンコードする
			({Visual}については |Visual-mode| を参照)。
			{Vi にはない}

g?g?							*g?g?* *g??*
g??			現在行をRot13エンコードする。 {Vi にはない}

各単語の最初の文字を大文字にする: >
	:s/\v<(.)(\w*)/\u\1\L\2/g

加算と減算 ~
							*CTRL-A*
CTRL-A			カーソルの下または後の数またはアルファベットに [count]
			を加える。 {Vi にはない}

							*CTRL-X*
CTRL-X			カーソルの下または後の数またはアルファベットから
			[count] を減じる。 {Vi にはない}

コマンド CTRL-A と CTRL-X は(符号付)10進数と符号なし8進／16進数、アルファベッ
トに対し機能する。この動作はオプション 'nrformats' に依存する。
- 'nrformats' が "octal" を含むときは、Vimは '0' で始まり、'8' や '9' を含まな
  い数字を8進数として取り扱う。他の数は10進数とみなされ、マイナス符号が付いて
  もよい。カーソルが数の上にあれば、コマンドはその数に適用される。そうでなけれ
  ば、カーソルの右の数に適用される。
- 'nrformats' が "hex" を含むときは、Vimは '0x' か '0X' で始まる数を16進数とし
  て取り扱う。その数の最も右の文字が大文字であるか小文字であるかによって、変更
  結果の16進数が大文字か小文字かが決定する。対象となった数にアルファベットが含
  まれない場合、Vimは前回の決定を使う。
- 'nrformats' が "alpha" を含むときは、Vimはカーソル下または後のアルファベット
  を変更する。これはアルファベットのインデックスつきのリストを作るときに便利で
  ある。

ゼロから始まる数 (全ての8進数、16進数を含む) に対して、Vimはできる限りその数の
文字数を保とうとする。"0077" 上で CTRL-A を使うと "0100" となり、"0x100" 上で
CTRL-X を使うと "0x0ff" となる。
1つだけ例外がある: ゼロで始まるが8進数でないとき('8' や '9' を含んでいるとき)、
'nrformats' が "octal" を含んでいるならば、結果が8進数とみなされないように、前
方のゼロは削除される。

Note: 'nrformats' が "octal" を含んでいるとき、0で始まる10進数は、8進数と区別
しづらいため、意図しない結果になる可能性がある。

コマンド CTRL-A はマクロ内でたいへん便利である。例: 番号付きリストを作るには、
次の方法を使う。

1. リストの最初の項目を作る。番号から始まるようにすること。
2. qa	     - レジスタ 'a' への記録を始める
3. Y	     - 項目をコピーする
4. p	     - 項目のコピーを最初の項目の後に貼り付ける
5. CTRL-A    - 番号を増やす
6. q	     - 記録をストップする
7. <count>@a - コピー、貼り付け、番号増加を <count> 回繰り返す


行を左右にずらす					*shift-left-right*

							*<*
<{motion}		{motion} の行を 'shiftwidth' 1個分左にずらす。

							*<<*
<<			[count] 行を 'shiftwidth' 1個分左にずらす。

							*v_<*
{Visual}[count]<	ビジュアル選択された行を、'shiftwidth' の [count] 個分
			左にずらす ({Visual} については |Visual-mode| を参照)。
			{Vi にはない}

							*>*
 >{motion}		{motion} の行を 'shiftwidth' 1個分右にずらす。

							*>>*
 >>			[count] 行を 'shiftwidth' 1個分右にずらす。

							*v_>*
{Visual}[count]>	ビジュアル選択された行を、'shiftwidth' の [count] 個分
			右にずらす ({Visual} については |Visual-mode| を参照)。
			{Vi にはない}

							*:<*
:[range]<		[range] の行を、'shiftwidth' 1個分左にずらす。
			'shiftwidth' の複数個分ずらすには、'<' を繰り返す。

:[range]< {count}	[range] (既定は現在行 |cmdline-ranges|) から始まる
			{count} 行を 'shiftwidth' 1個分左にずらす。
			'shiftwidth' の複数個分ずらすには、'<' を繰り返す。

:[range]le[ft] [indent]	[range] の行を左揃えする。行のインデントは [indent]
			(既定値は 0) に設定される。 {Vi にはない}

							*:>*
:[range]> [flags]	[range] の行を、'shiftwidth' 1個分右にずらす。
			'shiftwidth' の複数個分ずらすには、'>' を繰り返す。
                        [flags]については|ex-flags|を参照。

:[range]> {count} [flags]
                        [range] (既定は現在の行 |cmdline-ranges|) から始まる
			{count} 行を、'shiftwidth' 1個分右にずらす。
			'shiftwidth' の複数個分ずらすには、'>' を繰り返す。
                        [flags]については|ex-flags|を参照。

コマンド ">" と "<" は、プログラムに含まれるインデントを変更するのに便利である。
オプション 'shiftwidth' には、これらのコマンドが挿入、削除する空白の幅を設定す
る。'shiftwidth' は既定では 8 だが、例えば 3 に設定して、インデントをもっと少
なくすることもできる。左方向へのシフトは、インデントがなくなったときに終了する。
右方向へのシフトは、空行には適用されない。

'shiftround' がオンのとき、インデントは 'shiftwidth' の倍数に丸められる。

'shiftwidth' がオンのとき、あるいは 'cindent' がオンで 'cinkeys' が '#' を含む
とき、右方向へのシフトは '#' で始まる行に適用されない (これらの行は、行の最初
に位置すべきCプリプロセッサ指令であると考えられる)。

'expandtab' がオフ (既定値) のとき、Vimはインデントにできる限り多くの <Tab> を
使う。">><<" によって、空白のみで構成されたインデントを、<Tab> (と必要ならばい
くつかの空白) で構成されたインデントに置換できる。'expandtab' がオンのときは、
Vimは空白のみを使う。">><<" によって、インデント内の <Tab> を空白に置換できる
(あるいは `:retab!` を使う)。

行を 'shiftwidth' の複数個分ずらすには、ビジュアルモードかコマンド `:` を使う。
例: >
	Vjj4>		3行をインデント4個分右に移動
	:<<<		現在の行をインデント3個分左に移動
	:>> 5		5行をインデント2個分右へ移動
	:5>>		5行目をインデント2個分右に移動

==============================================================================
4. 複雑な変更						*complex-change*

4.1 フィルタコマンド					*filter*

フィルタとは、テキストを標準入力から受け取り、何らかの変更を加え、標準出力に送
るプログラムのことである。以下のコマンドにより、テキストの一部をフィルタにかけ
ることができる。フィルタの例としては、行をアルファベット順にソートする "sort"、
Cのプログラムを整形する "indent" (ただし、フィルタ機能を持ったバージョンが必要。
全てのバージョンでできるわけではない) などがある。オプション 'shell' は、Vimが
フィルタコマンドを実行するときに使うシェルを指定する ('shelltype' も参照)。フィ
ルタコマンドはコマンド "." で繰り返せる。Vimは `:!` の後のコメント ('"' で始ま
る行) を認識しない。

							*!*
!{motion}{filter}	{motion} のテキストを外部プログラム {filter} でフィル
			タ処理する。

							*!!*
!!{filter}		[count] 行を外部プログラム {filter} でフィルタ処理する。

							*v_!*
{Visual}!{filter}	ビジュアル選択された行を外部プログラム {filter} でフィ
			ルタ処理する。({Visual} については |Visual-mode| を参
			照)。 {Vi にはない}

:{range}![!]{filter} [!][arg]				*:range!*
			{range} 行を外部プログラム {filter} でフィルタ処理する。
			{filter} の後ろには '!' を付けてもよい。これは最後に実
			行されたコマンドに置き換えられる。さらに [arg] を付け
			ると、それがコマンドに付け加えられる。 Vimはフィルタコ
			マンドの出力を一時ファイルに保存し、そのファイルをバッ
			ファに読み込む |tempfile|。フィルタの出力を一時ファイ
			ルにリダイレクトするときはオプション 'shellredir' が使
			われる。Unixでは 'shellredir' がオフのとき、可能ならば
			パイプが使われる。
			'cpoptions' に 'R' フラグが含まれるとき、フィルタ処理
			された行のマークは削除される。|:keepmarksa| コマンドを
			使うと削除されない。例: >
				:keepmarks '<,'>!sort
<			フィルタ処理のあと行数が少なくなっていた場合、すでにな
			い行を指しているマークは削除される。

							*=*
={motion}		{motion} の行を、オプション 'equalprg' で指定された外
			部プログラムでフィルタ処理する。'equalprg' が空のとき
			(これが既定) は、組み込みの整形機能の |C-indenting| と
			|'lisp'| を使う。しかし 'indentexpr' が空でないとき
			は、それが使われる |indent-expression|。Vim が内部
			フォーマット機能なしでコンパイルされているときは、最後
			の手段として "indent" プログラムが使われる。

							*==*
==			[count] 行を ={motion} と同様にフィルタ処理する。

							*v_=*
{Visual}=		ビジュアル選択されたテキストを ={motion} と同様にフィ
			ルタ処理する。 {Vi にはない}


						*tempfile* *setuid*
フィルタリング、diff の生成、tempname() などを行うときには、一時ファイルが作成
される。Unix ではこのファイルはプライベートな (自分だけがアクセスできる) ディ
レクトリに置かれる。セキュリティ上の問題 (symlink attack や他の人があなたのファ
イルを読むなど) を避けるためである。Vim が終了するとき、そのディレクトリと中に
あるファイルは自動的に削除される。Vim に setuid ビットが立っているとこれが問題
を引き起こすことがある。一時ファイルは setuid されたユーザーが所有するのに対
し、フィルタコマンドは元のユーザーとして動作するためである。
MS-DOS と OS/2 では、以下のディレクトリのうち最初に利用可能なものが使われる:
$TMP, $TEMP, c:\TMP, c:\TEMP。
Unix におけるディレクトリのリストは: $TMPDIR, /tmp, current-dir, $HOME。
MS-Windows ではシステム関数 GetTempFileName() が使われる。
他のシステムではライブラリ関数 tmpnam() が使われる。



4.2 置換						*:substitute*
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			[range] の各行で {pattern} のマッチを {string} に置き
			換える。
			{pattern}については|pattern|を参照すること。
			{string} は普通の文字列でもよいし、特別な指定方法を使っ
			てもよい。|sub-replace-special| を参照。
			[range] と [count] が指定されないと、現在行内でのみ置
			換を行う。
			[count] が指定されると、[range] の最終行から数えて
			[count] 行で置換を行う。[range] が指定されないと、現在
			行から開始する。
			|cmdline-ranges| も参照。
			フラグについては |:s_flags| を参照。

:[range]s[ubstitute] [flags] [count]
:[range]&[&][flags] [count]					*:&*
			最後の置換を同じパターンかつ同じ置換文字列で、フラグを
			つけずに繰り返す。フラグを追加することもできる
			(|:s_flags|を参照)。
			Note `:substitute` の後ではフラグ '&' は使えないことに
			注意。パターンの区切り文字だと認識されてしまう。
			`:substitute` とフラグ 'c', 'g', 'r' の間の空白は必要
			不可欠ではない。しかしスクリプト内では、混乱しないよう
			に空白を入れておくのはよい考えである。

:[range]~[&][flags] [count]					*:~*
			最後の置換を同じ置換文字列で、最後の検索パターン {訳注:
			"/" で使ったもの} に対して繰り返す。`:&r` に似ている。
			フラグについては |:s_flags| を参照。

								*&*
&			`:s` と同義 (最後の置換を繰り返す)。 Note 同じフラグが
			使われるわけではないので注意。実際の動作は違うかもしれ
			ない。フラグも同じにするには `:&&` を使うこと。

								*g&*
g&			`:%s//~/&` と同義 (全ての行に対し、最後の検索パターン
			で、同じフラグで最後の置換を繰り返す)。
			例えば、`:s/pattern/repl/flags` と置換を実行し、次に
			`/search` と検索を実行すると、`g&` は
			`:%s/search/repl/flags` を実行する。
			覚え方: 「グローバル (global --全体的な) 置換」
			{Vi にはない}

						*:snomagic* *:sno*
:[range]sno[magic] ...	`:substitute` と同じだが、常に 'nomagic' を使う。
			{Vi にはない}

						*:smagic* *:sm*
:[range]sm[agic] ...	`:substitute` と同じだが、常に 'magic' を使う。
			{Vi にはない}

							*:s_flags*
置換コマンドで使えるフラグ:

[&]	先頭に指定しなければならない。前回の置換コマンドと同じフラグを使う。
	例: >
		:&&
		:s/this/that/&
<	Note コマンド `:s` と `:&` では、前回と同じフラグは使われない。
	{Vi にはない}

[c]	置換前に毎回確認する。マッチしている文字列を (強調表示グループ
	|hl-IncSearch| で) 強調表示する。確認を求められたら、ユーザは以下のよ
	うに応答する。					*:s_c*
	    'y'	    そのマッチを置換する ("yes")
	    'l'	    そのマッチを置換し、置換を終了する ("last")
	    'n'	    そのマッチを置換せず、次に移る ("no")
	    <Esc>   置換を終了する
	    'a'	    そのマッチと、以降の全てのマッチを置換する {Vi にはない}
	    'q'	    置換を終了する {Vi にはない}
	    CTRL-E  画面を上にスクロールする {Vi にはない。Vimが
		    |+insert_expand| 機能付きでコンパイルされたときのみ有効}
	    CTRL-Y  画面を下にスクロールする {Vi にはない。Vimが
		    |+insert_expand| 機能付きでコンパイルされたときのみ有効}
	オプション 'edcompatible' がオンのとき、Vimはフラグ [c] を記憶し、それ
	が指定される度にオン／オフを切り替えるが、新しい検索パターンが使われる
	とリセットする。
	{Vi にはないもの: マッチの強調表示、'y' と 'n' 以外の応答}

[e]	検索パターンが何もマッチしなかったとき、エラーメッセージを表示しない。
	特にマッピング内ではエラーが発生しなかったかのように続行される。これは
	「パターンは見つかりませんでした」のエラーによるマッピングの中断を防ぐ
	のに使える。しかし以下のエラーの発生は抑制されない。
		「正規表現は文字で区切ることができません」
		「\\ の後は / か ? か & でなければなりません」
		「正規表現置換がまだ実行されていません」
		「余分な文字が後ろにあります」
		「(割込まれました)」
	{Vi にはない}

[g]	行中の全てのマッチを置換する。このフラグなしだと、各行の1個目のマッチ
	のみが置換される。オプション 'edcompatible' がオンのとき、Vimはこのフ
	ラグを記憶し、指定される度にオン／オフを切り替えるが、新しい検索パター
	ンが使われるとリセットする。'gdefault' がオンのときは、このフラグはオ
	ンが既定値になり、フラグ [g] を指定したときにはオフになる。

[i]	パターンの大文字／小文字の区別をしない。オプション 'ignorecase' と
	'smartcase' は使われない。
	{Vi にはない}

[I]	パターンの大文字／小文字を区別する。オプション 'ignorecase' と
	'smartcase' は使われない。
	{Vi にはない}

[n]	マッチの個数を表示し、実際には置換を行わない。フラグ [c] は無視される。
	'report' が 0 のときと同じようにマッチが表示される。
	何個あるか調べるときに便利。|count-items|
	\= |sub-replace-expression| が使われたときは、式はそれぞれのマッチに対
	してサンドボックス (|sandbox|) で実行される。

[p]	最後に置換を行った行を表示する。
	{Vi にはない}

[#]	[p] と同様。行番号をつける。

[l]	[p] と同様だが、|:list| のように表示する。

[r]	引数のない `:&` か `:s` との連携でのみ有効。`:&r` は `:~` と同様に動作
	する。検索パターンが空のとき、最後の置換コマンドや `:global` でのパター
	ンではなく、最後の検索パターンを使用する。最後に検索パターンを使用した
	コマンドが置換や `:global` だったときは、何もしない。最後のコマンドが
	"/" のような検索コマンドだったときは、そのコマンドの検索パターンを使う。
	引数付きの `:s` では、すでにそう動作するようになっていた。 >
		:s/blue/red/
		/green
		:s//red/  または  :~  または  :&r
<	最後のコマンドは "green" を "red" に置き換える。 >
		:s/blue/red/
		/green
		:&
<	最後のコマンドは "blue" を "red" に置き換える。
	{Vi にはない}

NOTE パターンに 'magic' が適用されるかどうかを変更するフラグはないことに注意。
代わりに違うコマンド{訳注: |:snomagic|}または |/\v| などを使う。これは、パター
ン解釈を飛ばすことでのみフラグを認識できるが、その一方でパターン解釈を飛ばす
には 'magic' の適用状態が知られている必要があるためである。 Catch 22! {訳注:
どうにもならないという意味}

置換コマンドで {pattern} が空のときは、最後に使われた置換コマンドまたはコマン
ド `:global` のパターンが使われる。それが無い場合は、直前の検索パターンがあれ
ばそれが使われる。フラグ [r] を指定すると、最後の置換、`:global`、または検索コ
マンドのパターンが使われる。

{string}を省略した場合は、空文字列を指定したのと同じ結果になる。すなわち、マッ
チしたパターンが削除される。{pattern}の後のセパレータも省略することができる。
例: >
	:%s/TESTING
これは、全行から "TESTING" を削除する例である。ただし、1つの行に2個以上あって
も1個しか削除されない。

Viとの互換性のため、これら2つの例外が許される。
"\/{string}/" と "\?{string}?" は "//{string}/r" と同様の効果。
"\&{string}&" は "//{string}/" と同様の効果。
							*E146*
'/' でパターンと置換文字列を囲む代わりに、英数字や '\', '"', '|' 以外であれば、
他の1バイト文字を使うことができる。これは検索パターンや置換文字列に '/' を含む
場合に有益である。例 >
	:s+/+//+

パターンの定義については |pattern| を参照。矩形ビジュアルモードで、置換をその
領域内だけで行いたい場合は、パターンに |/\%V| を含める。これを使わない場合は、
置換は常に行全体に対して行われる。

					*sub-replace-special* *:s\=*
{string} が "\=" で始まるときは、それは式として評価される。
|sub-replace-expression|　を参照のこと。複雑な置換や特殊な文字を使うことができ
る。そうでなければ、{string} の中のこれらの文字は特別な意味を持つ:

								*:s%*
'cpoptions' に '/' が含まれている場合、{string} が "%" に等しいならば前の置換
コマンドの {string} が使われる。|cpo-/| 参照

 magic	nomagic	  作用    ~
  &	  \&	  マッチしたパターン全体に置き換わる		     *s/\&*
 \&	   &	  '&' に置き換わる
      \0	  マッチしたパターン全体に置き換わる		   *\0* *s/\0*
      \1	  1番目の () 内のマッチしたパターンに置き換わる      *s/\1*
      \2	  2番目の () 内のマッチしたパターンに置き換わる      *s/\2*
      ..	  ..						     *s/\3*
      \9	  9番目の () 内のマッチしたパターンに置き換わる      *s/\9*
  ~	  \~	  前回の置換の {string} に置き換わる		     *s~*
 \~	   ~	  '~' に置き換わる				     *s/\~*
      \u	  次の文字が大文字になる			     *s/\u*
      \U	  後に続く文字が (\E まで) 大文字になる		     *s/\U*
      \l	  次の文字が小文字になる			     *s/\l*
      \L	  後に続く文字が (\E まで) 小文字になる		     *s/\L*
      \e	  \u, \U, \l, \L の終わり ( NOTE: <Esc> の意味ではない！)
								     *s/\e*
      \E	  \u, \U, \l, \L の終わり			     *s/\E*
      <CR>	  ここで行を2つに分ける (<CR> は CTRL-V <Enter> と入力する)
								     *s<CR>*
      \r	  同上						     *s/\r*
      \<CR>	  キャリッジリターン (CTRL-M) の挿入 (<CR> は CTRL-V <Enter>
		  と入力する)					     *s/\<CR>*
      \n	  <NL> (ファイル内では <NUL>) の挿入 (改行を「起こさない」)
								     *s/\n*
      \b	  <BS> の挿入					     *s/\b*
      \t	  <Tab> の挿入					     *s/\t*
      \\	  '\' の挿入					     *s/\\*
      \x	  ('x' は上で説明されていない文字) 将来の拡張用に予約済み

特別な意味は |substitute()| の 第三引数 {sub} でも使えるがいくつか例外がある:
  - % は 'cpoptions' に関係なくパーセント文字を挿入する。
  - 'magic' に関係なく magic は常にオンである。
  - ~ はチルダをそのまま挿入する。
  - <CR> と \r はキャリッジリターン (CTRL-M) を挿入する。
  - \<CR> は特別な意味を持たない。単に \x の一種として扱われる。

例: >
  :s/a\|b/xxx\0xxx/g		 "a b"      を "xxxaxxx xxxbxxx" に置換
  :s/\([abc]\)\([efg]\)/\2\1/g	 "af fa bg" を "fa fa gb"        に置換
  :s/abcde/abc^Mde/		 "abcde"    を "abc", "de" (2行) に置換
  :s/$/^V^M/			 "abcde"    を "abcde^M"         に置換
  :s/\w\+/\u\0/g		 "bla bla"  を "Bla Bla"         に置換
  :s/\w\+/\L\u/g		 "BLA bla"  を "Bla Bla"         に置換

Note: "\L\u" を使うと単語の最初の文字をキャピタライズできる。これは Vi や古い
Vim とは互換性がない。それらの古い環境では "\u" は "\L" をキャンセルする。
"\U\l" も同様。

NOTE: 以前のバージョンでは CTRL-V が特別に扱われていた。これはVi互換ではないの
で変更された。代わりに '\' を使うこと。

コマンド      テキスト	置換結果 ~
:s/aa/a^Ma/	aa	a<line-break>a
:s/aa/a\^Ma/	aa	a^Ma
:s/aa/a\\^Ma/	aa	a\<line-break>a

(ここで ^M を使うには CTRL-V <CR> と打ち込むこと)

"\1", "\2" などの番号付けは、パターン内でどの "\(" が最初に来るかによって決まる
(左から右の順)。括弧でくくられたグループが複数回マッチするときは、最後のものが
"\1", "\2" 等に使われる。例: >
	:s/\(\(a[a-d] \)*\)/\2/      "aa ab x" を "ab x" に置換

\([ab]\)\|\([cd]\) のように括弧を '|' と連携して使っているとき、1番目か2番目の
どちらかの括弧内のパターンにはマッチしない、すなわち、\1 か \2 のどちらかは空
になる。例: >
	:s/\([ab]\)\|\([cd]\)/\1x/g   "a b c d" を "ax bx x x" に置換
<

式で置換する					*sub-replace-expression*
						*sub-replace-\=*

置換文字列が "\=" で始まるとき、それ以降の文字列は式として解釈される。これは再
帰的に機能しない。その式の中での |substitute()| では置換文字列に "\=" を使うこ
とはできない。

"<CR>" 以外の文字の特別な意味 |sub-replace-special| は無効になる。<NL> 文字は
改行として使われるのでダブルクォート文字列 "\n" で改行を入れることができる。
実際の <NL> 文字 (ファイルにおける NUL 文字) を挿入するにはバックスラッシュを
前置する。

"\=" 表記は |substitute()| 関数の第三引数 {sub} でも使うことができる。その場
合、|sub-replace-special| で説明されている文字は特別な意味を持たなくなる。特
に、<CR> と <NL> は改行として解釈されるのではなく、そのままキャリッジリターン
とニューラインとして解釈される。

結果が|List|のときはその要素が改行を区切りとして連結される。よって要素がそれぞ
れ行となる。ただし要素が改行を含んでいる場合は除く。

マッチしたテキストの全体は "submatch(0)" で参照できる。1番目の () 内でマッチし
たテキストは "submatch(1)" で参照できる。以降の () 内でマッチしたテキストも同
様に参照できる。

注意: 正規表現の区切り文字が expression 内に現れてはいけない！区切りには "@"
や "|" を使うよう検討すること。Expression の結果に区切り文字が現れても問題はな
い。

例: >
	:s@\n@\="\r" . expand("$HOME") . "\r"@
こうすると置換を行った行の下に、環境変数 $HOME の値を含む新しい行が挿入される。 >

	s/E/\="\<Char-0x20ac>"/g
これは文字 'E' をユーロ記号で置換する。詳しくは |<Char->| を参照。


4.3 検索と置換					*search-replace*

						*:pro* *:promptfind*
:promptf[ind] [string]
			検索ダイアログを表示する。 [string] が与えられると、そ
			れ初期検索文字列になる。
			{VimのWin32版、Motif版、GTKのGUI版のみ}

						*:promptr* *:promptrepl*
:promptr[epl] [string]
			検索／置換ダイアログを表示する。 [string] が与えられる
			と、それが初期検索文字列になる。
			{VimのWin32版、Motif版、GTKのGUI版のみ}


4.4 タブの変換                                          *change-tabs*
							*:ret* *:retab* *:retab!*
:[range]ret[ab][!] [new_tabstop]
			新たに指定されたタブストップ (タブ幅) に基づき、<Tab>
			を含む空白の連続を全て、新しい空白と <Tab> の列に置き
			換える。新たなタブストップの指定がないか0が指定された
			ときは、Vimはオプション 'tabstop' の現在の値を使用す
			る。'tabstop' の現在の値は、既存のタブの幅を計るために
			常に使用される。'!' を付けると、Vimは通常の空白のみの
			列も、適切なタブに置き換える。
			'expandtab' がオンのとき、Vimは全てのタブを適切な数の
			空白に置き換える。
			このコマンドは 'tabstop' を新たに指定された値に設定す
			る {訳注: この事実は重要である}。ファイル全体に適用さ
			れたときは (それが既定の動作)、ファイルの見かけに変化
			が起こることはないはずだ。
			注意: このコマンドはCプログラム中の文字列内部にある
			<Tab> 文字も修正する。これを避けるためには、プログラム
			内では "\t" を使うとよい (そうでなくても、これはよい習
			慣である)。
			`:retab!` も空白の連続を <Tab> 文字に変えてしまい、
			printf() の出力をめちゃくちゃにするかもしれない。
			{Vi にはなく、Vim が |+ex_extra| 機能付きでコンパイル
			されたときのみ有効}

							*retab-example*
タブストップが 8 で保存され、タブストップが 4 で編集されたファイルを編集するた
めに autocommand と ":retab" を使う例。警告: 文字列内の空白は変わってしまうこ
とがある！オプション 'softtabstop' も参照。 >

	:auto BufReadPost	*.xx	retab! 4
	:auto BufWritePre	*.xx	retab! 8
	:auto BufWritePost	*.xx	retab! 4
	:auto BufNewFile	*.xx	set ts=4

==============================================================================
5. テキストのコピーと移動				*copy-move*

							*quote*
"{a-zA-Z0-9.%#:-"}	続く操作 (削除、コピー、貼り付け) にレジスタ
			{a-zA-Z0-9.%#:-"} を使う (削除、コピーでは大文字を使う
			ことでレジスタに追記できる)
			({.%#:} は貼り付けにのみ使用可能)。

							*:reg* *:registers*
:reg[isters]		全ての名前付きレジスタおよび番号付きレジスタの内容を表
			示する。レジスタが |:redir| の書き込み先になっている場
			合はそのレジスタは表示されない。
			{Vi にはない}

:reg[isters] {arg}	{arg} に指定された名前付きレジスタおよび番号付きレジス
			タを表示する。例: >
				:dis 1a
<			レジスタ '1' と 'a' が表示される。{arg} の中では空白を
			用いてよい。 {Vi にはない}

							*:di* *:display*
:di[splay] [arg]	:registers と同じ。  {Vi にはない}

							*y* *yank*
["x]y{motion}		{motion} のテキストを [レジスタ x に] コピーする。
			コピーされるテキストがないとき (例えば 1 桁目で "y0"
			を行う)、オプション 'cpoptions' がフラグ 'E' を含んで
			いるならエラーになる。

							*yy*
["x]yy			[count] 行を [レジスタ x に] コピーする (行単位
			|linewise|)。

							*Y*
["x]Y			[count] 行を [レジスタ x に] コピーする ("yy" と同義、
			行単位|linewise|)。"Y" でカーソル位置から行の終わりま
			でコピーしたいときは (この方が論理的と言えるが、Vi互換
			ではない) ":map Y y$" を使う。

							*v_y*
{Visual}["x]y		ビジュアル選択されたテキストを [レジスタ x に] コピー
			する
			({Visual} については |Visual-mode| を参照)。
			{Vi にはない}

							*v_Y*
{Visual}["x]Y		ビジュアル選択された行を [レジスタ x に] コピーする
			({Visual} については |Visual-mode| を参照)。
			{Vi にはない}

							*:y* *:yank* *E850*
:[range]y[ank] [x]	[range] の行を [レジスタ x に] コピーする。"* レジスタ
			と "+ レジスタへのコピーは |+clipboard| 機能が有効な場
			合のみ可能。

:[range]y[ank] [x] {count}
			[range] の最後の行 (省略時は現在行 |cmdline-ranges|)
			から数えて {count} 行を [レジスタ x に] コピーする。

							*p* *put* *E353*
["x]p			カーソルの後に、テキストを [count]回 [レジスタ x から]
			貼り付ける。 {Vi: カウントはない}

							*P*
["x]P			カーソルの前に、テキストを [count]回 [レジスタ x から]
			貼り付ける。 {Vi: カウントはない}

							*<MiddleMouse>*
["x]<MiddleMouse>	カーソルの前に、テキストを [count]回 [レジスタ x から]
			貼り付ける。レジスタ指定がない場合は "* が使われる。
			カーソルは挿入したテキストの末尾に置かれる。
			マウスは 'mouse' が 'n' か 'a' を含むときのみ使える。
			{Vi にはない}
			もしあなたがスクロールホイールを持っていて意図せずにテ
			キストを貼り付けてしまうのなら、次のマッピングでマウス
			の真ん中のボタンを無効化できる。 >
				:map <MiddleMouse> <Nop>
				:imap <MiddleMouse> <Nop>
<			複数クリックも無効にしたいなら |double-click| も参照のこ
			と。

							*gp*
["x]gp			"p" と似ているが、カーソルは挿入したテキストの直後に置
			かれる。 {Vi にはない}

							*gP*
["x]gP			"P" と似ているが、カーソルは挿入したテキストの直後に置
			かれる。 {Vi にはない}

							*:pu* *:put*
:[line]pu[t] [x]	[line] 行目 (省略時は現在行) の後にテキストを [レジス
			タ x から] コピーする。このコマンドは常に行単位
			|linewise| の動作をするので、コピーされたブロックを新
			しい行として挿入するときに使える。
			レジスタが指定されていないときのレジスタは 'cb' オプ
			ションに依存する。'cb' が "unnamedplus" を含むときは
			+ レジスタ |quoteplus| からペーストする。そうではなく、
			'cb' が "unnamed" を含むときは * レジスタ |quotestar|
			からペーストする。そうでなければ、無名レジスタ
			|quote_quote| からペーストする。
			レジスタには '=' に続けて式を指定することもできる。コ
			マンドの末尾までが式として評価される。文字 '|' と '"'
			がコマンドの末尾として解釈されないようにするには、それ
			らをエスケープする {訳注: 前に '\' を置く} 必要があ
			る。例: >
				:put ='path' . \",/test\"
<			'=' の後に式がないときは前回の式が使われる。それはコマ
			ンド ":dis =" で見ることができる。

:[line]pu[t]! [x]	[line] 行目 (省略時は現在行) の前にテキストを [レジス
			タ x から] コピーする。

["x]]p		    または				*]p* *]<MiddleMouse>*
["x]]<MiddleMouse>	"p" と似ているが、現在行に合わせてインデントが調整され
			る。マウスは、'mouse' が 'n' か 'a' を含むときだけ使え
			る。  {Vi にはない}

["x][P		    または				*[P*
["x]]P		    または				*]P*
["x][p		    または				*[p* *[<MiddleMouse>*
["x][<MiddleMouse>	"P" と似ているが、現在行に合わせてインデントが調整され
			る。マウスは、'mouse' が 'n' か 'a' を含むときだけ使え
			る。  {Vi にはない}

これらのコマンドを使って、ある場所から別の場所へテキストをコピーできる。まずコ
ピー、削除または変更コマンドを使って、テキストをレジスタに蓄える。そしてレジス
タの内容を、貼り付けコマンドで文章中に挿入する。これらのコマンドで、あるファイ
ルから別のファイルへテキストを移動させることもできる。Vim はバッファを切り替え
ても、全てのレジスタの内容を保っているからである (コマンド CTRL-^ は、2個の
バッファを素早く切り替えられる)。

				*linewise-register* *characterwise-register*
貼り付けコマンド (":put" 以外) は、"." で繰り返したり、アンドゥできる。テキス
トをレジスタに蓄えるのに使われたコマンドが行単位|linewise|のものだったら、テキ
ストはカーソルのある行の次の行 ("p" のとき) や前の行 ("P" のとき) に貼り付けら
れる。そうでなければ、テキストはカーソルの後 ("p" のとき) や前 ("P" のとき) に
挿入される。コマンド ":put" を使ったときは、テキストは常に次の行へ挿入される。
"xp" というコマンド列で、カーソル上の文字と次の文字との入れ替えができる。現在
行と次の行との入れ替えには、コマンド列 "ddp" を使う。(カーソルが単語の前の空白
の上にあるとき) 次の単語とその次の単語との入れ替えには、コマンド列 "deep" を使
う。貼り付けコマンドを使った後には、コマンド "']" か "`]" で挿入された行の終わ
りに移動でき、コマンド "'[" か "`[" で挿入された行の最初に移動できる。

						*put-Visual-mode* *v_p* *v_P*
ビジュアルモードで |p| や |P| 等の貼り付けコマンドを使ったとき、Vimは選択さ
れたテキストをレジスタの中身で置き換えようとする。これがうまく動作するかどう
かは、選択領域の種類とレジスタ内のテキストの種類による。ブロック指向の選択で
は、ブロックのサイズと、選択領域の角が既存の文字上にあるかどうかにもよる。
(実装上の詳細:実際の動作は、まずレジスタの中身を選択領域の後に貼り付け、その
後で選択領域を削除するようになっている)
それまで選択されていたテキストが無名レジスタに保存される。同じテキストを複数
のビジュアル選択領域にプットしたい場合は、ほかのレジスタを使う必要がある。例
えば、コピーしたいテキストをヤンクして、選択したテキストを "0p で置き換える。
これを好きなだけ繰り返す。このとき、無名レジスタはプットするたびに変わる。

							*blockwise-register*
矩形ビジュアルモードで、レジスタにテキストを蓄えるコマンドを使うと、テキストの
ブロックはカーソルの前 ("P" のとき) または後 ("p" のとき) から、現在行と引き続
く行にわたって、挿入される。テキストのブロック全体は同じ列から始まるように挿入
される。そのため挿入されたテキストはコピーや削除されたときと同じ形を保っている。
Vimは、このようにするために <Tab> を空白で置き換えることがある。しかし、テキ
ストのブロックの幅が <Tab> の幅の整数倍でなく、さらに挿入されたブロックの後の
テキストが <Tab> を含むとき、列揃えがおかしくなることがある。

Note 文字単位のコピーコマンドの後、コピーされたテキストの中でバッファの先頭に
一番近い文字の上にカーソルが置かれることに注意。つまり "yl" ではカーソルは動か
ないが、"yh" ではカーソルは1文字左に動く。
理論的説明:	Viでは、後方移動を伴ったコマンド "y" ではコピーされたテキスト
		の先頭にカーソルを移動させないことがあった。これは再表示が省か
		れたためである。Vimでは Posix に定められた通り、常に先頭の文字
		にカーソルを移動させる。
行単位のコピーコマンドではカーソルは選択の最初の行に置かれるが、カラムは変更さ
れない。なのでその位置はコピーされた最初の文字の上ではないかもしれない。

レジスタには 9 種類ある:				*registers* *E354*
1. 無名レジスタ ""
2. 10個の番号付きレジスタ "0 から "9
3. 小削除用レジスタ "-
4. 26個の名前付きレジスタ "a から "z または "A から "Z
5. 4個の読み取り専用レジスタ ": と ". と "% と "#
6. expression 用レジスタ "=
7. 選択領域用レジスタ "* と "+ と "~ 
8. 消去専用レジスタ "_
9. 最終検索パターン用レジスタ "/

1. 無名レジスタ ""				*quote_quote* *quotequote*
このレジスタには、コマンド "d", "c", "s", "x" 等で削除されたテキストや、"y" 等
のコピーコマンドでコピーされたテキストが蓄えられる。特定のレジスタが指定されて
いてもいなくても関係ない (例えば "xdd でもこれが使われる)。つまり無名レジスタ
は最後に使われたレジスタを指していると考えられる。よって、大文字レジスタを使っ
て名前つきレジスタにテキストを追加したときも、無名レジスタの中身は、その名前
つきレジスタと同じになる。
例外はレジスタ '_' である。"_dd は、削除されたテキストをどのレジスタにも蓄え
ない。
無名レジスタの中身は、レジスタを指定しない貼り付けコマンド (p や P) で使うこ
とができる。加えて、このレジスタは '"' という名前で使うことができる。これは、
使うときには二重引用符 '"' を 2 個打ち込むということである。レジスタ "" に対す
る書き込みはレジスタ "0 にも書き込むことになる。
{Vi ではレジスタの内容はファイルを変更するときに失われ、'"' もない}

2. 番号付きレジスタ "0 から "9		*quote_number* *quote0*	*quote1*
					*quote2* *quote3* *quote4* *quote9*
これらのレジスタには、コピーや削除コマンドによってテキストが蓄えられる。
番号付きレジスタの 0 には、一番最近にコピーしたテキストが蓄えられるが、コピー
の際に ["x] として別のレジスタ名を指定したときは、これには蓄えられない。
番号付きレジスタ 1 には、一番最近に削除したり変更したテキストが蓄えられるが、
コマンドに別のレジスタ名を指定したり、削除や変更したテキストが1行以下だったり
したときは、これには蓄えられない (そのときは小削除用レジスタが使われる)。例外
は、以下の移動コマンドと削除コマンドを組み合わせたときである。|%|, |(|, |)|,
|`|, |/|, |?|, |n|, |N|, |{|, |}|。このときは必ずレジスタ "1 が使われる (これ
はVi互換の動作である)。削除や変更したテキストが1行以下だったときは、レジスタ
"- も使われる。削除や変更が行われるたびに、レジスタ 1 の内容はレジスタ 2 に、
レジスタ 2 の内容はレジスタ 3 に、という風にずれていく。レジスタ 9 の内容は失
われる。
{Vi では番号付きレジスタの内容はファイルを変更する際に失われる。レジスタ 0 は
ない}

3. 小削除用レジスタ "-					*quote_-* *quote-*
このレジスタには、範囲が1行以下の削除コマンドで削除されたテキストが蓄えられる。
ただし、コマンドに ["x] で別のレジスタ名を指定したときはこれには蓄えられない。
{Vi にはない}

4. 名前付きレジスタ "a から "z または "A から "Z	*quote_alpha* *quotea*
これらのレジスタが使われるのは、ユーザに指定されたときのみである。コピーや削除
の際にこれらのレジスタを小文字で指定すると、コピーや削除されたテキストが蓄えら
れ、元から入っていたテキストは消える。大文字で指定すると、元から入っていた内容
の後ろに新しいテキストを付け加える。'cpoptions' にフラグ '>' が入っていると、
新しいテキストの前に改行が挿入される。

5. 読みとり専用レジスタ ": と ". と "% と "#
読みとり専用レジスタには '%' と '#' と ':' と '.' がある。コマンド "p", "P",
":put" および CTRL-R でのみ使うことができる。 {Vi にはない}
						*quote_.* *quote.* *E29*
	".	最後に挿入されたテキストが蓄えられる (挿入モードのコマンド
		CTRL-A や CTRL-@ で挿入されるものと同じテキストである)。 Note:
		これはコマンドライン上での CTRL-R では使えないことに注意。動作
		が少し異なり、テキストを貼り付けるというより挿入するような動作
		をする (挿入されるテキストに 'textwidth' 等のオプションが影響
		する)。
							*quote_%* *quote%*
	"%	カレントファイルの名前が蓄えられる。
							*quote_#* *quote#*
	"#	代替ファイルの名前が蓄えられる。
						*quote_:* *quote:* *E30*
	":	一番最近に実行されたコマンドラインの内容が蓄えられる。例: 前回
		のコマンドラインによるコマンドを実行するには、"@:" が使える。
		コマンドラインがこのレジスタに蓄えられるのは、コマンドライン内
		にコマンドが最低でも1文字打ち込まれたときである。そのため、コ
		マンドが完全にキーマッピングから実行されたときには、この内容に
		変化はない。
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}

6. Expression レジスタ "=			*quote_=* *quote=* *@=*
これは、本当はテキストを蓄えるレジスタではないが、レジスタを使うコマンドで式
を評価するために使える。この expression レジスタは読み取り専用である。
これにはテキストをコピーできない。'=' を打ち込むと、カーソルはコマンド行に移
動し、あらゆる式を入力することができる (|expression| を参照)。コマンドライン
から入力できる普通の編集用コマンドは、式用の特別履歴も含め、全て使用可能であ
る。<CR> を打ち込んでコマンドライン入力を終了させると、式の結果が計算される。
<Esc> を打ち込んで終了させると、式は破棄される。式が入力されないときは、(コ
マンド "/" と同様) 前回の式が使われる。

式を評価した結果は文字列でなければならない。評価した結果が数値なら、文字列に
変換される。"p" と ":put" コマンドの場合、結果が浮動小数点数なら文字列に変換
される。リストの場合、各要素が文字列に変換され、それぞれが 1 行として挿入さ
れる。辞書または FuncRef はエラーメッセージが出る(string()を使って変換する)。

レジスタ "= が "p" で使われると、文字列は<NL> 文字 {訳注: New Line
--改行} の所で分割される。文字列が <NL> で終わっていたら、これは行単位のレジ
スタと見なされる。 {Vi にはない}

7. 選択範囲レジスタ "* と "+
これらのレジスタは、GUIで、選択されたテキストを蓄えたり取り出すために使われる。
|quotestar| と |quoteplus| を参照。クリップボードが利用できないときは、無名レ
ジスタが代わりに使われる。 Unixでは|+xterm_clipboard|が有効になっているときだ
けクリップボードを利用できる。{Vi にはない}

Note "* と "+ に区別があるのは X11 システムのみであることに注意。違いについて
は |x11-selection| を参照。MS-Windowsでは "* と "+ は実際には同義で、クリップ
ボード |gui-clipboard| を使用する。

						*quote_~* *quote~* *<Drop>*
この読み込み専用の "~ レジスタは最後にドラッグアンドドロップされたテキストを
提供する。何かがVimにドロップされたとき、 "~ レジスタがそれで埋められ、
<Drop>仮想キーが通知される。このキーをリマップして使うことができる。デフォル
トでは(全てのモードにおいて) "~ レジスタの内容をカーソルの位置に挿入する。
{Vi にはない}
{|+dnd|付きでコンパイルされたときのみ有効。現在はGTK GUIでのみ使える。}

Note: "~ レジスタはプレインテキストをVimにドロップしたときのみ使われる。URI
のリストは内部で扱われる。

8. 消去専用レジスタ "_					*quote_*
このレジスタを指定してテキストを削除しても、{訳注: レジスタには} 何も起こらな
い。そのため、普通のレジスタに影響を与えずに削除が行える。このレジスタから貼り
付けようとしても、何も出てこない。 {Vi にはない}

9. 最終検索パターン用レジスタ	"/			*quote_/* *quote/*
最後に使われた検索パターンが蓄えられる。これはコマンド "n" やオプション
'hlsearch' による強調表示に使われる。
このレジスタは `:let` で変更できるので、'hlsearch' による強調表示を、実際に検
索を行わずに別のマッチに適用することができる。このレジスタを使ってコピーしたり
削除することはできない。
Note 関数から抜けると、この値は関数に入る前の値に復元される。
|function-search-undo|
{Vi にはない}

							*@/*
レジスタには、コマンド `:let` で書き込むことができる |:let-@|。例: >
	:let @/ = "the"

レジスタを指定せずに貼り付けコマンドを使うと、最後に書き込みが行われたレジスタ
が使われる (その内容は無名レジスタと同じである)。混乱したときは、コマンド
`:dis` を使うとレジスタの内容が分かる (このコマンドは、全てのレジスタの内容を
表示する。無名レジスタは '"' と示される)。

以下の3個のコマンドは、必ず行全体に対して働く。

:[range]co[py] {address}				*:co* *:copy*
			[range] 行を、{address} 行目の下にコピーする。

							*:t*
:t			":copy" と同義。

:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			[range] 行を、{address} 行目の下に移動する。

==============================================================================
6. テキストの整形					*formatting*

:[range]ce[nter] [width]				*:ce* *:center*
			[range] の行を、幅 [width] (既定値は 'textwidth'、
			'textwidth' が 0 のときは 80) に基づいて中央揃えする。
			{Vi にはなく、Vimが |+ex_extra| 機能付きでコンパイルさ
			れたときのみ有効}

:[range]ri[ght] [width]					*:ri* *:right*
			[range] の行を、幅 [width] (既定値は 'textwidth'、
			'textwidth' が 0 のときは 80) に基づいて右揃えする。
			{Vi にはなく、Vimが |+ex_extra| 機能付きでコンパイルさ
			れたときのみ有効}

							*:le* *:left*
:[range]le[ft] [indent]
			[range] の行を左揃えする。行中のインデントを [indent]
			(既定値 0) に設定する。 {Vi にはない}
			{Vimが |+ex_extra| 機能付きでコンパイルされたときのみ
			有効}

							*gq*
gq{motion}		{motion} の行を整形する。整形は3種類の方法のうちどれか
                        で行われる。
                        1. 'formatexpr' が空でなければそのexpressionが評価さ
                           れる。これはバッファごとに異なってもよい。
                        2. 'formatprg' が空でなければ外部プログラムが使われる。
                        3. それ以外の場合は内部整形ルーチンが使われる。

                        3番目の場合は、オプション 'textwidth' が整形された各行
                        の長さを制御する (後述)。'textwidth' が 0 なら、整形さ
                        れた行の長さは画面の幅となる (ただし、最大で79)。 
			'formatoptions' は、整形の仕方を制御する |fo-table|。
                        カーソルは最後に整形された行の最初の非空白文字の上に置
                        かれる。
			NOTE: 以前はコマンド "Q" でこの機能を行っていた。やは
			り整形に "Q" を使いたいならば、次のマッピングを使うこ
			と。 >
				:nnoremap Q gq

gqgq							*gqgq* *gqq*
gqq			現在行を整形する。カウントを指定するとその行数だけ整形
			される。 {Vi にはない}

							*v_gq*
{Visual}gq		ビジュアル選択されたテキストを整形する。({Visual}につ
			いては|Visual-mode| を参照)。 {Vi にはない}

							*gw*
gw{motion}		{motion}で動いた範囲の行を整形する。|gq|に似ているが
			カーソルは元の位置に戻る。'formatprg' と 'formatexpr'
			は使われない。{Vi にはない}

gwgw							*gwgw* *gww*
gww			"gw" と同様にして現在行を整形する。 {Vi にはない}

							*v_gw*
{Visual}gw		選択されたテキストを "gw" と同様にして整形する。
                        ({Visual}については|Visual-mode|を参照). {Vi にはない}

例: 現在の段落を整形するには、次のようにする。			*gqap*  >
	gqap

コマンド "gq" は、移動コマンドによってカーソルが動くはずの位置にカーソルを移動
させる。このため、"." で整形を繰り返すことができる。これは、"gqj" (現在行と次
行を整形) と、"gq}" (段落の最後までを整形) で有用である。 NOTE: 'formatprg' が
設定されているときは、"gq" を実行すると (フィルタコマンド使用時と同様に) カー
ソルは整形された最初の行に移動する。

カーソルのある位置の段落をフォーマットし、その位置からさらに編集を再開するには
こうする。 >
	gwap
いつも段落をフォーマットしておきたいなら 'formatoptions' に 'a' フラグを追加す
ればよい。|auto-format| も参照のこと。

オプション 'autoindent' がオンのとき、Vimは最初の行のインデントを続く行に対し
て適用する。

テキストの整形処理は空の行には変更を加えない (しかし、空白のみで構成された行に
は変更を行う！)。

オプション 'joinspaces' は、行が連結されるときに使われる。

オプション 'formatexpr' でテキストの整形に使うexpressionを設定したり、
'formatprg' で外部プログラムの名前を設定することができる。
外部プログラムによる整形処理には、'textwidth' や他のオプションは何の影響も与え
ない。

							*right-justify*
テキストを右揃えするコマンドは、Vimには存在しない。"par" 等の外部コマンド (例:
"!}par" で段落の最後までを整形する) を実行したり、'formatprg' に "par" を指定
することで、これを行うことができる。

							*format-comments*
コメント整形の概要がユーザーマニュアルの |30.6| にある。

Vimは特殊な方法で自動的にコメントを挿入・整形できる。Vimは行の最初の特定の文
字列 (空白を無視する) によって、コメントを認識できる。コメントには3種類が使
える。

- 各行の最初で繰り返されるコメント文字列。例えば、"#" で始まるシェルスクリプト
  のコメントなど。
- 最初の行にのみ現れ、続きの行には現れないコメント文字列。例えば、このリストに
  おけるダッシュ '-'。
- 最初の文字列、最後の文字列、そしてその間の行の3つの部分から成るコメント。開
  始部分、中間部分、終了部分に使われる文字列は異なる。例えば、C言語形式のコメ
  ント。 >
	/*
	 * これは C のコメント
	 */

オプション 'comments' は要素のコンマ区切りのリストである。各要素はコメント文字
列の種類を定義している。要素は次のように構成される。
	{flags}:{string}

{string} は普通のテキストで、これがなければならない。

{flags}:
  n	入れ子になったコメント。混在した要素の入れ子も有効である。'comments'
	が "n:),n:>" であれば、"> ) >" で始まる行はコメント。

  b	{string} の後に余白 (<Space>、<Tab> または <EOL>) が必要。

  f	最初の行のみがコメント文字列を持つ。次の行にはコメントを繰り返さないが、
	インデントは保持する(例、bullet-list)。

  s	3部コメントの開始部分。

  m	3部コメントの中間部分。

  e	3部コメントの終了部分。

  l	左揃え。's' か 'e' と共に指定された場合、それぞれ最初または最後の部分
	の一番左の文字が、真ん中の一番左の文字に対して揃えられる。この動作は
	デフォルトであるが、省略もできる。詳しくは後述。

  r	右揃え。一番左でなく一番右であること以外、l と同じ。詳しくは後述。

  O	コマンド "O" ではこのコメントを考慮しない。

  x	3部コメントで、中間部分のコメントがすでに自動で挿入されているとき、新
	しい行の最初のアクションとして、終了部分のコメント文字列の最後の文字
	を打ち込むだけで、コメントを終了させる。詳細は以下を参照。

  {digits}
	's' か 'e' と共に指定された場合: 自動的に挿入された、中間または最後
	のコメントの最初の部分に対し、{digits} 分のオフセットを加える。この
	オフセットは左端を基準とする。詳しくは後述。

  -{digits}
	{digits} に似ているが、インデントを減らす。開始部分と終了部分に減らす
	べきインデントが存在しているときのみ機能する。

コメント文字列にフラグ 'f', 's', 'm', 'e' のいずれも指定しないとき、Vimはコメ
ント文字列を行の最初に繰り返すと仮定する。フラグ欄は空になる。

{string} の前や後にある余白は、{string} の一部とされる。コメント文字列に必要で
ない限り、余白を前や後に付けないこと。

あるコメント開始文字列が他のコメントの一部であるときは、共通部分の後で特定の部
分を指定すること。例えば、"-" と "->" の両方を含みたいときは、次のようにする。 >
	:set comments=f:->,f:-

3部コメントには常に開始部分、中間部分、終了部分を指定しなければならない。そし
て、他の要素を間に入れてはならない。C言語での3部コメントの例は次の通り。 >
	sr:/*,mb:*,ex:*/
"*ptr" がコメントとして認識されないように、中間部分の文字列がフラグ 'b' を含ん
でいる。3部コメントでは、Vimは開始部分と中間部分の文字列の後のテキスト内に、最
後の文字列が含まれていないかを調べる。終了部分の文字列が見つかると、コメントは
次の行には続かない。3部コメントには、Vimが中間の行を認識できるようにするために、
中間部分の文字列を指定しなければならない。

上記の3部コメントの定義における、フラグ "x" の使用について注意しておく。Cコメ
ントでリターンを打てば、Vimは新しい行に対して " * " のようなコメントの中間部分
の開始文字列を挿入する。このコメントを閉じるには、新しい行において何も打ち込む
前に "/" と打ち込めばよい。これは中間のコメント指示を最後のコメント指示に置き
換え、" */" とする。指定された桁揃えは適用される。その前にバックスペースを打
ち込む必要はない。

中間部分がマッチしたとき、終了部分もマッチしていてそちらの方が長い場合は、終了
部分が使われる。これによって C スタイルコメントが中間部分の末尾にスペースを付
けなくても機能するようになる。

桁揃えフラグを使ってコメントを目立たせる例を示す。'comments' が次のようになっ
ている場合: >
	:set comments=sr:/***,m:**,ex-2:******/
<
                                   /*** ~
                                     **<--"r" フラグによって右揃えされている ~
                                     ** ~
 "-2" フラグによってスペース         ** ~
 2 個分のオフセットがついている  --->** ~
                                   ******/ ~
これを入力する際、コメントの開始行を入力し、リターンを 4 回押す。そして "/"
を押せばコメントが終了する。

3部コメントについて、より細かいことをいくつか説明する。桁揃えフラグとオフセッ
トフラグが考慮される箇所は、次の3箇所ある。コメント開始行のあとの新規行を開く
とき、コメント終了行の前の新規行を開くとき、自動的にコメントを終了させるとき
である。終了部分の桁揃えフラグは、上の行を参照する。これによって、"s" と "e"
に同じ桁揃えフラグを指定したとき、開始部分と終了部分のインデント量が同じにな
る。コメントの部分ごとに1個だけの桁揃えが使われるようになっている。しかし、
オフセットの数は "r" と "l" フラグより優先する。

'cindent' をオンにしていると、多くの場合、桁揃えフラグより優先される。
|gq| や |=| を使って再インデントするときも、桁揃えフラグは適用されない。同じ
挙動を定義するには、それらのコマンドのオプションを使う。一つの考えとしては、
'cindent' に文脈に応じてコメントをインデントさせるオプションを追加することで
あるが、3部コメントの桁揃えを模倣することはほとんどできない。しかし
'indentexpr' は3部コメントをもっとうまく扱える可能性を持つ。

他の例: >
   "b:*"	"*" の後に非ブランク文字が付いていなければ、"*" で始まる行を
		含む。これはポインタの値への参照 "*str" が、コメントとして認識
		されるのを防ぐ。
   "n:>"	">", ">>", ">>>" などで始まる行を含む。
   "fb:-"	"- " で始まるリストを整形する。

既定では "b:#" が含まれている。これは "#include" で始まる行がコメントとならな
いことを意味する。しかし、"# define" で始まる行はコメントとなる。これは妥協的
解決である。

{Vimが |+comments| 機能付きでコンパイルされたときのみ有効}

							*fo-table*
テキストの整形方法はオプション 'formatoptions' で調整できる。 'formatoptions'
は以下のフラグを含む文字列である。既定値は "tcq" である。読みやすくするために、
フラグをコンマで区切ってもよい。

フラグ	 'formatoptions' に指定されたときの作用    ~

t	'textwidth' を使ってテキストを自動折返しする
c	'textwidth' を使ってコメントを自動折返して、現在のコメント開始文字列を
	自動挿入する。
r	挿入モードで <Enter> を打ち込んだ後に、現在のコメント開始文字列を自動
	挿入する。
o	ノーマルモードで 'o', 'O' を打ち込んだ後に、現在のコメント開始文字列を
	自動的に挿入する。
q	"gq" でコメントを整形する。
	NOTE 整形は空行やコメント開始文字列のみの行は変更しないことに注意。新
	しい段落はそのような行の次、またはコメント開始文字列が変わった所から始
	まる。
w	行末に空白が付いているとき、段落が次行に続いていると認識する。行末が空
	白以外の行で段落が終わるとする。
a	段落を自動整形する。テキストが挿入されたり削除されるたび、段落は再整形
	される。|auto-format| を参照。
	'c' フラグも設定されているときはコメント挿入時のみ機能する。
n	テキストの整形時、番号付きリストを認識する。これは実際には
        'formatlistpat' を使う。それゆえ、どんな種類のリストでも処理できる。
        数字の後のテキストのインデントが次の行に使われる。数字の後に '.', ':',
        ')', ']' や '}' が付いてもよい。 オプション 'autoindent' がオンでなけ
        ればならないことに注意。"2" と一緒には機能しない。例: >
		1. 一つ目の項目
		   折り返し
		2. 二つ目の項目
2	テキストを整形するとき、段落の最初の行ではなく2番目の行のインデントを
	使ってそれ以降の行を整形する。これは最初の行のインデントが他の行と異な
	るような段落をサポートする。'autoindent' もオンである必要がある。例: >
			ここはある段落の一行目
		ここは上の行と同じ段落の二行目
		ここは三行目。
<	これはコメントの中でも機能します (コメント文字がないかのように)。
v	挿入モードでVi互換の自動折返しを使う: 挿入モードに入って以来入力された
	空白でのみ折返しが行われる。( NOTE: これは100%のVi互換ではない。Viには
	このあたりに「予期できない機能」、というかバグがあった。Viは実際のテキ
	ストの列の代わりに画面上の列を使用する。)
b	'v' と同様だが、折返し余白の中または前で、空白を入力したときのみ自動折
	返しをする。挿入開始時に 'textwidth' より行が長かったり、'textwidth'
	に達するまで空白を入力しなかったときは、Vimは自動折返しをしない。
l	挿入モードでは長い行は折り返されない: 挿入開始時に行が 'textwidth' よ
	り長い場合、Vimは自動で整形を行わない。
m	文字コードが 255 より後のマルチバイト文字の間でも改行する。これは文字
	全てがそれだけで単語であるような、アジア言語のテキストで便利である。
M	行の連結時に、マルチバイト文字の前後に空白を挿入しない。こちらの方がフ
	ラグ 'B' より優先する。
B	行の連結時に、マルチバイト文字同士の間に空白を挿入しない。こちらよりフ
	ラグ 'M' の方が優先する。
1	1文字の単語の後では改行しない。代わりにその前で改行される (可能ならば)。
j	可能ならば、行を連結する際にコメントリーダーを削除する。例えば、以下の
	行を連結する場合:
		int i;   // the index ~
		         // in the list ~
	以下のようになる:
		int i;   // the index in the list ~


't' と 'c' でVimが自動折返しを行うタイミングを指定できる。
フラグ	作用	~
""	自動整形しない ("gq" で手動の整形処理を行う)
"t"	テキストを自動整形するが、コメントにはしない
"c"	コメントを自動整形するが、テキストにはしない (C言語コードに適している)
"tc"	テキストとコメントを自動整形する

NOTE 'textwidth' が 0 のとき、Vimはいかなる自動整形も行わないので注意
('comments' によるコメント開始文字列の挿入はする)。例外はフラグ 'a' が入ってい
る場合である。|auto-format|

NOTE 'paste' がオンのとき、Vimは全ての整形処理を行わないので注意。

NOTE Vimに自動折返しをさせなくても、'textwidth' は非 0 であってよいことに注意。
'textwidth' は "gq" による整形処理でも便利だからである。

'comments' が "/*" と ("*" と) "*/" を含んでいるときは、Vim組み込みの機能によ
りこれらのタイプのコメントをもう少し巧く扱うことができる。
('formatoptions' に 'r' か 'o' が含まれているとき) "/*" または "*/" の前か後で
新しい行を始めると、行の正しい開始位置が自動的に与えられる。同じことが整形処理
と自動折返しでも行われる。"/*" や "*" で始まり、かつ "*/" を含む行の後で行を始
めるときは、コメント開始文字列が挿入されず、新しい行のインデントはコメントの最
初の行に合わせられる。
例:
    /* ~
     * 典型的なコメント。 ~
     */ ~
    この行のインデントは、上のコメントの先頭行と同じになる。

これら全ては、特に異なるファイルタイプに対する異なる設定に対応する際、新しい
autocommand と連携して、クールに振舞うはずである。

いくつかの例:
  C言語コード用 (コメントの整形のみ): >
	:set fo=croq
< メール／ネットニューズ用 (全て整形、コマンド "o" でコメントを始めない): >
	:set fo=tcrq
<

自動整形					*auto-format* *autoformat*

オプション 'formatoptions' にフラグ 'a' が含まれると、テキストを挿入したり削除
したときに自動整形が行われる。これはテキストの段落分けを編集するときに便利であ
る。以下では使い方についてのヒントをいくつか。

- 段落を適切に定義する必要がある。もっとも単純なものは、空行が区切りになる場合
  である。区切りとなる空行がないときは、フラグ 'w' を使い、段落の最終行以外の
  行末に空白を付けるようにしてみること。

- 'formatoptions' をファイルタイプ |filetype| に基づいて設定することができる。
  またはモードライン |modeline| で特定のファイルに対して設定することもできる。

- 'formatoptions' を "aw2tcq" に設定し、テキストのインデントを次のようにするこ
  ともできる。

	    bla bla foobar bla 
	bla foobar bla foobar bla
	    bla bla foobar bla 
	bla foobar bla bla foobar

- コメントだけを自動整形するには 'c' フラグを追加する。ソースコードの編集向き。

- 行の長さを望みどおりにするには 'textwidth' を設定する。これが0ならば79になる。
  画面の幅が79桁より小さい場合は画面幅になる。

次にいくつかの警告:

- テキストの部分部分が段落内で適切に分割されていないとき、そのテキスト内で変更
  を行うと、有無をいわさず整形が始まってしまう。次のようにしてみること。 >

	:set fo-=a

- フラグ 'w' (行末の空白で段落が終わっていないことを判断する) を使っているとき
  に |dd| で段落の最終行を削除すると、その段落が次の段落とつながってしまう。

- 変更されたテキストは、アンドゥのために記憶される。整形も変更の一種である。そ
  のため、整形を行う度にテキストがアンドゥ用に記憶される。すると大量のメモリを
  消費するかもしれない。

- 長い段落や、複雑なインデントの段落を整形するのには、時間がかかることがある。

==============================================================================
7. テキストのソート					*sorting*

Vimはソート関数とソートコマンドを備えている。ソート関数については|sort()|を参
照。

							*:sor* *:sort*
:[range]sor[t][!] [i][u][r][n][x][o] [/{pattern}/]
			[range]の行をソートする。範囲が指定されない場合は全行
			をソートする。

			[!]をつけると順序が逆になる。
			
			[i]をつけると大文字・小文字を区別しない。

			[n]をつけると行の({pattern}のマッチの後ろまたは内側
			の)最初の10進数の数字でソートする。
			数字が '-' で始まる場合、マイナスとみなされる。

			[x]をつけると行の({pattern}のマッチの後ろまたは内側
			の)最初の16進数の数字でソートする。"0x" と "0X" は無視
			される。
			数字が '-' で始まる場合、マイナスとみなされる。

			[o]をつけると行の({pattern}のマッチの後ろまたは内側
			の)最初の8進数の数字でソートする。

			[u]をつけると連続する同一行の最初の行だけを残す。
			([i]がつくと大文字・小文字を無視する)
			このフラグがつかない場合、連続する同一行はそのままの順
			序で残される。
			Note: 行頭に行末の空白があると異なる行とみなされる。

			/pattern/が指定され、フラグ[r]がない場合は{pattern}に
			マッチするテキストはスキップされる。これによって、その
			マッチの後に来るテキストでソートできる。
			スラッシュの代わりにどんなnon-letterでも使うことができ
			る。
			例えば、カンマで区切られた2番目のフィールドでソートす
			るには: >
				:sort /[^,]*,/
<			画面上の10桁目でソートするには(そのためタブとスペース
			は同一視される): >
				:sort /.*\%10v/
<			行中の最初の数字でソートするには: >
				:sort /.\{-}\ze\d/
<			(解説: ".\{-}" は任意のテキストにマッチする。"\ze"
			はそのマッチの終わりをセットし、"\d" は数字にマッチ
			する。)
			[r]がつくと、前述のように{pattern}をスキップするのでな
			く、{pattern}にマッチする部分でソートする。
			例えば、各行の最初の3文字だけでソートするには: >
				:sort /\a\a\a/ r

<			{pattern}が使われると{pattern}を含まない行は現在の順序
			のままになる。逆順でソートすると、それらはソートされた
			行の後で逆順になる。逆順でなければ、ソートされた行の前
			でもとの順序のまま置かれる。

			{pattern} が空である場合(例: // が指定されたとき)、
			最後に使われた検索パターンが使われる。よって、まず検
			索コマンドでパターンを確かめてみることができる。

Note: `:global` といっしょに `:sort` を使ってもマッチする行をソートすることに
はならない。これはまったく無意味である。

ソートの詳細は使っているライブラリ関数による。ソートが「安定」であるとか現在の
ロケールに従うという保証はない。それを調べるには実行してみるしかない。

ソートは中断することができる。しかし中断するのが遅いと行が重複してしまうかもし
れない。これも使っているシステムのライブラリ関数による。

 vim:tw=78:ts=8:ft=help:norl:
