*cmdline.txt*   For Vim バージョン 7.3.  Last change: 2013 Mar 16


		  VIMリファレンスマニュアル    by Bram Moolenaar

				*Cmdline-mode* *Command-line-mode*
コマンドラインモード		*Cmdline* *Command-line* *mode-cmdline* *:*

コマンドラインモードはExコマンド (":")、検索パターン ("/" と "?")、フィルタコ
マンド ("!") の入力に使われる。

コマンドライン編集の基本は、ユーザマニュアルの第20章で説明されている
|usr_20.txt|。

1. コマンドラインの編集		|cmdline-editing|
2. コマンドラインの補完		|cmdline-completion|
3. Exコマンドライン		|cmdline-lines|
4. Exコマンドラインの範囲	|cmdline-ranges|
5. Exコマンドラインのフラグ	|ex-flags|
6. Exコマンド用の特別な文字	|cmdline-special|
7. コマンドラインウィンドウ	|cmdline-window|

==============================================================================
1. コマンドラインの編集					*cmdline-editing*

通常、文字はカーソル位置の前に挿入される。コマンドラインでは左右のカーソルキー
で移動ができる。<Insert>キーで挿入と上書を切り替えることができる。
{Vi: 行の最後の文字しか変更できない}

Note キーボードに有効なカーソルキーまたは他の特殊なキーが一切ないときでも、コ
マンド ":cnoremap" を使って他のキーをそれらに割り当てられることに注意。
例えば、tcsh風の編集キーを定義する方法は以下の通り。	*tcsh-style*  >
	:cnoremap <C-A> <Home>
	:cnoremap <C-F> <Right>
	:cnoremap <C-B> <Left>
	:cnoremap <Esc>b <S-Left>
	:cnoremap <Esc>f <S-Right>
(<> 記法を使っている |<>|．これらを全て文字通り打ち込むこと)

							*cmdline-too-long*
コマンドラインが長くなりすぎて画面に収まらなくなったときは、画面に入るだけの部
分が表示される。カーソルはこの見える部分しか動けない。そのため、これ以上は編集
できない。

						*cmdline-history* *history*
ユーザの打ち込んだコマンドは、履歴表に記録される。これらの履歴は上下矢印キーで
呼び出せる。実際には4つの履歴表がある。
履歴表:
- ':' コマンド用
- 検索文字列用
- 式 (expression) 用
- インプット行 (関数 |input()| に対して入力されたテキスト) 用
- デバッグモードコマンド用
これらは全く別のものである。それぞれの履歴は同種の入力をしたときだけ使用できる。
オプション 'history' で保存されるコマンド数を設定できる (既定値: 20)。
NOTE:
- 以前と全く同じコマンドを打ち込んだときは、古い方の記録が消される (繰り返され
  たコマンドが古いコマンドの履歴を追い出して消すのを避けるため)。
- 打ち込んだコマンドだけが記録される。完全にマッピングから実行されたコマンドは
  履歴に残らない。
- 全ての検索パターンは、コマンド "*" や "#" 等によるものも含め、検索用の履歴に
  記録される。しかしマッピングからの検索に対しては、最後の検索のみが記録される
  (長いマッピングが履歴の内容を捨ててしまうのを避けるため)。
{Vi: 履歴はない}
{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}

コマンドラインには名前の自動補完機能がある。|cmdline-completion| を参照。

							*c_CTRL-V*
CTRL-V		次に打ち込まれた非数字文字を、その通りに挿入する。また最大3個
		の数字により、1バイト文字をコードの10進表現に基づいて入力でき
		る。打ち込んだ非数字文字と3個の数字にはマッピングは適用されな
		い。これは挿入モードと同じ働きをする (|i_CTRL-V| を参照)。
		NOTE: Windowsでは CTRL-V はテキストの貼り付けにマッピングされ
		ていることが多い。そのときは代わりに CTRL-Q を使うこと。
							*c_CTRL-Q*
CTRL-Q		CTRL-V と同様だが、ターミナルによっては表示制御に使われている。
		その場合は使えない。

							*c_<Left>* *c_Left*
<Left>		カーソルを左へ
							*c_<Right>* *c_Right*
<Right>		カーソルを右へ
							*c_<S-Left>*
<S-Left> または <C-Left>				*c_<C-Left>*
		カーソルを 1WORD 分左へ
							*c_<S-Right>*
<S-Right> または <C-Right>				*c_<C-Right>*
		カーソルを 1WORD 分右へ
CTRL-B または <Home>				*c_CTRL-B* *c_<Home>* *c_Home*
		カーソルをコマンドライン先頭へ
CTRL-E または <End>				*c_CTRL-E* *c_<End>* *c_End*
		カーソルをコマンドライン末尾へ

							*c_<LeftMouse>*
<LeftMouse>	カーソルをマウスでクリックした所へ移動する

CTRL-H						*c_<BS>* *c_CTRL-H* *c_BS*
<BS>		カーソル前の文字を削除する (<BS> キーが思い通り働かないときは
		|:fixdel| を参照)。
							*c_<Del>* *c_Del*
<Del>		カーソル下の文字を削除する (行の最後では: カーソル前の文字)
		(<Del> キーが思い通り働かないときは |:fixdel| を参照。)
							*c_CTRL-W*
CTRL-W		カーソルの前の |word| を削除
							*c_CTRL-U*
CTRL-U		行頭とカーソル位置の間の全ての文字を削除する。Vimの以前の
		バージョンでは行内の文字を全て削除していた。その動作の方がよい
		なら、次の行をファイル .vimrc に加えること。 >
			:cnoremap <C-U> <C-E><C-U>
<
						*c_<Insert>* *c_Insert*
<Insert>	挿入／上書の切り替え  {Vi にはない}

{char1} <BS> {char2}	または				*c_digraph*
CTRL-K {char1} {char2}					*c_CTRL-K*
		ダイグラフの入力 (|digraphs| を参照)。{char1} が特殊キーのとき
		は、そのキーコードは <> 形式で挿入される。 {Vi にはない}

CTRL-R {0-9a-z"%#:-=.}					*c_CTRL-R* *c_<C-R>*
		番号/名前付きレジスタの内容を挿入する。CTRL-R を打ち込んで次の
		文字を打ち込むまでの間、レジスタ名の入力待ちであることを示すた
		め '"' が表示される。
		テキストは打ち込まれた通りに挿入され、マッピングや短縮入力は無
		効である。'wildchar' によるコマンドライン補完も行われない。
		またコマンドラインを終了する文字 (<Esc>, <CR>, <NL>, <C-C>) も
		文字通り挿入される。<BS> や CTRL-W はコマンドラインを終了でき
		るが、コマンドラインに残っている文字が違うモードで解釈されるこ
		となるので、意図とは異なる動作になるかもしれない。
		特殊なレジスタ:
			'"'	無名レジスタ、最後の削除やコピーによるテキスト
				を格納する。
			'%'	カレントファイル名
			'#'	代替ファイル名
			'*'	クリップボードの内容 (X11: primary selection)
			'+'	クリップボードの内容
			'/'	最後の検索パターン
			':'	最後のコマンドラインの内容
			'-'	最後の小規模な (1行未満の) 削除の内容
			'.'	最後に挿入されたテキスト
							*c_CTRL-R_=*
			'='	Expression レジスタ: 式を入力するよう要求され
				る (|expression| を参照)
				(Expressionプロンプトでは機能しない。バッファ
				変更やカレントウィンドウ変更などは副作用を避け
				るため許可されていない)
				結果がリスト |List| である場合、各要素が1行と
				して挿入される。行の中に改行文字が含まれていて
				もよい。
				結果が浮動小数点数である場合、自動的に文字列に
				変換される。
		レジスタに関しては |registers| を参照。 {Vi にはない}
		実装上の詳細: |expression|レジスタを使っているときに
		setcmdpos()を呼ぶと結果文字列を挿入する前の位置をセットする。
		挿入後の位置をセットするにはCTRL-R CTRL-Rを使うこと。

CTRL-R CTRL-F				*c_CTRL-R_CTRL-F* *c_<C-R>_<C-F>*
CTRL-R CTRL-P				*c_CTRL-R_CTRL-P* *c_<C-R>_<C-P>*
CTRL-R CTRL-W				*c_CTRL-R_CTRL-W* *c_<C-R>_<C-W>*
CTRL-R CTRL-A				*c_CTRL-R_CTRL-A* *c_<C-R>_<C-A>*
		カーソル下にオブジェクトを挿入する。
			CTRL-F	カーソル下のファイル名
			CTRL-P	|gf| と同様に 'path' を使って展開された、カー
				ソル下のファイル名
			CTRL-W	カーソル下の word
			CTRL-A	カーソル下の WORD; |WORD| を参照

		'incsearch' がセットされてるとき、現在表示されているマッチの末
		尾のカーソル位置が使われる。CTRL-Wではwordの一部がすでに入力さ
		れているとき、その部分がもう一度入力されることはない。
		{訳注: wordという単語のrの上にカーソルを置き、:wo<C-r><C-w>と
		してみると、'incsearch' の値によって結果が違うことがわかる}

		{Vi にはない}
		CTRL-F と CTRL-P: {Vimが |+file_in_path| 機能付きでコンパイル
		されたときのみ有効}

					*c_CTRL-R_CTRL-R* *c_<C-R>_<C-R>*
					*c_CTRL-R_CTRL-O* *c_<C-R>_<C-O>*
CTRL-R CTRL-R {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
CTRL-R CTRL-O {0-9a-z"%#:-=. CTRL-F CTRL-P CTRL-W CTRL-A}
		カーソル下にレジスタの内容またはオブジェクトを挿入。|c_CTRL-R|
		と同様の動作だが、テキストを文字通り挿入する。例えば、レジスタ
		"a の内容が "xy^Hz" (ここで ^H はバックスペース) のとき、
		"CTRL-R a" は "xz" を挿入するのに対し、"CTRL-R CTRL-R a" は
		"xy^Hz" を挿入する。

CTRL-\ e {expr}						*c_CTRL-\_e*
		コマンドラインを {expr} を評価した結果で置き換える。式を入力し
		<Enter> を押せば完了する。マッピングする時に使うと便利である。
		|expression| も参照のこと。
		式の評価を挿入するには |c_CTRL-R_=| を使う。便利な関数に
		|getcmdtype()| と |getcmdline()| と |getcmdpos()| がある。
		カーソルが行末になければカーソル位置は変更されない。カーソルが
		行末にあるときのコマンドライン変更後のカーソル位置は行末であ
		る。|setcmdpos()| を使うとカーソル位置を変更できる。
		|sandbox| を使うと不要な副作用を避けて式を評価することができ
		る。
		例: >
		  :cmap <F7> <C-\>eAppendSome()<CR>
		  :func AppendSome()
		    :let cmd = getcmdline() . " Some()"
		    :" place the cursor on the )
		    :call setcmdpos(strlen(cmd))
		    :return cmd
		  :endfunc
<		これは再帰的には機能しない。つまり、すでに式を編集しているとき
		は動作しない。ただしマップの中では再帰的に使える。

							*c_CTRL-Y*
CTRL-Y		モードレスセレクションでテキストを選択中のとき、テキストをクリッ
		プボードにコピーする。 |modeless-selection|
		選択中でないときは、CTRL-Y は文字として挿入される。

CTRL-J					*c_CTRL-J* *c_<NL>* *c_<CR>* *c_CR*
<CR> または <NL>
		入力されたコマンドの実行
							*c_<Esc>* *c_Esc*
<Esc>		打ち込まれたときにオプション 'cpoptions' にフラグ 'x' が含まれ
		ていなければ、コマンドを実行せずにコマンドラインモードを終了す
		る。マクロ内で使われたとき、または 'cpoptions' に 'x' が含まれ
		ているときは、コマンドラインを実行する。
		Note: お使いのキーボードで <Esc> が押しづらい場合は、CTRL-[
		を使うよう練習してください。
							*c_CTRL-C*
CTRL-C		コマンドを実行せずにコマンドラインモードを終了する。

							*c_<Up>* *c_Up*
<Up>		古いコマンドラインの内容のうち、先頭部分が現在のコマンドライン
		とマッチするものを履歴から呼び出す (下を参照)。
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}
							*c_<Down>* *c_Down*
<Down>		さらに最近のコマンドラインの内容のうち、先頭部分が現在のコマン
		ドラインとマッチするものを履歴から呼び出す (下を参照)。{訳注:
		変な訳ですが、<Up> で行き過ぎたら <Down> で戻るということです}
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}

						*c_<S-Up>* *c_<PageUp>*
<S-Up> または <PageUp>
		履歴から古いコマンドラインの内容を呼び出す。
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}
						*c_<S-Down>* *c_<PageDown>*
<S-Down> または <PageDown>
		履歴からさらに最近のコマンドラインの内容を呼び出す。
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}

CTRL-D		コマンドライン補完 (|cmdline-completion|を参照)
オプション 'wildchar' で指定したキー
		コマンドライン補完 (|cmdline-completion|を参照)
CTRL-N		コマンドライン補完 (|cmdline-completion|を参照)
CTRL-P		コマンドライン補完 (|cmdline-completion|を参照)
CTRL-A		コマンドライン補完 (|cmdline-completion|を参照)
CTRL-L		コマンドライン補完 (|cmdline-completion|を参照)

							*c_CTRL-_*
CTRL-_		1. キーボードのヘブライ語モードと英語モードを切り替える。これ
		はコマンドラインのみに適用され、'hkmap' とは関係ない。
		コマンドライン、検索や短縮入力等にヘブライ語テキストの項目が必
		要とされるときに便利である。Vimが |+rightleft| 機能付きでコン
		パイルされ、'allowrevins' がオンのときのみ有効。
		|rileft.txt| を参照。

		2. キーボードのペルシア語モードと英語モードを切り替える。これ
		はコマンドラインのみに適用され、オプション 'fkmap' には関係し
		ない。ペルシア語モードでは、文字は普段とは反対の方向に挿入され
		る。コマンドライン、検索や短縮入力等にペルシア語テキストの項目
		が必要とされるときに便利である。Vimが |+farsi| 機能付きでコン
		パイルされたときのみ有効。
		|farsi.txt|を参照。

							*c_CTRL-^*
CTRL-^		言語マッピング |:lmap| を切り替えたり、Input Method (IM) を切
		り替える。
		検索コマンドのためにパターンを入力するとき、オプション
		'imsearch' が -1 でなければ VAL は 'imsearch' の値に、そうでな
		ければ VAL は 'iminsert' の値になる。
		言語マッピングが定義されているとき:
		- VAL が 1 のとき (言語マッピングが使われているとき) 0 に変わ
		  る (言語マッピングは使われなくなる)。
		- VAL が 1 でなければ 1 に変わり、言語マッピングが有効になる。
		言語マッピングが全く定義されていないとき:
		- VAL が 2 のとき (IMが使われているとき) 0 に変わる (IMは使わ
		  れなくなる)
		- VAL が 2 以外のときは 2 に変わり、IMが有効になる。
		普通、言語マッピングは、キーボードが生成するのと違う文字を打ち
		込むのに使われる。オプション 'keymap' を使えばまとめて設定でき
		る。
		コマンドラインに入ったときは、コマンドを打ち込むはずなので、言
		語マッピングはオフに切り替えられる。CTRL-^ でオンにした後も、
		次にコマンドや検索パターンを打ち込むときにはその状態は使われな
		い。
		{Vi にはない}

						*c_CTRL-]*
CTRL-]		文字を挿入することなく短縮入力を展開する。{Vi にはない}

コマンドラインをEmacsスタイルで編集する方法については |emacs-keys| を参照。

キー <Up> と <Down> は現在のコマンドラインを検索文字列として扱う。次／以前のコ
マンドラインの先頭部分が、この文字列と比較される。マッチした最初の行が新しいコ
マンドラインとなる。これら2つのキーを繰り返し入力すると、同じ文字列が検索に使
われる。例えば、以前の置換コマンドを見つけるためにはこうする: ":s" の後 <Up>
を打ち込むこと。同じことは、<S-Up> を望んだ行が出るまで数回打ち込むことでもで
きる。( Note: シフトキーと矢印キーとの同時押しは、全ての端末で機能するわけでは
ないことに注意)

							*:his* *:history*
:his[tory]	最近入力されたコマンドの履歴を表示する。
		{Vi にはない}
		{Vimが |+cmdline_hist| 機能付きでコンパイルされたときのみ有効}

:his[tory] [{name}] [{first}][, [{last}]]
		{name} の種類の履歴内容を一覧表示する。{name} に入るものは:
		c[md]	 または :		コマンドラインの履歴
		s[earch] または / または ?	検索文字列の履歴
		e[xpr]	 または =		Expression レジスタの履歴
		i[nput]	 または @		入力行の履歴
		d[ebug]	 または >		デバッグコマンドの履歴
		a[ll]				上記のもの全て
		{Vi にはない}

		{first}や{last}が指定されたときは、履歴中の指定された範囲の
		項目が表示される。これらの数字は次の形式で指定する。
							*:history-indexing*
		正数は、":history" の一覧表示で最初の列に表示される、項目の絶
		対的な番号を表す。この数字は、他の項目が削除されても固定された
		ままである。

		負数は項目の相対的な位置を示す。これは最も新しい項目 (番号 -1
		を持つ) から後ろ向きに数えたものである。

		例:
			検索履歴の項目6から12までを一覧表示する。 >
			:history / 6,12
<
			全履歴の最近の5項目を一覧表示する。 >
			:history all -5,

==============================================================================
2. コマンドラインの補完					*cmdline-completion*

コマンドラインの編集をしているとき、いくつかのコマンドを使ってカーソル前の単語
を補完できる。補完は以下のものに対して有効である。

- コマンド名: コマンドラインの先頭で使われる
- タグ: コマンド ":tag" の後でのみ使われる
- ファイル名: ファイル名を取るコマンドの後、またはファイル名に対して設定される
  オプションの設定時のみ使われる。これはファイル名補完と呼ばれる。
- シェルコマンド名: ":!cmd"、":r !cmd"、":w !cmd" の後で使われる。$PATHが考慮
  される。
- オプション: コマンド ":set" の後でのみ使われる。
- マッピング: ":map" や類似コマンドの後でのみ使われる。
- 変数／関数名: ":if", ":call" や類似コマンドの後でのみ使われる。

Vimが |+cmdline_compl| 機能付きでコンパイルされなかったときは、ファイル名、ディ
レクトリ名、ヘルプの項目のみが補完される。マッチするヘルプ項目の個数には上限が
ある(現在のところは 300)。非常に多くのマッチがあったとき、遅くなるのを避けるた
めである。

補完に使えるコマンドは以下の通り。

							*c_CTRL-D*
CTRL-D		カーソルより前のパターンに一致する名前を一覧表示する。ファイル
		名を表示しているときには、ディレクトリは強調表示される (オプショ
		ン 'highlight' を参照)。オプション 'suffixes' の値がマッチした
		名前は、末尾の方に移動される。
		'wildoptions' を "tagfile" にセットすると、マッチするタグを含
		むファイル名をリストすることができる。
					*c_CTRL-I* *c_wildchar* *c_<Tab>*
オプション 'wildchar' で指定したキー
		カーソルより前のパターンに対してマッチの検索が行われる。マッチ
		(いくつかあるなら、最初のもの) が、そのパターンの位置に挿入さ
		れる。( Note: これはマクロの中では機能しない。なぜなら <Tab>
		と <Esc> は大抵 'wildchar' として使われ、またいくつかのマクロ
		の中ではこれらが特別な意味を持つからである) このキーを再び入力
		すると、複数のマッチがあるときは、次のマッチが挿入される。最後
		のマッチの後には、最初のマッチが再び使われる (繰り返し)。
		この動作は、オプション 'wildmode' で変更できる。
							*c_CTRL-N*
CTRL-N		'wildchar' を使ったら複数のマッチがあったとき、その後に使うと
		次のマッチが挿入される。それ以外のときには、より最近使ったコマ
		ンドラインを履歴から呼び出す。
<S-Tab>							*c_CTRL-P* *c_<S-Tab>*
CTRL-P		'wildchar' を使ったら複数のマッチがあったとき、その後に使うと
		前のマッチが挿入される。それ以外のときには、より昔に使ったコマ
		ンドラインを履歴から呼び出す。<S-Tab> はGUI版、Amiga版と
		MS-DOS版でのみ機能する。
							*c_CTRL-A*
CTRL-A		カーソルより前のパターンに一致する、全ての名前が挿入される。
							*c_CTRL-L*
CTRL-L		カーソルより前のパターンに対してマッチの検索が行われる。マッチ
		が1個のときは、それがパターンの位置に挿入される。複数個のマッ
		チがあったときは、最も長い共通部分がパターンの位置に挿入される。
		その結果がパターンより短い場合には、補完は行われない。
		'incsearch' がセットされていると、"/" や "?" で検索パターンを
		入力するとき現在のマッチが表示され、CTRL-Lを押すと現在のマッチ
		の末尾から1文字追加する。'ignorecase' と 'smartcase' がセット
		されていてコマンドラインに大文字が含まれていないときは、追加さ
		れた文字は小文字に変換される。

オプション 'wildchar' の既定値は <Tab> である (Vi互換モードの場合は CTRL-E で
ある。以前のバージョンでは <Esc> が使われていた)。パターンがファイル名に対して
適用されるときは標準のワイルドカード '*' と '?' が使用できる。'*' はあらゆる文
字列に一致し、'?' はちょうど 1文字に一致する。

オプション 'wildignorecase' を設定するとファイル名の大文字と小文字を区別しない
ようにできる。

tcshのautolist補完が好みなら、このマッピングが使える。 >
	:cnoremap X <C-L><C-D>
(ここで X は使いたいコマンドキー。<C-L> は CTRL-L, <C-D> は CTRL-D のこと)
これは最長のマッチを見つけ、マッチしたファイルを全て一覧表示する。

tcshのautolist補完が好みなら、オプション 'wildmode' を使ってその動作をエミュ
レートできる。例えば、次の設定は autolist=ambiguous という設定を真似る。 >
	:set wildmode=longest,list
これは、最初の 'wildchar' で最長のマッチを見つけ、次はマッチするファイルを全て
一覧表示する。

							*suffixes*
ファイル名補完では、オプション 'suffixes' を使い、ほぼ同じ名前のファイル名に優
先度を設定できる。複数のマッチがあったとき、あるファイルの拡張子が 'suffixes'
の値に含まれていると、そのファイルは無視される。既定値は
".bak,~,.o,.h,.info,.swp" であり、これは ".bak", "~", ".o", ".h", ".info",
".swp" で終わるファイルが無視されることがあるということである。

空の項目(つまり2つの連続するカンマ)は "." を含まないファイル名(つまり拡張子を
持たない)にマッチする。これは "prog" を無視させ、かつ "prog.c" にマッチさせた
いときに便利である。

例:

  パターン:	存在するファイル:		マッチ:	~
   test*	test.c test.h test.o		test.c
   test*	test.h test.o			test.h and test.o
   test*	test.i test.h test.c		test.i and test.c

2つのドットを持つ拡張子を無視することはできない。

(オプション 'suffixes' による除外が行われた後で) マッチするファイルが複数個あ
るときは、最初のファイル名が挿入される。'wildchar' のキーを2度打ち込んでも補完
されたマッチが同じだったら、マッチが1つしかないことが分かる。他のマッチは、
'wildchar' のキーまたは CTRL-N, CTRL-P を入力することで得られる。それには
'suffixes' に設定された拡張子にマッチするものも含め、全てのファイルが含まれる。

ある拡張子のファイルを完全に無視するにはオプション 'wildignore' を使うこと。

入力されたテキストで終わるファイルにのみマッチさせるには、"$" をつけること。例
として、".c" で終わるファイルにのみマッチさせるには: >
	:e *.c$
これは ".cpp" で終わるファイルにはマッチしない。"$" をつけないとマッチする。

オプションの、以前に設定された値は、'=' の後で 'wildchar' のキーを打ち込むこと
で得られる。例えば、":set dir=" の後で 'wildchar' のキーを打ち込むと、'dir' の
現在の値が挿入される。この動作は、ファイル名を取るオプションに対するファイル名
補完より優先する。

xtermで <S-Tab> を CTRL-P として使いたいときは、このコマンドをユーザの .cshrc
に加えること。 >
	xmodmap -e "keysym Tab = Tab Find"
そして次を .vimrc に加えること。 >
	cmap <Esc>[1~ <C-P>

==============================================================================
3. Exコマンドライン					*cmdline-lines*

Exコマンドはいくつかの特徴を持っている。

							*:quote* *:comment*
行の最初に '"' があると、その行全てが無視される。'"' がコマンドの後にあると、
その行の残りの部分が無視される。これはコメントを加えるために使われる。例: >
	:set ai		"set 'autoindent' option
シェルコマンド ":!cmd", コマンド ":map" とその他いくつかのコマンドにはコメント
を付けることができない。これらのコマンドは '"' を引数の一部として認識するから
である。各コマンドの説明のところにその旨の注意がある。

							*:bar* *:\bar*
'|' を使ってコマンドを区切ることができる。これにより一行に複数のコマンドを書き
込める。引数に '|' を使いたいときは、'\' を前に置くこと。

以下のコマンドは '|' を引数として認識するため、後に他のコマンドを続けることは
できない。
    :argdo
    :autocmd
    :bufdo
    :command
    :cscope
    :debug
    :folddoopen
    :folddoclosed
    :function
    :global
    :help
    :helpfind
    :lcscope
    :make
    :normal
    :perl
    :perldo
    :promptfind
    :promptrepl
    :pyfile
    :python
    :registers
    :read !
    :scscope
    :sign
    :tcl
    :tcldo
    :tclfile
    :vglobal
    :windo
    :write !
    :[range]!
    引数 "-bar" なしで定義されたユーザコマンド |:command|

Note: (Viから継承されたのだが) 次の点は混乱を招きやすいので注意: '|' は ":g"
と共に使うとコマンドの引数に含まれるが、":s" ではコマンドの区切りになる。

どうしても他のコマンドを使いたいときは、コマンド ":execute" を使うこと。
例 (バッファに外部コマンド "ls" の出力を追加し、最初の行にジャンプする): >
	:execute 'r !ls' | '[

例外が1点ある: オプション 'cpoptions' にフラグ 'b' が含まれるときは、":map",
":abbr" またはその類似コマンドの引数に '|' を使うとき、'\' の代わりに CTRL-V
を使う必要がある。代わりに "<Bar>" を使うこともできる。|map_bar| も参照。

例: >
	:!ls | wc		2つのコマンドの出力を見る
	:r !ls | wc		その出力をテキストに挿入する
	:%g/foo/p|>		一致した全ての行をshiftwidth1個分ずらす
	:%s/foo/bar/|>		1つの行をshiftwidth1個分ずらす
	:map q 10^V|		"q" に "10|" をマッピングする
	:map q 10\| map \ l	"q" に "10\" を、"\" に "l" をマッピングする
					('b' が 'cpoptions' に含まれるとき)
<
<NL> を使って、'|' と同様にコマンドを区切ることができる。<NL> を挿入するには
CTRL-V CTRL-J を使うこと。すると "^@" が表示される。'|' を使う方が好ましいが、
外部コマンドに対しては、'|' が外部コマンドに含まれてしまうため、<NL> を使わな
ければならない。<NL> の特別な作用を避けるためには、前に '\' を置く必要がある。
例: >
	:r !date<NL>-join
これは現在の日時をファイルに読み込み、それを前の行につなげる。

Note: '|' の前のコマンドがエラーを起こしたときは、以降のコマンドは実行されない
ことに注意。


Viとの互換性のために、以下の奇妙なコマンドがサポートされている。 >
	:|			現在行を表示する (":p" と同様)
	:3|			3行目を表示する (":3p" と同様)
	:3			3行目に移動する

範囲とコマンド名の間にコロンを入れることができる。このコロンは無視される (これ
はVi互換の動作である)。例: >
	:1,$:s/パターン/文字列

ファイル名が入るべき場所に、文字 '%' または '#' が使われているときは、それらは
カレントファイル名、代替ファイル名に展開される ("ファイルの編集" の章を参照
|:_%| |:_#|)。

Amigaでは、引数がファイル名1個になるはずのとき、空白を含むファイル名が使用でき
る。ファイル名末尾の空白は、'\' や CTRL-V でエスケープされていない限り無視され
る。 NOTE: コマンド ":next" では、ファイル名の区切りに空白を使うことに注意。ファ
イル名に空白を含むには、エスケープすること。例: >
	:next foo\ bar goes\ to school\
こうすると3個のファイル "foo bar", "goes to", "school " の編集を開始する。

コマンドで特別な文字 '"', '|' を使いたいとき、あるいはファイル名に '%', '#' を
使いたいときは、'\' を前に置く。範囲指定やコマンド ":substitute" では '\' は必
要ない。

							*:_!*
Exコマンドの後に文字 '!' (bang) を置くと、コマンドの動作方法が変わる。'!' はコ
マンドの直後に置かなければならず、間に空白を入れてはならない。空白を挿入すると、
'!' はコマンドの引数と見なされ、違った意味を持つことになる。例: >
	:w! name	現在のバッファをファイル "name" に保存し、ファイルがす
			でに存在していると上書きする
	:w !name	現在のバッファを、標準入力からの入力としてコマンド
			"name" に送る

==============================================================================
4. Exコマンドラインの範囲		*cmdline-ranges* *[range]* *E16*

Exコマンドには、その前に行単位の範囲を指定できるものがある。これは [range] と
表記される。それは ',' か ';' で区切られた、1個以上の行指定子から成る。

基本事項はユーザマニュアルの |10.3| 章で説明されている。

						*:,* *:;*
区切りに ';' を使うと、次の行指定子を解釈する前にカーソル位置がその行に移動
する。',' ではこうならない。例: >
	4,/この行/
		4行目から、カーソルより後の、"この行" がマッチする行まで。
	5;/あの行/
		5行目から、5行目より後の、"あの行" がマッチする行まで。

ほとんどのコマンドでは、範囲の既定値はカーソルのある行である。しかしコマンド
":write", ":global" での既定値はファイル全体 (1,$) である。

コマンドに必要以上の行指定子が指定されたときは、先頭の方に指定されたものから順
に除外される。

行番号は以下の方法で指定できる:			*:range* *E14* *{address}*
	{number}	絶対的な行番号
	.		現在の行				  *:.*
	$		ファイルの最終行			  *:$*
	%		1,$と同じ (ファイル全体)		  *:%*
	't		マーク tの位置 (小文字)			  *:'*
	'T		マーク Tの位置 (大文字); マーク位置が別ファイルにある
			ときには範囲指定には使えない
	/{pattern}[/]	次に {pattern} のマッチする行 (下向き)	  *:/*
	?{pattern}[?]	次に {pattern} のマッチする行 (上向き)	  *:?*
	\/		次に直前の検索パターンのマッチする行 (下向き)
	\?		次に直前の検索パターンのマッチする行 (上向き)
	\&		次に直前の置換元パターンのマッチする行 (下向き)

これらの後に '+' または '-' と数値を付けてもよい (複数も可)。この数は直前の行
番号に加算または減算される。数が省略された場合は 1 が指定されたと見なされる。

{pattern} の後の "/" と "?" は、パターンとその後の項目とを区別するために必要と
なる。

"/" と "?" は別の場所指定の後に付くことがある。すると検索はそこから始まる。';'
との違いは、カーソルが移動しない点である。例: >
	/pat1//pat2/	"pat1" を含む行より後の、"pat2" を含む行を見つける。こ
			のときカーソルは移動しない。
	7;/pat2/	7行目より後の、"pat2" を含む行を見つける。このときカー
			ソルは7行目に留まる。

{number} は 0 からファイルの行数までの数でなければならない。0 (零) を使うと、
コマンドの大半では 1 と解釈される。その数をカウントとして使うコマンド (|:tag|,
|:pop| 等) では確かに 0 として使われる。0 を「先頭行の前」として解釈するコマン
ドもある (|:read|, 検索パターン等)。

Examples: >
	.+3		カーソルの3行下
	/that/+1	次行より下の、"that" を含む行
	.,$		現在行からファイル末尾まで
	0;/that		"that" を含む最初の行 (第1行にもマッチ可能)
	1;/that		第1行より下の、"that" を含む行

いくつかのコマンドには、後にカウントを指定できる。そのコマンドは、最後の行指定
子で指定された行 (既定値はカーソルの行) から始まる、そのカウントの行数の範囲に
使われる。カウントを取ることができるのは、範囲指定は取るがファイル名の引数を取
らないコマンドである (ファイル名は数字でもよいから)。

例: >
	:s/x/X/g 5	現在行から始まる5行で 'x' を 'X' に置換
	:23d 4		第23, 24, 25, 26行を削除


折り畳みと範囲指定

折り畳みがアクティブなときは、閉じられた折り畳み全体を含むように範囲が切り上げ
／切り下げられる。 |fold-behavior| を参照。


逆向きの範囲指定						*E493*

範囲には小さい行番号を先に指定しなければならない。そうでないときは、Vimはその
行番号を入れ替えてよいかを尋ねる。
	Backwards range given, OK to swap ~
ただしグローバルコマンド ":g" では尋ねない。

コマンドの前に ":silent" をつけるとこの質問が出ないようになる。そのときは常に
範囲が入れ替えられる。


カウントと範囲指定						*N:*

":" を入力する前にカウントを指定すると、次のように変換される。 >
		:.,.+(count - 1)
つまりカーソルの行から始まる [count] 行のことである。例: 3行を削除するにはこう
する。 >
		3:d<CR>		は	.,.+2d<CR>	に変換される
<

ビジュアルモードと範囲指定					*v_:*

{Visual}:	ビジュアルに選択された行を範囲として、コマンドライン入力を始め
		る。この範囲指定にはコード `:'<,'>` が使われるので、コマンドラ
		イン履歴から同様のコマンド行を呼び出して、別のビジュアル選択行
		にコマンドを繰り返すことができる。
		ビジュアルモードがすでに終了しているときは、`:*` を使うことで
		簡単にビジュアル選択を範囲指定できる。ただし "*" が 'cpo' オプ
		ションに含まれているいるときは使えない (|cpo-star| 参照)。その
		ときは `:'<,'>` を使う必要がある。


==============================================================================
5. Ex コマンドラインのフラグ				*ex-flags*

以下のフラグがExコマンドの選択においてサポートされている。
これらはコマンドを実行した後にカーソルが移動する位置の行を表示する:

	l	|:list|のように表示する
	#	行番号をつける
	p	|:print|のように表示する

これらのフラグは組み合わせることができる。つまり "l#" とすると行番号をつけて
":list" のスタイルで表示する。

==============================================================================
6. Exコマンド用の特別な文字				*cmdline-special*

Note: 以下はコマンドラインの実行における特別な文字である。CTRL-Rコマンドを使う
とこれらの特別な文字列を挿入することができる。例えば "%" は現在のファイル名を
表す。CTRL-R %とするとその場に現在のファイル名を挿入する。|c_CTRL-R|を参照。

Note: Vim スクリプト内で特別な文字をエスケープするには |fnameescape()| を使う
とよいかもしれない。

Exコマンドの、ファイル名が使えるところでは、以下の文字は特別な意味を持つ。これ
らは式や関数 |expand()| 内でも使うことができる。
	%	カレントファイル名に置き換えられる。		  *:_%* *c_%*
	#	代替ファイル名に置き換えられる。		  *:_#* *c_#*
	#n	(ここで n は数) バッファ n のファイル名に置き	  *:_#0* *:_#n*
	        換えられる。"#0" は "#" と同じ。		  *c_#n*
	##	引数リスト内の全てのファイル名を、空白で区切って  *:_##* *c_##*
		列挙したものに置き換えられる。ファイル名の中の空白には、
		全て前に '\' が付けられる。
	#<n	(n は > 0 の数値)。				  *:_#<* *c_#<*
		n 番目の old file 名に置き換えられる。
		この番号については |:oldfiles| や |v:oldfiles| を参照。
		*E809*
		{|+eval| と |+viminfo| 機能つきでコンパイルされたときのみ有効}

Note: "#<n" 以外は、ユーザに打ち込まれた通りのファイル名を与えることに注意
{訳注: 普通、カレントディレクトリのファイルは、パスを付けずにファイル名のみを
打ち込んで編集を始めるはずだが、その形でファイル名が呼び出される}。絶対パスが
必要なとき(違うディレクトリのファイル名を使うとき) は、":p" を付け加える必要が
ある。|filename-modifiers|を参照。

"#<n" は絶対パスを返す。ただしホームディレクトリ以下のファイルに対しては "~/"
で始まる。

コマンドが適切に解釈できるように、スペースの前にはバックスラッシュがつく。しか
しシェルコマンドに対してはこれは行われない。シェルコマンドに対しては、引用符を
使うとよいかもしれない(しかしこれは引用符とワイルドカードを含む文字列に対して
は失敗する): >
	:!ls "%"
	:r !spell "%"

'%' と '#' の特別な意味を避けるためには、その前に '\' を挿入する。
詳細: これらの文字の特別な意味は、'\' がその前に置かれれば、それがいくつあるか
に関わらず、常にエスケープ (無効化) される。
	打ち込むキー:		結果	~
	   #			代替ファイル名
	   \#			#
	   \\#			\#

			       *:<cword>* *:<cWORD>* *:<cfile>* *<cfile>*
			       *:<sfile>* *<sfile>* *:<afile>* *<afile>*
			       *:<abuf>* *<abuf>* *:<amatch>* *<amatch>*
			       *<slnum>* *E495* *E496* *E497* *E499* *E500*
Note: これらは文字通りに打ち込まれる、これらは特別なキーではない！
	<cword>    カーソル下の word に置き換えられる (|star| と同様)
	<cWORD>    カーソル下の WORD に置き換えられる (|WORD| を参照)
	<cfile>    カーソル下のパス名に置き換えられる (|gf| が使うものと同様)
	<afile>    自動コマンドの実行時、ファイルの読み書き用のファイル名に置
		   き換えられる
	<abuf>     自動コマンドの実行時、カレントバッファの番号に置き換えられ
		   る (":r file" と ":so file" のときにもカレントバッファの番
		   号に置き換えられる。読み込まれているファイルはバッファ内に
		   ない)
	<amatch>   自動コマンドの実行時、この自動コマンドが実行されたときのマッ
		   チに置き換えられる。そのファイル名がマッチの検索に使われて
		   いないときのみ、<afile> と違う値になる (イベント FileType
		   や Syntax、SpellFileMissing 用)。
	<sfile>    コマンド ":source" の実行時、取り込まれたファイルのファイル
		   名に置き換えられる。  *E498* 
		   関数の実行時、"関数 {関数名}" に置き換えられる。関数呼び出
		   しのネスト (入れ子状態) はこのように表される:
		   "関数 {関数名1}..{関数名2}"。 Note: 関数内で <sfile> が使わ
		   れている場合、ファイル名修飾子は無効になることに注意。
	<slnum>	   コマンド ":source" の実行時、行番号に置き換えられる。
	           *E842*
		   関数の中では、関数の先頭からの相対的な行番号になる。

							 *filename-modifiers*
	 *:_%:* *::8* *::p* *::.* *::~* *::h* *::t* *::r* *::e* *::s* *::gs*
	        *%:8* *%:p* *%:.* *%:~* *%:h* *%:t* *%:r* *%:e* *%:s* *%:gs*
ファイル名修飾子は "%", "#", "#n", "<cfile>", "<sfile>", "<afile>", "<abuf>"
の後で使うことができる。これらは関数 |fnamemodify()| と使うこともできる。Vim
が |+modify_fname| 機能付きでコンパイルされていなければ、これらの修飾子を使う
ことはできない。
これらの修飾子は次の順で指定できる。
	:p	ファイル名を完全パスにする。最初の修飾子でなければならない。
		また "~/" (およびUnixやVMSで使われる "~user/" の形式のもの) も
		ホームディレクトリのパスに変換する。これが付けられたものがディ
		レクトリ名に展開されるならば、パスの区切り文字が末尾に追加され
		る。これが付けられたものが、ディスク上に存在せず絶対パスを持た
		ないファイルに展開されるときは、結果は予期できない。MS-Windows
		では 8.3 形式のファイル名はロングファイル名に展開されます。
	:8	パスを短い8.3形式に変換する (現在のところ MS-Windows 版での
		み)。パスの内、実際に存在する部分に対して機能する。
	:~	ファイル名をホームディレクトリについて相対的な名前に (可能なら
		ば) 切り詰める。ファイルがホームディレクトリの下になければ、ファ
		イル名は修正されない。
	:.	ファイル名をカレントディレクトリについて相対的な名前に (可能な
		らば) 切り詰める。ファイル名がカレントディレクトリの下になけれ
		ば、ファイル名は修正されない。
		最も短く切り詰めるには ":~:." を使う。
	:h	ファイル名のヘッド (末尾の部分と全ての区切りが除かれたもの)。
		:e, :r, :t には使えない。
		繰り返すと、末尾から順に複数の部分を取り除くことができる。
		ファイル名がパス区切りで終わるときは、パス区切りのみが取り除か
		れる。そのためディレクトリ名に ":p:h" を使うと、(末尾にパス区
		切りなしの) ディレクトリ名そのものが得られる。
		ファイル名が絶対パス (Unixでは "/"; MS-DOS, WIN32, OS/2では
		"x:\"; Amigaでは "drive:" で始まるもの) のときは、この部分は取
		り除かれない。ヘッドがないときは (パスがカレントディレクトリに
		対して相対的なとき)、結果は空となる。
	:t	ファイル名のテール (名前の末尾の部分)。:r または :e よりも前に
		指定しなければならない。
	:r	ファイル名のルート (最後の拡張子が取り除かれたもの)。拡張子だ
		けしかないときは ('.' で始まるファイル名、例えば ".vimrc" 等)、
		それは取り除かれない。繰り返し使うと、複数の拡張子を (最後のも
		のから順に) 取り除くことができる。
	:e	ファイル名の拡張子。単独で使われたときのみ意味を持つ。
		拡張子がないときは、結果は空となる。
		拡張子だけしかないときは ('.' で始まるファイル名)、結果は空と
		なる。繰り返すと、複数の拡張子が得られる。繰り返した回数より拡
		張子の数の方が少ないときは、可能なだけ取り込まれる (しかし最低
		でも1個はないと取り込まれない)。
	:s?pat?sub?
		最初に "pat" に一致したものを "sub" に置き換える。これはコマン
		ド |:s| と同様に機能する。"pat" は正規表現である。'?' には任意
		の文字を使えるが、"pat" や "sub" 内に現れてはならない。
		この後、上述の修飾子を再び使うことができる。例えば、":p" では
		置換した後でフルパスに変える。
	:gs?pat?sub?
		"pat" に一致したものを全て "sub" に置き換える。その他の点では
		":s" と同様に機能する。

ファイル名が "src/version.c"、カレントディレクトリが "/home/mool/vim" のときの
例: >
	:p			/home/mool/vim/src/version.c
	:p:.				       src/version.c
	:p:~				 ~/vim/src/version.c
	:h				       src
	:p:h			/home/mool/vim/src
	:p:h:h			/home/mool/vim
	:t					   version.c
	:p:t					   version.c
	:r				       src/version
	:p:r			/home/mool/vim/src/version
	:t:r					   version
	:e						   c
	:s?version?main?		       src/main.c
	:s?version?main?:p	/home/mool/vim/src/main.c
	:p:gs?/?\\?		\home\mool\vim\src\version.c

ファイル名が "src/version.c.gz" のときの例: >
	:p			/home/mool/vim/src/version.c.gz
	:e						     gz
	:e:e						   c.gz
	:e:e:e						   c.gz
	:e:e:r						   c
	:r				       src/version.c
	:r:e						   c
	:r:r				       src/version
	:r:r:r				       src/version
<
					*extension-removal* *:_%<*
"%", "#", "#n" または "CTRL-V p" に "<" を付け加えたとき、ファイル名の拡張子
(ファイル名の最後の '.' とそれ以降の全て) は取り除かれる。これは
Vim version 3.0 との下位互換性のために残されており、":r" 形式を使う方がよい。
例: >

	%		カレントファイル名
	%<		拡張子なしのカレントファイル名
	#		カレントウィンドウでの代替ファイル名
	#<		同上、ただし拡張子なし
	#31		代替ファイル番号31
	#31<		同上、ただし拡張子なし
	<cword>		カーソル下の word
	<cWORD>		カーソル下の WORD (|WORD| を参照)
	<cfile>		カーソル下のパス名
	<cfile><	同上、ただし拡張子なし

Note: ファイル名が来る筈の所では、ワイルドカードの展開が行われる。Unixでは展開
にはシェルが使われる。ただしVim内部でできない展開だけである (スピードのため)。
バッククォート '`' も次のように使える。 >
	:n `echo *.c`
(バッククォートの展開は |restricted-mode| ではできない)
しかし展開は、'%' や '#' 等が展開される前にワイルドカードが存在したときにのみ
行われる。これはファイル名に含まれるワイルドカードを展開しないためである。
<cfile> の結果を展開したいときは、ワイルドカードの文字を追加すればよい。
例: (代替ファイル名は "?readme?" とする)
	コマンド	展開結果  ~
	:e #		:e ?readme?
	:e `ls #`	:e {"?readme?" にマッチしたファイル全て}
	:e #.*		:e {"?readme?.*" にマッチしたファイル全て}
	:cd <cfile>	:cd {カーソル下のファイル名}
	:cd <cfile>*	:cd {カーソル下のファイル名に "*" を加え展開したもの}

展開された後のコマンド引数に "!" に含まれていて、それがシェルコマンドに使われ
る (":!cmd", ":r !cmd" や ":w !cmd") とき、"!" は '\' でエスケープされ、前回の
コマンドに展開されるのを防ぐ。オプション 'shell' の値が "sh" を含むときは、エ
スケープは2回行われ、シェルが "!" を展開するのを防ぐ。

							*filename-backslash*
'\' をディレクトリの区切りに使うファイルシステム (MS-DOS、Windows、OS/2) では、
次のキャラクタの特別な意味をエスケープする目的の '\' を認識するのが少し困難で
ある。一般的な規則は次の通り。'\' が普通のファイル名の文字の後にある場合は、特
別な意味を持たない。したがって、"\file\foo" は有効なファイル名であり、'\' を2
度打つ必要はない。

例外は '$' 記号である。これはファイル名で有効な文字である。しかし "$home" のよ
うなファイル名が環境変数として解釈されるのを避けるため、'\' をこの前に付ける必
要がある。従ってルートディレクトリのファイル "$home" の指定には、"/\$home" を
使う必要がある。いくつかの例:

	ファイル名	その解釈	~
	$home		環境変数 $home の値に展開される
	\$home		カレントディレクトリのファイル "$home"
	/\$home		ルートディレクトリのファイル "$home"
	\\$home		"\\" の後に $home の値を付け加えた名前のファイル

==============================================================================
7. コマンドラインウィンドウ			*cmdline-window* *cmdwin*
							*command-line-window*

コマンドラインウィンドウでは、普通のウィンドウでテキストを編集するのと同じよう
にコマンドラインを編集できる。コマンドラインウィンドウは特殊なウィンドウで、普
通の方法でそこから出ることはできない。
{Vimが |+cmdline_hist| 機能と |+vertsplit| 機能付きでコンパイルされたときのみ
有効である。}


開 始						*c_CTRL-F* *q:* *q/* *q?*

コマンドラインウィンドウを開くには2通りの方法がある。
1. コマンドラインモードで、オプション 'cedit' で指定されたキーを使う。
   'compatible' がオフのときの既定値は CTRL-F である。
2. ノーマルモードで、コマンド "q:", "q/" または "q?" を使う。
   "q:" でExコマンドラインの編集を始め、"q/" または "q?" で文字列を検索する。
   Note: 打ち込んだキーの記録中にはこの方法は使えないことに注意 (そのときは
   "q" では記録が終了する)。

コマンドラインウィンドウが開かれたとき、中にはコマンドラインの履歴が並んでいる。
末尾の行には、その時点までに打ち込まれたコマンドが含まれる。左の列には、編集さ
れているコマンドラインの種類を表す1文字が表示される。|cmdwin-char| を参照。

コマンドラインウィンドウが開かれたとき、Vimはノーマルモードに移るが、オプショ
ン 'insertmode' がオンのときは挿入モードに移る。

コマンドラインウィンドウの高さはオプション 'cmdwinheight' で指定できる (ただし
余裕がないとこれより低くなる)。常に幅は最大になり、場所はコマンドラインの直上
である。


編 集

コマンドラインウィンドウ内では、コマンドを使ってあちこちへ移動したり、ウィンド
ウ内のテキストを編集できる。ノーマルモードと挿入モードが使える。

":" や "/" を始めとする、コマンドラインを使うコマンドも使えるが、そこから別の
コマンドラインウィンドウを開くことはできない。コマンドラインウィンドウはネスト
(入れ子状になること) できない。
							*E11*
コマンドラインウィンドウは普通のウィンドウではないので、別のウィンドウに移動し
たり、別のバッファを編集したりはできない。コマンドラインウィンドウでは、それら
を行うコマンドは無効化されている。もちろんコマンドラインウィンドウで入力したコ
マンドならどんなものでも 実 行 可 能 である。他のテキスト編集はコマンドライン
ウィンドウを閉じるときに破棄される。


終 了							*E199*

コマンドラインウィンドウを終了するには、以下の通りの方法がある。

<CR>		カーソル下のコマンドラインを実行する。挿入モードとNormalモー
		ドの両方で有効である。
CTRL-C		コマンドラインモードとして継続する。カーソル下のコマンドライン
		が引き継がれる。挿入モードとノーマルモードの両方で有効である。
		コマンド ":close" も使える。再描画は行われないので、ウィンドウ
		は可視状態のままになる。
:quit		コマンドラインを破棄してノーマルモードに戻る。コマンド ":exit",
		":xit" や CTRL-\ CTRL-N も有効である。
:qall		Vimを終了する (他のバッファに変更がない限り)。
:qall!		Vimを終了し、どのバッファの変更も破棄する。

コマンドラインウィンドウが閉じられると、他のウィンドウのサイズは復元される。実
行されたコマンドはコマンドラインウィンドウの開始元のウィンドウやバッファに適用
される。これはコマンドラインウィンドウがなかったかのように動作するが、画面の再
描画だけは余計に行われる。
コマンドラインウィンドウに使われたバッファは削除される。<CR> で実行された行以
外に対する変更は、全て失われる。

カーソル下のコマンドを実行した後、もう一度コマンドラインウィンドウを開きたけれ
ば、このマップを使うとよいかもしれない: >

	:autocmd CmdwinEnter * map <buffer> <F5> <CR>q:


そ の 他

コマンドラインウィンドウは、以下のときには使えない。
- 既にコマンドラインウィンドウを開いているとき (ネストすなわち入れ子は不可)
- 暗号化キーの入力時や関数 |inputsecret()| の使用時
- Vimが |+vertsplit| 機能付きでコンパイルされていないとき

コマンドラインウィンドウが開かれると、以下のオプションの設定が変わる。
'filetype'	"vim" (Exコマンドラインの編集時に) これは、可能ならVimスクリプ
		トに対する構文強調表示を開始する
'rightleft'	オフ
'modifiable'	オン
'buftype'	"nofile"
'swapfile'	オフ

コマンドラインウィンドウの内容をファイルに書き出すことができる。こうすれば、簡
単にコマンドライン履歴を保存し、後で読み込むことができる。

オプション 'wildchar' が <Tab> であり、コマンドラインウィンドウがExコマンドに
対して使われているときは、以下の2個のマッピングが追加され、コマンドラインウィ
ンドウ内でも <Tab> で補完ができるようになる。 >
	:imap <buffer> <Tab> <C-X><C-V>
	:nmap <buffer> <Tab> a<C-X><C-V>
Note: ノーマルモードで <Tab> を打ち込むと、カーソルの次の文字の位置で補完を行
うことに注意。この方法なら行末でも補完が行われる。
それらのマッピングを望まないなら、次のようにして無効化すること。 >
	au CmdwinEnter [:>] iunmap <Tab>
	au CmdwinEnter [:>] nunmap <Tab>
ユーザの .vimrc ファイルに上の行を書き込んでおけばよい。

コマンドラインウィンドウ内では、マウスでカーソルを別のウィンドウに移したり、別
のウィンドウのステータスラインをドラッグしたりはできない。コマンドラインウィン
ドウ自身のステータスラインはドラッグできる。上向きにずっとドラッグすると、直上
のウィンドウのステータスラインも動き、コマンドラインウィンドウがさらに広くなる。


自動コマンド の 適 用

2種類の 自動コマンドのイベントが使われる: |CmdwinEnter| と |CmdwinLeave|。コマ
ンドラインウィンドウは特別なウィンドウなので、イベント WinEnter, WinLeave,
BufEnter, BufLeave は発生しない。コマンドラインウィンドウに対して特別に設定を
するには、イベント Cmdwin を使う。副作用を引き起こさないよう注意！
例: >
	:au CmdwinEnter :  let b:cpt_save = &cpt | set cpt=.
	:au CmdwinLeave :  let &cpt = b:cpt_save
これはカレントウィンドウで |i_CTRL-N| によって補完を行うよう 'complete' を設定
する。
別の例: >
	:au CmdwinEnter [/?]  startinsert
こうすれば、コマンドラインウィンドウではVimは挿入モードに移る。

						*cmdwin-char*
パターンに使われる文字は、コマンドラインの種類を表す。
	:	普通のExコマンド
	>	デバッグモードのコマンド |debug-mode|
	/	前方検索に使われる文字列
	?	後方検索に使われる文字列
	=	Expressionレジスタ "= 用の expression |expr-register|
	@	関数 |input()| に対して入力する文字列
	-	コマンド |:insert| や |:append| に対して入力する文字列

 vim:tw=78:ts=8:ft=help:norl:
