*motion.txt*    For Vim バージョン 7.4.  Last change: 2013 Mar 07


		  VIMリファレンスマニュアル	  by Bram Moolenaar


カーソルの移動					*cursor-motions* *navigation*

これらのコマンドはカーソルの位置を変えます。移動先の位置がスクリーンの外側であ
ればカーソルを表示するためにスクリーンをスクロールさせます( 'scrolljump' と
'scrolloff' オプションも参照してください)。

1. 移動とオペレータ		|operator|
2. 左右の移動			|left-right-motions|
3. 上下の移動			|up-down-motions|
4. 単語単位の移動		|word-motions|
5. オブジェクト単位で移動	|object-motions|
6. オブジェクト単位で選択	|object-select|
7. マーク			|mark-motions|
8. ジャンプ			|jump-motions|
9. 様々な移動			|various-motions|

一般的な注意:

ファイルのどの場所にいるかを知るには "CTRL-G" コマンド |CTRL-G| か "g CTRL-G"
コマンド |g_CTRL-G| を使ってください。'ruler' オプションをセットしていればス
テータス行にカーソルの位置が表示し続けられます(ちょっとだけ Vim を遅くしま
す)。

経験を積んだユーザーは hjkl キーを使うのをそれらが常に指の下にあるという理由で
好みます。初心者はしばしば hjkl キーの動作を知らないので矢印キーを使うのを好み
ます。hjkl がどんな動きをするのか覚えるのはキーボードを見ればすぐわかります。j
を下矢印と見立ててみてください。

'virtualedit' オプションをセットすると、文字がない位置や文字の真ん中にもカーソ
ルを移動できるようになります。


==============================================================================
1. 移動とオペレータ					*operator*

移動コマンドはオペレータコマンドの後に続けることができ、カーソルが移動する間の
テキストにそのオペレータコマンドを施すことができます。つまりは移動前と移動後
のカーソル位置の間のテキストです。オペレータコマンドは一般的にテキストを削除し
たり変更したりするのに使われます。下記のオペレータコマンドを使うことができます:

	|c|	c	変更
	|d|	d	削除
	|y|	y	レジスタにヤンクする (テキストは変更しません)
	|~|	~	大文字/小文字を入れ換える ('tildeop' がセットされてい
			れば)
	|g~|	g~	大文字/小文字を入れ換える
	|gu|	gu	小文字にする
	|gU|	gU	大文字にする
	|!|	!	外部コマンドを使ってフィルターに通す
	|=|	=	'equalprg' を使ってフィルターに通すか、値が空であれば
			C のインデントを行う
	|gq|	gq	テキストを整形する
	|g?|	g?	ROT13 エンコーディング
	|>|	>	右にシフトする
	|<|	<	左にシフトする
	|zf|	zf	折り畳みを作成する
	|g@|	g@	オプション 'operatorfunc' に設定された関数を呼ぶ

移動コマンドにカウントが前置されていてかつオペレータコマンドにカウントが前置さ
れていれば2つのカウントが掛け合わされます。例: "2d3w" は6つの単語を削除します。

オペレータが終了すると、カーソルはだいたいオペレータを受けたテキストの始めに置
かれます。例えば、"yfe" はカーソルを動かしませんが、"yFe" はカーソルをヤンクの
スタートした "e" の左側に移動します。
						*linewise* *characterwise*
オペレータは行全体もしくは開始位置と終了位置の間の文字に対して施されます。一般
的に、行をまたいで移動するコマンドは行に対して施され(行単位)、行内を移動するコ
マンドは文字に対して施されます(文字単位)。しかしながらいくつかの例外はあります。

						*exclusive* *inclusive*
文字単位の移動は内包的(inclusive)か排他的(exclusive)のどちらかです。内包的な場
合は移動の最初と最後の位置がオペレータの対象に含まれますが、排他的な場合はバッ
ファの最後に向かって最後の文字は対象に含まれません。行単位の移動は常に最初と最
後の位置が含まれます。

どの移動コマンドが行単位であり、内包的であり、排他的であるかはコマンドのそばに
書かれています。しかしながら2つの例外があります:

1. 移動コマンドが排他的で移動後の位置が1桁目であれば、移動の最後は一行前の行の
   最後に動かされ、移動コマンドは内包的になります。例: "}" は段落の後の最初の
   行まで移動しますが "d}" はその行を含めません。
						*exclusive-linewise* 
2. 移動コマンドが排他的で、移動後の位置が1桁目でかつ移動初めの位置がその行の最
   初の非空白文字かその手前の位置であれば、移動コマンドは行単位になります。
   例: 段落が空白文字で始まっていて、カーソルが最初の非空白文字に位置している
   とすれば "d}" は段落中のすべての行を最初の空白も含めて削除します。それから
   put コマンドを行えば削除された行はカーソルの位置の下から挿入されます。

オペレータが待機しているとき(オペレータコマンドがタイプされていて移動コマンド
はまだタイプされていない状態)でのみ動作するマップを作成することができます。
参照: |:omap|

初めにオペレータコマンドを指定してそれから移動コマンドを打つ、という風にする代
わりにビジュアルモードを使うこともできます: テキストの最初を "v" でマークして
からカーソルをテキストの終わりまで移動させます。そうするとその範囲に対してオペ
レータコマンドを打つことで処理を施すことができます。テキストの初めとカーソル位
置の間はハイライトされていますので、どの部分のテキストにオペレータが施されるの
かを目で確認することができます。こうすることで自由度が上がりますが、打ち込む
キーストロークは増え、そしてリドゥ機能が制限されます。ビジュアルモードの章もご
覧下さい。
|Visual-mode|

移動に ":" コマンドを使うことが出来ます。例えば "d:call FindEnd()"。しかし、コ
マンドが１行以上になると "." で繰り返すことが出来ません。
これは繰り返せます: >
	d:call search("f")<CR>
これは繰り返せません: >
	d:if 1<CR>
	   call search("f")<CR>
	endif<CR>
Note ":" を使った全ての移動は、排他的な文字単位になることに注意してください。


移動を行単位、文字単位、ブロック単位にする

移動があなたの望むタイプと違う場合は、オペレータコマンドの後に "v", "V",
CTRL-V を使うことで別のタイプにすることができます。
例: >
	dj
は2行を削除します。 >
	dvj
はカーソル位置からカーソルの1個下の文字の手前までを削除します。 >
	d<C-V>j
はカーソル位置とカーソルの1個下の文字を削除します。 >

行単位の移動に文字単位・ブロック単位の移動をさせるときは注意してください。桁が
必ずしも定義されていないかもしれません。

							*o_v*
v		オペレータコマンドと移動コマンドの間で使われたとき: 移動コマン
		ドが行単位であっても、オペレータコマンドが文字単位で機能するよ
		うにします。移動コマンドが行単位のときは排他的 |exclusive| に
		なります。移動コマンドが既に文字単位の場合には、内包的／排他的
		を切り替えます。これによって排他的な移動を内包的にしたり、その
		逆にしたりできます。

							*o_V*
V		オペレータコマンドと移動コマンドの間で使われたとき: 移動コマン
		ドが文字単位であっても、オペレータコマンドが行単位で機能するよ
		うにします。

							*o_CTRL-V*
CTRL-V		オペレータコマンドと移動コマンドの間で使われたとき: オペレータ
		コマンドがブロック単位で機能するようにします。これは移動の前後
		のカーソル位置を端点とする矩形範囲を選択したのと同じように動作
		します。

==============================================================================
2. 左右の移動						*left-right-motions*

この節で説明するコマンドはどれも、カーソルをカレント行の指定の位置に移動させま
す。これらのコマンドは行の先頭と末尾でストップします。例外は "$" で、カウント
を指定した場合は下の行へ移動します。'whichwrap' をオンにすると、これらのコマン
ドが行をまたいで移動するようになります。

h		or					*h*
<Left>		or					*<Left>*
CTRL-H		or					*CTRL-H* *<BS>*
<BS>			[count] 文字左に移動します|exclusive|
			Note: <BS> キーには文字を削除させたければ次のマッピン
			グを使ってください:
				:map CTRL-V<BS>		X
			("CTRL-V<BS>" を入力するには CTRL-V キーをタイプした後
			<BS> キーをタイプしてください)
			<BS> キーがうまく動作しない場合は |:fixdel| を参照して
			ください。

l		or					*l*
<Right>		or					*<Right>* *<Space>*
<Space>			[count] 文字右に移動します|exclusive|

							*0*
0			その行の最初の文字に移動します|exclusive|。

							*<Home>* *<kHome>*
<Home>			その行の最初の文字に移動します|exclusive|。
			上下に移動するときは同じ論理桁位置に留まります。(可能
			であれば)。他のほとんどのコマンドは同じ物理桁位置に留
			まります。<Home>は "1|" と同じように動作し、"0" との違
			いは行が <Tab> で始まる場合です。{Vi にはありません}

							*^*
^			その行の最初の非空白文字に移動します|exclusive|。

							*$* *<End>* *<kEnd>*
$  or <End>		その行の最後に移動します。カウントが指定された場合は、
			[count - 1] 行下にも移動します|exclusive|。
			ビジュアルモードではカーソルは行の最後の文字の後へ移動
			します。
			'virtualedit' がオンのときには、"$" によってカーソルが
			行末の先から行の最後の文字へバックするかもしれません。

							*g_*
g_			[count - 1]行下の最後の非空白文字へ移動|inclusive|。
			{Vi にはありません}

							*g0* *g<Home>*
g0 or g<Home>		行が折り返されている場合( 'wrap' オン): スクリーン行の
			初めの文字に移動|exclusive|。スクリーンより広い行の
			場合に "0" と違う動作になります。
			行が折り返されていない場合は( 'wrap' オフ): スクリーン
			上の現在の行でもっとも左の文字に移動します。最初の文字
			がスクリーン上にない場合に "0" とは違う動作になります。
			{Vi にはありません}

							*g^*
g^			行が折り返されている場合( 'wrap' オン): スクリーン行の
			最初の非空白文字に移動します|exclusive|。スクリーンよ
			り広い行の場合に "^" とは違う動作になります。行が折り
			返されていない場合は( 'wrap' オフ): スクリーン上の現在
			の行でもっとも左側にある非空白文字に移動します。最初の
			非空白文字がスクリーン上にない場合に "^" とは違う動作
			になります。 {Vi にはありません}

							*gm*
gm			"g0" と似ていますがスクリーンの幅の真ん中に移動します
			(もしくは可能な限り真ん中に向かって右に)。
			{Vi にはありません}

							*g$* *g<End>*
g$ or g<End>		行が折り返されている場合( 'wrap' オン): スクリーン行の
			最後の文字に、そして [count - 1] スクリーン行下に移動
			します|inclusive|。行がスクリーンより広い場合に "$" 
			と違う動作になります。
			行が折り返されていない場合( 'wrap' オフ): スクリーン上
			に表示されている現在の行の文字のうち最も右に位置するも
			のに移動します。行の最後の文字がスクリーン上にないかカ
			ウントが使われた場合に "$" とは違う動作になります。
			さらに、縦方向への移動は、行末でなく同じ桁になります。
			'virtualedit' が有効である場合、スクリーン行の末尾に移
			動します。
			{Vi にはありません}

							*bar*
|			現在の行の [count] スクリーン桁位置に移動します
			|exclusive|。Ceci n'est pas une pipe.
			{訳注: 「これはパイプではない」。同名のマグリットの絵
			がある}

							*f*
f{char}			右に向かって [count] 番目に現れる {char} に移動し、
			カーソルがその {char} 上に置かれます|inclusive|。
			{char} はダイグラフ |digraph-arg| でも構いません。
			'encoding' が Unicode にセットされているときは、
			composing character が使えます。|utf-8-char-arg| を参
			照。
			|:lmap| マッピングが {char} に適用されます。挿入モード
			時の CTRL-^ コマンドでこれの on/off を切り替えられま
			す|i_CTRL-^|。

							*F*
F{char}			左に向かって [count] 番目に現れる {char} に移動し、
			カーソルがその {char} 上に置かれます|exclusive|。
			{char} は |f| コマンドと同様に入力できます。

							*t*
t{char}			右に向かって [count] 番目に現れる {char} まで移動しま
			す。カーソルは {char} の左側の文字に置かれます
			|inclusive|。
			{char} は |f| コマンドと同様に入力できます。

							*T*
T{char}			左に向かって [count] 番目に現れる {char} まで移動しま
			す。カーソルは {char} の右側の文字に置かれます
			|exclusive|。
			{char} は |f| コマンドと同様に入力できます。

							*;*
;			[count] 回最後の f, t, F, T を繰り返します。
			|cpo-;| 参照。

							*,*
,			[count] 回最後の f, t, F, T を反対方向に繰り返します。
			|cpo-;| 参照。

==============================================================================
3. 上下の移動						*up-down-motions*

k		or					*k*
<Up>		or					*<Up>* *CTRL-P*
CTRL-P			[count] 行上に移動(行単位|linewise|)

j		or					*j*
<Down>		or					*<Down>*
CTRL-J		or					*CTRL-J*
<NL>		or					*<NL>* *CTRL-N*
CTRL-N			[count] 行下に移動(行単位|linewise|)

gk		or					*gk* *g<Up>*
g<Up>			[count] 表示行上に移動|exclusive|。行が折り返されている
			場合とオペレータコマンドとともに使われた場合は 'k' と
			違う動作になります(行単位ですから)。{Vi にはありません}

gj		or					*gj* *g<Down>*
g<Down>			[count] 表示行下に移動|exclusive|。行が折り返されている
			場合とオペレータコマンドとともに使われた場合は 'j' と
			違う動作になります(行単位ですから)。{Vi にはありません}

							*-*
-  <minus>		[count] 行上の最初の非空白文字に移動します(行単位
			|linewise|)

+		or					*+*
CTRL-M		or					*CTRL-M* *<CR>*
<CR>			[count] 行下の最初の非空白文字に移動します(行単位
			|linewise|)

							*_*
_  <underscore>		[count] -1 行下の最初の非空白文字に移動します(行単位
			|linewise|)

							*G*
G			[count] 行目の最初の非空白文字に移動します(行単位
			|linewise|)。
			カウントの前置がなければ最後の行に移動します。
			'startofline' がセットされていなければ同じ桁位置に移動
			します。
			G はジャンプモーション (|jump-motions|) です。

							*<C-End>*
<C-End>			[count] 行目へ移動|inclusive|。カウントの前置がなければ
			最後の行の最後の文字へ移動します。
			{Vi にはありません}

<C-Home>	or					*gg* *<C-Home>*
gg			[count] 行目の最初の非空白文字に移動します(行単位
			|linewise|)。
			カウントの前置がなければ最初の行に移動します。
			'startofline' がセットされていなければ同じ桁位置に移動
			します。

							*:[range]*
:[range]		[range] 内の最後の行へカーソルを移動します。[range]
			は単に 1 個の数字であってもかまいません。例: ":1" や
			":'m"。
			|G| と違ってこのコマンドはジャンプリスト (|jumplist|)
			を変更しません。
							*N%*
{count}%		ファイルの {count} パーセントの位置の最初の非空白文字
			に移動します(行単位|linewise|)。新しい行番号を計算する
			のに次の式が使われます:
			     ({count} * number-of-lines + 99) / 100
			'startofline' オプションも参照してください。
			{Vi にはありません}

:[range]go[to] [count]					*:go* *:goto* *go*
[count]go		バッファ中の [count] バイト目に移動します。デフォルト
			では [count] は1で、ファイルの最初になっています。
			[range] が指定された場合は最後の数字が使われます。行の
			終わりを示す文字が数えられるかどうかは 'fileformat' の
			設定によります。
			|line2byte()| 関数と 'statusline' の 'o' オプションも
			参照。
			{Vi にはありません}
			{|+byte_offset|機能なしでコンパイルされた場合は使えませ
			ん}

これらのコマンドは指定された行に移動します。最初の行もしくは最後の行に到達した
場合はそれ以上動きません。最初の2つのコマンドはカーソルを桁位置を変更する最後
のコマンドの後の位置と(可能であれば)同じ桁位置に動かします。"$" コマンドは例外
でカーソルは行の最後の位置に置かれます。

[count]をつけて "k", "-", CTRL-Pを実行したが、カーソルより上に[count]分の行が
なかった場合、オプション 'cpo' がフラグ "-" を含むならばエラーになります。
|cpo--|

==============================================================================
4. 単語単位の移動					*word-motions*

<S-Right>	or					*<S-Right>* *w*
w			[count] word 前方に。|exclusive|

<C-Right>	or					*<C-Right>* *W*
W			[count] WORD 前方に。|exclusive|

							*e*
e			[count] word 前方の単語の終わりに。|inclusive|
			w や b と異なり、空行では止まりません。

							*E*
E			[count] WORD 前方の単語の終わりに。|inclusive|
			w や b と異なり、空行では止まりません。

<S-Left>	or					*<S-Left>* *b*
b			[count] word 後方に。|exclusive|

<C-Left>	or					*<C-Left>* *B*
B			[count] WORD 後方に。|exclusive|

							*ge*
ge			[count] word 後方の単語の最後に。|inclusive|

							*gE*
gE			[count] WORD 後方の単語の最後に。|inclusive|

これらのコマンドは word もしくは WORD 単位で移動します。
							*word*
word はアルファベット、数字、アンダースコア、もしくは他の非空白文字の連続で構
成され、ホワイトスペース(スペース、タブ、<EOL>)で区切られます。これらは
'iskeyword' オプションで変更することができます。空行もwordとみなされます。
							*WORD*
WORD は非空白文字の連続で構成され、ホワイトスペースで区切られます。空行もまた
1つの word と WORD と見なされます。

折り畳まれた一連の行は1文字からなる1単語と数えられます。"w" と "W", "e" と "E"
は折り畳まれた行の範囲の後の最初の word や WORD の初め／終わりに移動します。
"b" と "B" は折り畳みの前の最初の word や WORD の初めに移動します。

特殊なケース: カーソルが非空白文字の上にあれば "cw" と "cW" は "ce" と "cE" の
ように扱われます。これは "cw" が単語を変更するコマンドだと解釈されるからで、単
語には続くホワイトスペースは含まれていないからです。{Vi: 後に空白文字が続く空
白文字上で "cw" を実行した場合最初の空白文字のみが変更されました; これはおそら
くバグです。なぜなら "dw" はすべての空白文字を削除するからです}

もう一つの特殊なケース: オペレータコマンドと移動コマンド "w" を組み合わせたと
きカーソルがその上を移動した最後の単語が行末にあった場合、その単語の終わりがオ
ペレータの対象になるテキストの終わりになります。次の行の最初の単語ではありませ
ん。

オリジナルの Vi の "e" の実装はかなりバギーでした。例えば、前の行が空行であっ
た場合 "e" コマンドを打っても行の最初の文字に止まったままになりました。しかし
"2e" と打つとこのことは起こりません。Vim では "ee" と "2e" は同じで、こちらの
方が理にかなっています。しかしながら、このことは Vi と Vim との間に少し非互換
性を生じさせていることになります。

==============================================================================
5. オブジェクト単位で移動				*object-motions*

							*(*
(			[count] 文後方に。|exclusive|

							*)*
)			[count] 文前方に。|exclusive|

							*{*
{			[count] 段落後方に。|exclusive|

							*}*
}			[count] 段落前方に。|exclusive|

							*]]*
]]			[count] セクション前方に、もしくは1桁目が '{' で始まる
			次の場所に。オペレータコマンドの後で使われた場合は1桁
			目の '}' の下でも止まります。|exclusive|
                        Note しばしば|exclusive-linewise|になる。

							*][*
][			[count] セクション前方に、もしくは1桁目が '}' で始まる
			次の場所に。|exclusive|
                        Note しばしば|exclusive-linewise|になる。

							*[[*
[[			[count] セクション後方に、もしくは1桁目が '{' で始まる
			前の場所に。|exclusive|
                        Note しばしば|exclusive-linewise|になる。

							*[]*
[]			[count] セクション後方に、もしくは1桁目が '}' で始まる
			前の場所に。|exclusive|
                        Note しばしば|exclusive-linewise|になる。

これらのコマンドは3種類のテキストのまとまりの単位で移動します。

							*sentence*
文は '.', '!', '?' で終わり、その後に行末かスペースもしくはタブが続くものとし
て定義されます。任意の数の閉じ ')', ']', '"', ''' 文字が '.', '!', '?' の後
に、そして改行もしくはスペースかタブの前に現れてもよいです。段落とセクションの
境界は文の境界でもあります。
もし 'J' フラグが 'cpoptions' にある場合は句読点の後に少なくとも二つのスペース
がある必要があります; <Tab> はホワイトスペースとして認識されません。
文の定義を変更することはできません。

							*paragraph*
段落はそれぞれ空行の後から始まり、そしてまた段落マクロのセットからそれぞれ始ま
ります。段落マクロは 'paragraphs' オプションで指定されている文字のペアです。デ
フォルトで "IPLPPPQPP TPHPLIPpLpItpplpipbp" で、".IP", ".LP", などのマクロに一
致します(これらは nroff のマクロです。ですのでドットは1桁目になければなりませ
ん)。セクションの境界は段落の境界でもあります。空行(ホワイトスペースのみを含む
行)は、段落の境界ではないということに注意してください。
これは '{' か '}' を1桁目には含んでいないということにも注意してください。
'cpoptions' にフラグ "{" が入っていると1桁目の "{" が段落の境界とみなされるよ
うになります。|posix|

							*section*
セクションは1桁目の改ページ(form-feed)(<C-L>)の後から始まり、そしてセクション
マクロのセットからそれぞれ始まります。セクションマクロは 'sections' オプション
で定義される文字のペアです。デフォルトは "SHNHH HUnhsh" で ".SH", ".NH", ".H",
".HU", ".nh", ".sh" といった nroff マクロでセクションを開始するものを定義して
います。

"]" と "[" コマンドは1桁目の '{' もしくは '}' でストップします。これは C のプ
ログラムで関数の最初か最後を見つけるのに便利です。2番目にタイプされたタイプの
括弧が探されるということに留意しておいてください。

もし '{' か '}' が1桁目にはないけれど、とにかく "[[" と "]]" を使って検索した
い場合は次のマッピングを使ってみてください: >
   :map [[ ?{<CR>w99[{
   :map ][ /}<CR>b99]}
   :map ]] j0[[%/{<CR>
   :map [] k$][%?}<CR>
[これらはそのままタイプしてください。参照 |<>|]

==============================================================================
6. オブジェクト単位で選択			*object-select* *text-objects*
						*v_a* *v_i*

次のものはビジュアルモードかオペレータコマンドの後でのみ使うことができる一連の
コマンドを示しています。"a" で始まるコマンドは "a" (1つの) まとまりをホワイト
スペースを含めて選択します。"i" で始まるコマンドはまとまりの "inner" (内部) を
ホワイトスペースを含まずに選択するか、もしくはホワイトスペースのみを選択しま
す。ですので、"inner" コマンドは常に "a" コマンドより少なくテキストを選択する
ことになります。

これらのコマンドは {Vi にはありません}
これらのコマンドはコンパイル時に |+textobjects| 機能を無効にしていた場合には
使えません。
最後に使われた検索パターンによる操作をするには `gn` と `gN` を参照。

							*v_aw* *aw*
aw			"a word"、[count] word 選択します(参照 |word|)。
			単語の前後に続いているホワイトスペースもともに含められ
			ますがカウントはされません。
			行単位ビジュアルモードで使われたときは、"aw" は文字単
			位ビジュアルモードに切り替えます。

							*v_iw* *iw*
iw			"inner word"、[count] word 選択します(参照 |word|)。
			word の間のホワイトスペースもカウントされます。
			行単位ビジュアルモードで使われたときは、"iw" は文字単
			位ビジュアルモードに切り替えます。

							*v_aW* *aW*
aW			"a WORD"、[count] WORD 選択します(参照 |WORD|)。
			単語の前後に続いているホワイトスペースも含められます
			がカウントはされません。
			行単位ビジュアルモードで使われたときは、"aW" は文字単
			位ビジュアルモードに切り替えます。

							*v_iW* *iW*
iW			"inner WORD"、[count] WORD 選択します(参照 |WORD|)。
			ホワイトスペースもカウントされます。
			行単位ビジュアルモードで使われたときは、"iW" は文字単
			位ビジュアルモードに切り替えます。

							*v_as* *as*
as			"a sentence"、[count] 文選択します(参照 |sentence|)。
			ビジュアルモードで使われたときは、文字単位になります。

							*v_is* *is*
is			"inner sentence"、[count] 文の内部を選択します(参照
			|sentence|)。
			ビジュアルモードで使われたときは、文字単位になります。

							*v_ap* *ap*
ap			"a paragraph"、[count] 段落選択します(参照
			|paragraph|)。
			例外: 空行 (空白だけからなる) も段落の境界になります。
			ビジュアルモードで使われたときは、行単位になります。

							*v_ip* *ip*
ip			"inner paragraph"、[count] 段落の内部を選択します(参照
			|paragraph|)。
			例外: 空行 (空白だけからなる) も段落の境界になります。
			ビジュアルモードで使われたときは、行単位になります。

a]						*v_a]* *v_a[* *a]* *a[*
a[			"a [] block"、[count] '[' ']' block を選択します。この
			コマンドは後方に [count] 番目に現れる '[' を探し、それ
			から対応する ']' を探します。そしてその2つに囲まれたテ
			キストを '[' と ']' も含めて選択します。
			ビジュアルモードで使われたときは、文字単位になります。

i]						*v_i]* *v_i[* *i]* *i[*
i[			"inner [] block"、[count] '[' ']' block の内部を選択
			します。このコマンドは後方に [count] 番目に現れる '['
			を探し、それから対応する ']' を探します。そしてその2つ
			に囲まれたテキストを '[' と ']' を除いて選択します。
			ビジュアルモードで使われたときは、文字単位になります。

a)							*v_a)* *a)* *a(*
a(							*v_ab* *v_a(* *ab*
ab			"a block"、[count] block 選択します。"[count] [(" から
			それに対応する ')' までで、'(' と ')' を含みます(参照
			|[(|)。括弧の外側の空白は含みません。
			ビジュアルモードで使われたときは、文字単位になります。

i)							*v_i)* *i)* *i(*
i(							*v_ib* *v_i(* *ib*
ib			"inner block"、[count] block の内部を選択します。
			"[count] [(" からそれに対応する ')' までで、'(' と ')'
			を除きます(参照 |[(|)。
			ビジュアルモードで使われたときは、文字単位になります。

a>						*v_a>* *v_a<* *a>* *a<*
a<			"a <> block"、[count] <> block 選択します。[count] 番
			目に現れる '<' を検索し、それに対応する '>' までを '<'
			と '>' を含めて選択します。
			ビジュアルモードで使われたときは、文字単位になります。

i>						*v_i>* *v_i<* *i>* *i<*
i<			"inner <> block"、[count] <> block の内部を選択します。
			[count] 番目に現れる '<' を検索し、それに対応する '>'
			までを '<' と '>' を除いて選択します。
			ビジュアルモードで使われたときは、文字単位になります。

						*v_at* *at*
at			"a tag block"、[count]個のタグブロックを選択します。
			後方の[count]番目の対応しない "<aaa>" からそれに対応す
			る "</aaa>" までを含みます。詳しくは|tag-blocks|を参照
			してください。ビジュアルモードで使われたときは文字単位
			になります。

						*v_it* *it*
it			"inner tag block"、[count]個のタグブロックを選択します。
			後方の[count]番目の対応しない "<aaa>" からそれに対応す
			る "</aaa>" までで、"<aaa>" と "</aaa>" を除きます。詳
			しくは|tag-blocks|を参照してください。ビジュアルモード
			で使われたときは文字単位になります。

a}							*v_a}* *a}* *a{*
a{							*v_aB* *v_a{* *aB*
aB			"a Block"、[count] Block 選択します。"[count] [{" から
			それに対応する '}' までで '{' と '}' を含みます(参照
			|[{|)。
			ビジュアルモードで使われたときは、文字単位になります。

i}							*v_i}* *i}* *i{*
i{							*v_iB* *v_i{* *iB*
iB			"inner Block"、[count] Block 選択します。"[count] [{"
			からそれに対応する '}' までで '{' と '}' を除きます(参
			照|[{|)。
			ビジュアルモードで使われたときは、文字単位になります。

a"							*v_aquote* *aquote*
a'							*v_a'* *a'*
a`							*v_a`* *a`*
			"a quoted string"。前の引用符から次の引用符までを選択
			します。オプション 'quoteescape' を使ってエスケープさ
			れた引用符をスキップします。
			1行内でだけ動作します。
			カーソルを引用符の上において実行されると、行の先頭から
			検索し、どの引用符のペアが文字列をなすかを調べます。
			後に空白文字があると、それも含まれます。ない場合、前に
			空白文字があれば含まれます。
			ビジュアルモードで使われたときは文字単位になります。
			ビジュアルモードでこのオブジェクトが繰り返し使われると、
			別の文字列を含むように選択範囲を拡大します。現在のとこ
			ろ、カウントは使われません。

i"							*v_iquote* *iquote*
i'							*v_i'* *i'*
i`							*v_i`* *i`*
			a", a', a` と同様ですが、引用符を含まず、繰り返し使わ
			れたとき選択範囲を拡大しません。
			特別な場合: カウントに2が指定された場合引用符が含まれ
			ます。ただし a"/a'/a` とは違い、前後の空白文字は含まれ
			ません。

オペレータコマンドの後に使われた場合:
ブロック以外のオブジェクト:
	"a" コマンド: オペレータコマンドはオブジェクトとオブジェクトの後に続く
	ホワイトスペースに対して施されます。オブジェクトの後にホワイトスペース
	がないか、もしくはオブジェクトの前のホワイトスペースにカーソルが位置し
	ている場合オブジェクトの前のホワイトスペースも含まれます。
	"inner" コマンド: カーソルがオブジェクト上にあればオペレータコマンドは
	オブジェクトに対して施されます。カーソルがホワイトスペース上にあればホ
	ワイトスペースに対して施されます。
ブロックオブジェクト:
	オペレータコマンドはカーソルがその内側に位置しているブロック、もしくは
	囲んでいる括弧上にカーソルがあるブロックに対して施されます。"inner" コ
	マンドは囲んでいる括弧以外に対して施され、"a" コマンドの場合は括弧も含
	められます。

ビジュアルモードで使われた場合:
ビジュアル範囲の初めと終わりが同一の場合(単に "v" と打っただけの場合):
	オペレータコマンドを使う場合と同様1つのオブジェクトが選択されます。
ビジュアル範囲の初めと終わりが同一でない場合:
	ブロック以外のオブジェクトの場合はビジュアル範囲を1オブジェクト分広げ
	るか、もしくは次のオブジェクトまでのホワイトスペースまで広げます。"a"
	オブジェクトの場合はそれら両方を含みます。広げる方向はカーソルがビジュ
	アル範囲のどちら側にあるかによります。つまりブロックオブジェクトの場合
	はブロックは1レベル外側に広げられます。

実例として削除コマンドのリストを挙げます。小さいオブジェクトから大きいオブジェ
クトの順で並べられています。1文字と行全体の削除については今までにも存在してい
た vi 移動コマンドが使われているということに注意してください。
	"dl"	1文字削除 ("x" と同じです)		|dl|
	"diw"	inner word を削除			*diw*
	"daw"	a word を削除				*daw*
	"diW"	inner WORD を削除 (参照: |WORD|)	*diW*
	"daW"	a WORD を削除 (参照: |WORD|)		*daW*
	"dgn"   次に検索パターンにマッチするものを削除  *dgn*
	"dd"	1行削除					|dd|
	"dis"	inner sentence を削除			*dis*
	"das"	a sentence を削除			*das*
	"dib"	inner '(' ')' block を削除		*dib*
	"dab"	a '(' ')' block を削除			*dab*
	"dip"	inner paragraph を削除			*dip*
	"dap"	a paragraph を削除			*dap*
	"diB"	inner '{' '}' Block を削除		*diB*
	"daB"	a '{' '}' Block を削除			*daB*

移動コマンドを使う場合とオブジェクトを使う場合の違いに留意しておいてください。
移動コマンドの場合はカーソルの位置から移動後の位置までに処理を施します。
オブジェクトを使った場合はカーソルがオブジェクトの中のどこに位置していてもオペ
レータはオブジェクト全体に施されます。例として "dw" と "daw" を比べてみましょ
う: "dw" はカーソルの位置から次の word の初めまでを削除し、"daw" はカーソルの
位置の単語と前後のスペースを削除します。

タグブロック						*tag-blocks*

テキストオブジェクト "it" と "at" ではHTMLやXMLの対応するタグの間のブロックを
選択しようとします。しかしこれらは完全な互換ではないため、いくつかの制限があり
ます。

通常の方法は<tag>から対応する</tag>までを選択します。"at" はそのタグ自身を含
み、"it" はタグ自身を除きます。しかし "it" が繰り返し使われるとタグ自身が含ま
れます(そうでないと何も変わらない)。また、中身が何もないタグブロックの上で
"it" を使うと開始タグが選択されます。

"<aaa/>" はスキップされます。本来XMLでは大文字・小文字の違いは区別されますが、
Vimはその違いを無視します。

HTMLでは<br>や<meta ...>のように対応する終了タグを持たないタグもありえます。こ
れらは無視されます。

このテキストオブジェクトはミスも許容します。対応する開始タグがない終了タグは無
視されます。

==============================================================================
7. マーク					*mark-motions* *E20* *E78*

マークへジャンプするには２つの方法があります:
1. ` (バッククォート)で  : カーソルは指定された位置に置かれます。|exclusive|
2. ' (シングルクォート)で: カーソルは指定された位置の行の最初の非空白文字に置
			   かれ移動は行単位です。

						*m* *mark* *Mark*
m{a-zA-Z}		カーソル位置を{a-zA-Z}にマークします(これは移動コマン
			ドではありません。ですのでカーソルは動きません)。

						*m'* *m`*
m'  or	m`		直前位置マークをセットします。"''" もしくは "``" コマ
			ンドでこの位置に移動できます。(移動コマンドではありま
			せん。ですのでカーソルは動きません)。

						*m[* *m]*
m[  or  m]		マーク |'[| or |']| をセットします。オペレータコマンド
			が複数のコマンドでシミュレートされるときに便利です。
			(移動コマンドではありません。ですのでカーソルは動きま
			せん)。

						*m<* *m>*
m<  or  m>		マーク |'<| or |'>| をセットします。`gv` コマンドで選
			択される範囲を変更するのに便利です。 (移動コマンドあり
			ません。ですのでカーソルは動きません)。
			Note ビジュアルモードは設定できません。開始と終了の位
			置のみ設定できます。

						*:ma* *:mark* *E191*
:[range]ma[rk] {a-zA-Z'}
                        [range]の範囲の最後の行番号の0桁目を{a-zA-Z}にマーク
			します。デフォルトはカーソル行です。

						*:k*
:[range]k{a-zA-Z'}	:mark コマンドと同じですが、マーク名の前のスペースは挿
			入しなくてもよいです。

						*'* *'a* *`* *`a*
'{a-z}  `{a-z}		カレントバッファのマーク {a-z} へジャンプ。

						*'A* *'0* *`A* *`0*
'{A-Z0-9}  `{A-Z0-9}	マーク {A-Z0-9} を含むファイル・位置へジャンプ。
			(別のファイルにある場合は移動コマンドにはなりません)。
			{Vi にはありません}

						*g'* *g'a* *g`* *g`a*
g'{mark}  g`{mark}
			{mark} へジャンプするが、カレントバッファ内で移動する
			場合にはジャンプリストを変更しない。例: >
				g`"
<			これはファイル内の最後の記憶している位置にジャンプする。
			$VIMRUNTIME/vimrc_example.vim を参照。
			|:keepjumps|も参照。
			{Vi にはありません}

						*:marks*
:marks			現在のマークを全てリストします(移動コマンドではありま
			せん)。
			|'(|, |')|, |'{| と |'}| マークはリストされません。
			1桁目は桁番号0となります。
			{Vi にはありません}

						*E283*
:marks {arg}		{arg} で指定されるマークをリストします(移動コマンドで
			はありません)。例: >
				:marks aB
<			マーク 'a' と 'B' をリストします。{Vi にはありません}

							*:delm* *:delmarks*
:delm[arks] {marks}	指定されたマークを削除します。削除できるマークはA-Zと
			0-9などです。マーク'は削除できません。それらはダッシュ
			で区切られたマーク名のリストを与えることで指定できます。
			スペースは無視されます。例: >
			   :delmarks a	      マークaを削除する
			   :delmarks a b 1    マークa, b, 1を削除する
			   :delmarks Aa       マークA, aを削除する
			   :delmarks p-z      pからzまでのマークを削除する
			   :delmarks ^.[]     マーク^ . [ ]を削除する
			   :delmarks \"	      マーク"を削除する
<			{Vi にはありません}

:delm[arks]!		A-Z, 0-9を除くカレントバッファのすべてのマークを削除し
			ます。
			{Vi にはありません}

マークはどのようにしても見えません。マークは単に覚えておかれるファイル中の位置
に過ぎません。マークと名前付きレジスタを混同しないようにしてください、まったく
別のものです。

'a - 'z		小文字のマークです。1つのファイル中で有効です。
'A - 'Z		大文字のマークで、ファイルマークとも呼ばれます。ファイル間でも
		有効です。
'0 - '9		番号マークです。.viminfo ファイルによってセットされます。

小文字のマーク 'a から 'z まではマークのあるファイルがバッファリストに存在す
る限り覚えておかれます。もしファイルをバッファリストから削除するとそのファイ
ルに関するマーク一は全て失われます。またマークを含んでいる行を削除するとその
マークは消されます。

小文字のマークはオペレータコマンドとともに使うことができます。例:
"d't" は現在のカーソル位置からマーク 't' までの行を削除します。アイディア:
マーク 't' をTop 位置に設定したり、'b' を Bottom 位置に設定したりします。小文
字のマークはアンドゥとリドゥによって復元することができます。

大文字のマーク 'A' から 'Z' はファイル名を含んでいます。{Vi: 大文字のマークは
ありません} ファイルからファイルに移動するのに使うことができます。大文字のマー
クをオペレータコマンドとともに使うにはマークは現在のファイルになければなりませ
ん。また大文字のマークの場合は行を挿入/削除したり一時的に他のファイルを編集し
たりしてもマークのある行番号は覚えておかれます。'viminfo' オプションの値が空で
なければ大文字のマークは .viminfo ファイルに保持されます。参照:
|viminfo-file-marks|

番号マーク '0 から '9 まではこれらとはまったく異なります。直接セットすることは
できず、viminfo ファイル |viminfo-file| を使っている場合にのみ存在します。基本
的に '0 は最後に Vim を終了したときのカーソル位置であり、'1 は最後から1個前の
位置、などなどです。特定のファイルを番号マークに保存しないようにするには
'viminfo' の "r" フラグを使ってください。参照: |viminfo-file-marks|


							*'[* *`[*
'[  `[			直前に変更またはヤンクされたテキストの最初の文字
			へ移動します。
			{Vi にはありません}

							*']* *`]*
']  `]			直前に変更またはヤンクされたテキストの最後の文字
			へ移動します。
			{Vi にはありません}

なんらかのオペレータコマンドを実行した後は、カーソルはオペレータを施したテキス
トの初めに置かれます。プットコマンド("p" もしくは "P")の後は、カーソルは挿入さ
れた最初の行に位置する場合と最後に挿入された文字に位置する場合があります。上の
4つのコマンドはカーソルをどちらかの端に位置させます。例: 10行ヤンクした後、そ
の行の内の最後の行に移動したい場合は: "10Y']"。数行を "p" コマンドで挿入した
後、1番下に挿入された行に移動したい場合は: "p']"。これはすでに挿入済みのテキス
トに関しても動作させることができます。

Note: 矩形ビジュアルモードを使っているのでない限り、テキストの削除の後は始めと
終わりの位置は同じです。これらのコマンドは、現在のファイルに対してまだ変更がさ
れていない場合は動作しません。

							*'<* *`<*
'<  `<			現在のバッファで最後に選択されたビジュアルエリアの最初
			の行('<)または最初の文字(`<)に移動します。ブロックモー
			ドでは最初の行の最後の文字になる場合もあります(選択の
			開始位置による)。{Vi にはありません}

							*'>* *`>*
'>  `>			現在のバッファで最後に選択されたビジュアルエリアの最後
			の行('<)または最後の文字(`<)に移動します。ブロックモー
			ドでは最後の行の最初の文字になる場合もあります(選択の
			'selection' が適用され、位置はビジュアルエリアの直後に
			開始位置による)。{Vi にはありません}

							*''* *``*
''  ``			カーソルがジャンプする直前にいた、もしくは最後の "m'"
			か "m`" コマンドが行われた位置に移動します。
			|:keepjumps| コマンドモディファイヤが使われた場合には
			セットされません。
			|restore-position| も参照。

							*'quote* *`quote*
'"  `"			現在のバッファを最後に終了した時のカーソル位置に
			移動します。デフォルトで最初の行の最初の文字に移動しま
			す。それぞれの開いたファイルでこれをどのようにして使う
			かについては |last-position-jump|をご覧下さい。
			ウィンドウごとに１つではなく、バッファに対して１つの位
			置が記憶されます。バッファがあるウィンドウに表示されて
			いる間はその位置は変わりません。
			{Vi にはありません}

							*'^* *`^*
'^  `^			最後に挿入モードが終了したときのカーソル位置に移動しま
			す。これは |gi| コマンドで使われます。
			|:keepjumps| コマンドモディファイヤが使われたときは
			セットされません。
			{Vi にはありません}

							*'.* *`.*
'.  `.			最後に変更された場所に移動します。変更が始まった場所
			かその近くです。１つのコマンドが複数の変更をすることも
			あります。その場合は、変更の最後の近くになります。例え
			ば、単語を入力をしたときは、最後の文字の上になります。
			{Vi にはありません}

							*'(* *`(*
'(  `(			|(| コマンドのように、現在の文の最初に移動します。
			{Vi にはありません}

							*')* *`)*
')  `)			|)| コマンドのように、現在の文の最後に移動します。
			{Vi にはありません}

							*'{* *`{*
'{  `{			|{| コマンドのように、現在の段落の最初に移動します。
			{Vi にはありません}

							*'}* *`}*
'}  `}			|}| コマンドのように、現在の段落の最後に移動します。
			{Vi にはありません}

これらのコマンドは、それ自身はマークではなく、マークへジャンプします:

							*]'*
]'			カーソルがある行から [count] 個先の小文字のマークがあ
			る行の最初の非空白文字へ移動します。
			{Vi にはありません}

							*]`*
]`			カーソル位置以降の [count] 個先の小文字のマークへ移動
			します。
			{Vi にはありません}
							*['*
['			カーソルがある行から [count] 個前の小文字のマークがあ
			る行の最初の非空白文字へ移動します。
			{Vi にはありません}

							*[`*
[`			カーソル位置より [count] 個前の小文字のマークへ移動し
			ます。
			{Vi にはありません}


:loc[kmarks] {command}					*:loc* *:lockmarks*
			マークを調整することなく {command} を実行します。
			{訳注: 普通にコマンドを実行したときはマーク位置が調整
			される}
			これは、完了したときの行数が実行前と変わらないような変
			更をするときに便利です。
			警告:行数が変わった場合には、変更箇所以降のマークは以
			前の行番号を持ち続けるので、別の行に移動することになり
			ます。
			以下のものが行の削除・挿入後に調整されません:
			- 小文字のマーク 'a - 'z
			- 大文字のマーク 'A - 'Z
			- 番号マーク '0 - '9
			- 最後の挿入箇所 '^
			- 最後の変更箇所 '.
			- ビジュアルエリア '< と '>
			- 目印が設置された行の番号
			- quickfix 箇所の行番号
			- |jumplist| 内の位置
			- |tagstack| 内の位置
			以下のものは調整されます:
			- 直前の文脈マーク ''
			- カーソル位置
			- the view of a window on a buffer
			- 折り畳み
			- diffs

:kee[pmarks] {command}					*:kee* *:keepmarks*
			現在のところ、フィルターコマンド |:range!| にだけ効果
			があります:
			- フィルタリングの後の行数が実行前以上の場合、全ての
			  マークは同じ行番号を持ち続けます。
			- 行数が減る場合、削除された行中のマークは削除されま
			  す。
			どちらの場合にも、フィルタされたテキスト以降のマークは
			通常通りテキストに一致するよう調整されます。
			'cpoptions' オプション中に 'R' フラグがない場合、これ
			は ":keepmarks" を使うのと同じ効果があります。

							*:keepj* *:keepjumps*
:keepj[umps] {command}
			{command}の実行中の移動でマーク |''|, |'.|, |'^| と
			|jumplist| や |changelist|を変更しないようにします。
			自動的に変更やテキストの挿入を行い、ユーザーがその位置
			に行きたくないという場合に便利です。例:タイムスタンプ
			"Last change" を更新するとき: >

				:let lnum = line(".")
				:keepjumps normal gg
				:call SetLastChange()
				:keepjumps exe "normal " . lnum . "G"
<
			Note ":keepjumps" はコマンドごとに使わねばなりません。
			関数を呼び出すとその関数の中のコマンドはジャンプリスト
			を変えてしまいます。また、":keepjumps exe 'command '"
			とすると、この "command" はジャンプリストを変えてしま
			います。そうでなくて ":exe 'keepjumps command'" として
			ください。

==============================================================================
8. ジャンプ					*jump-motions*

「ジャンプ」とは次のコマンドのどれかを意味します: 新しいファイルの編集を始める
コマンドと、"'", "`", "G", "/", "?","n", "N", "%", "(", ")", "[[", "]]",
"{","}", ":s", ":tag", "L", "M", "H" です。これらのコマンドのうちのどれかを
使ってカーソルを「ジャンプ」させた場合、ジャンプする前のカーソルの位置は覚えて
おかれます。その位置を含む行を削除したり変更したりしていなければ、"''" と
"``" コマンドを使ってその位置に戻ることができます。

							*CTRL-O*
CTRL-O			ジャンプリストの中の [count] だけ古いカーソル位置に移
			動します(移動コマンドではありません)。
			{Vi にはありません}
			{|+jumplist| 機能なしのときは使用できない}

<Tab>		or					*CTRL-I* *<Tab>*
CTRL-I			ジャンプリストの中の [count] だけ新しいカーソル位置に
			移動します(移動コマンドではありません)。
			{Vi にはありません}
			{|+jumplist| 機能なしのときは使用できない}

							*:ju* *:jumps*
:ju[mps]		ジャンプリストを表示させます(移動コマンドではありませ
			ん)。{Vi にはありません}
			{|+jumplist| 機能なしのときは使用できない}

							*jumplist*
ジャンプはジャンプリストに覚えておかれ、CTRL-O と CTRL-I コマンドで前の古い位
置に移動し、そして再び新しい位置に戻ることができます。このようにしてジャンプリ
ストの中を上下に移動することができます。ジャンプリストはそれぞれのウィンドウで
分かれており、エントリの最大の数は50に固定されています。
{|+jumplist| 機能なしのときは使用できない}

例えば、3回ジャンプを行った後ではジャンプリストは次のようになっています:

  jump line  col file/text ~
    3	  1    0 some text ~
    2	 70    0 another line ~
    1  1154   23 end. ~
 > ~

"file/text" 欄はファイル名か現在のファイルであればジャンプするテキストを表示し
ています(インデントは取り除かれ、そして長い行はウィンドウに合うように短くカッ
トされます)。

現在1167行目にいるとして、CTRL-O コマンドを使うとカーソルは1154行目に移動しま
す。結果として次のようになります:

  jump line  file/text ~
    2	  1  some text ~
    1	 70  another line ~
 >  0  1154  end. ~
    1  1167  foo bar ~

ポインターは最後に使われたジャンプ位置にセットされます。次の CTRL-O コマンドは
エントリの上に、次の CTRL-I コマンドはエントリの下に移動するのに使います。ポイ
ンターが最後のエントリの下に位置している場合、このことは前に CTRL-I もしくは
CTRL-O を使っていないことを意味します。この場合 CTRL-O コマンドを使うとカーソ
ル位置がジャンプリストにくわえられます。そうしてその CTRL-O コマンドを使う前の
位置に戻ることもできます。この場合は1167行目です。

さらに CTRL-O コマンドを実行することで70行目と1行目に移動し、CTRL-I コマンドを
使うことで再び1154行目と1167行目に戻ることができます。"jump" 欄の数はこの場所
に移動するのに何回の CTRL-O もしくは CTRL-I コマンドが必要なのかを示しているこ
とも覚えておいてください。

ジャンプコマンドを使うと現在の行がジャンプリストの最後に加えられます。同じ行が
すでにジャンプリストにあった場合はそれは削除され、結果としては CTRL-O を繰り返
していると以前の場所には一度だけ戻ることになります。

|:keepjumps|コマンド修飾子が使われた場合、ジャンプ操作はリストに記憶されませ
ん。また、他の場合にもジャンプ操作は記憶されません。例. |:global|の中。
明示的にジャンプリストに追加するにはマーク'を設定します。

CTRL-O コマンドを行って1154行目に移動した後、他のジャンプコマンド(例えば: "G")
を実行したとするとジャンプリストは次のようになります:

  jump line  col file/text ~
    4	  1    0 some text ~
    3	 70    0 another line ~
    2  1167    0 foo bar ~
    1  1154   23 end. ~
 > ~

行が削除されたり挿入された場合は行番号も調整されますが、保存しないで(":n!" コ
マンドなどを使って)編集を中断した場合は失敗します。

ウィンドウを分割すると、ジャンプリストは新しいウィンドウにコピーされます。

'viminfo' オプションに項目 ' を含めていると、viminfo ファイルにジャンプリスト
が保存され、Vim を起動したときに復元されます。


変更リストへのジャンプ			*changelist* *change-list-jumps* *E664*

変更がなされたとき、カーソル位置が記憶されます。アンドゥできる全ての変更に対
し、それが前の変更に近くない限り、1つの位置が記憶されます。変更点やアンドゥさ
れた位置へジャンプするのに、以下の2つのコマンドを使うことができます。

							*g;* *E662*
g;			変更リスト中の [count] 個前の位置に移動します。
			[count] が前の変更箇所の数より大きければ、最も古い変更
			箇所へ移動します。
			それ以上古い変更が無ければエラーメッセージが表示されま
			す。(移動コマンドではありません)
			{Vi にはありません}
			{|+jumplist| 機能なしのときは使用できない}

							*g,* *E663*
g,			変更リスト中の [count] 個後の位置に移動します。
			|g;| の逆方向で、あとは同様です。
			(移動コマンドではありません)
			{Vi にはありません}
			{|+jumplist| 機能なしのときは使用できない}

count を使うと、可能な限り前／後にジャンプできます。つまり、"999g;" とすると
履歴に残っている最初の変更箇所へジャンプできます。変更リストのエントリの数は固
定されていて、|jumplist| のものと同じです。

アンドゥ可能な変更が2回、同じ行の 'textwidth' よりも小さい桁で行われたときは、
後者だけが記憶されます。これは "xxxxx" のような一連の小さな変更をリストに残す
のを避けるためです。'textwidth' が 0 のときは 'wrapmargin' が使われます。
'wrapmargin' もセットされていないときは 79 となります。詳細:速度が落ちるのを
避けるため、計算には文字数でなくバイト数が使われます (これはマルチバイトエン
コーディングに対してのみ関係します)。

テキストが挿入または削除されると、カーソル位置が変更箇所と少しずれるかもしれま
せん。(特に行が削除されたときは)

|:keepjumps| コマンドモディファイヤが使われたときは変更箇所は記憶されません。

							*:changes*
:changes		変更リストを表示します。文字 ">" のついているエントリ
			は現在の位置であることを示しています。変更が行われると
			">" は最新のエントリの下になり、"g;" で最新のエントリ
			の場所に移動できることを表します。１列目はその場所に移
			動するのに必要な count を示しています。例:

				change line  col text ~
				    3     9    8 bla bla bla
				    2    11   57 foo is a bar
				    1    14   54 the latest changed line
				>

			"3g;" とすると9行目に移動します。すると次の ":changes"
			の出力はこうなります:

				change line  col text ~
				>   0     9    8 bla bla bla
				    1    11   57 foo is a bar
				    2    14   54 the latest changed line

			この状態で "g," とすると11行目に移動し、"2g," とすると
			14行目に移動します。

==============================================================================
9. 様々な移動					*various-motions*

							*%*
%			現在の行のカーソルの後もしくは下の次のアイテムを検索し
			その対応するものにジャンプします|inclusive|。アイテム
			は次のものです:
			([{}])		丸括弧もしくは(波/角)括弧
					(これは 'matchpairs' オプションで変更
					できます)
			/* */		C スタイルのコメントの始めと終わり
			#if, #ifdef, #else, #elif, #endif
					C プリプロセッサー条件命令 (カーソルが
					# の上にあるか ([{ が後にないとき)
			他のアイテムに対しては matchit プラグインが使えます。
			|matchit-install| を参照。このプラグインを使うと、コ
			メント内の対応する括弧をスキップするという効果もありま
			す。

			'cpoptions' が "M" |cpo-m| を含んでいる場合、丸括弧と
			大括弧の前のバックスラッシュは考慮されません。"M" がな
			い場合はバックスラッシュの数が考慮され、偶数個と奇数個
			は対応しないようになります。つまり、" ( \) )" や
			"\( ( \)" となっているとき、それぞれ最初と最後の括弧が
			対応します。

			'%' 文字 |cpo-%| が 'cpoptions' にない場合、一つの行の
			中の丸括弧/大括弧の数が偶数ではなく、そして現在行と１
			つ前の行がバックスラッシュで終わっていない限り、二重引
			用符の中の丸括弧と大括弧は無視されます。
			'(', '{', '[', ']', '}', ')も無視されます(シングル引用
			符の中の丸括弧と大括弧)。このことは C ではうまく動作し
			ますが Perl ではあんまりうまくないことに注意してくださ
			い。Perl では文字列にシングル引用符も使われるのです。

			コメント内にある括弧もそうでない括弧も同様に扱われま
			す。matchit プラグイン |matchit-install| を使うか、コ
			メント内の括弧に対しては前後に引用符を書くことで、コメ
			ント内の括弧を認識して区別できます。

			カウントの前置はできません({count}% はファイルの
			{count} パーセントの位置に移動します)。'%' を
			#if/#else/#endif 上で使うと動作は行単位になります。

						*[(*
[(			[count] 前のマッチするものがない '(' に移動します。
			|exclusive|{Vi にはありません}

						*[{*
[{			[count] 前のマッチするものがない '{' に移動します。
			|exclusive|{Vi にはありません}

						*])*
])			[count] 次のマッチするものがない ')' に移動します。
			|exclusive|{Vi にはありません}

						*]}*
]}			[count] 次のマッチするものがない '}' に移動します。
			|exclusive|{Vi にはありません}

上の4つのコマンドは現在のコードブロックの最初か最後に移動するのに使うことがで
きます。'(', ')', '{', '}' 上で "%" コマンドを実行するのに似ていますが、この場
合コードブロック内のどこにいても実行することができます。C プログラムで非常に役
に立ちます。例: "case x:" にいる時に "[{" を実行することで switch 文の所に戻り
ます。

						*]m*
]m			[count]次のメソッドの始めに移動します(Javaもしくは似た
			ような構造の言語用)。メソッドの始まりの前でなければ、
			クラスの始めか終わりに移動します。カーソルの後に '{' が
			見つからなければエラーとなります。|exclusive|
			{Vi にはありません}
						*]M*
]M			[count]次のメソッドの終わりに移動します(Javaもしくは似
			たような構造の言語用)。メソッドの終わりの前でなければ、
			クラスの始めか終わりに移動します。カーソルの後に '}' が
			見つからなけばエラーとなります。|exclusive|
			{Vi にはありません}
						*[m*
[m			[count]前のメソッドの始めに移動します(Javaもしくは似た
			ような構造の言語用)。メソッドの始まりの後でなければ、
			クラスの始めか終わりに移動します。カーソルの前に '{' が
			見つからなければエラーとなります。|exclusive|
			{Vi にはありません}
						*[M*
[M			[count]前のメソッドの終わりに移動します(Javaもしくは似
			たような構造の言語用)。メソッドの終わりの後でなければ、
			クラスの始めか終わりに移動します。カーソルの前に '}' が
			見つからなければエラーとなります。|exclusive|
			{Vi にはありません}

上記の2つのコマンドはファイルがメソッドとともにクラスを含んでいることを前提と
しています。クラスの定義は '{' と '}' で囲まれていることです。クラスの中のそれ
ぞれのメソッドもまた '{' と '}' で囲まれています。このことはJava言語にも当て
はまります。ファイルは次のようなものです: >

	// comment
	class foo {
		int method_one() {
			body_one();
		}
		int method_two() {
			body_two();
		}
	}
"body_two()" にカーソルをおいて始めてみましょう。"[m" とすると "method_two()"
の始めの '{' に移動します(当然 method が長いともっと便利です)。"2[m" とすると
"method_one()" の始めに移動します。"3[m" とするとクラスの最初に移動します。 

						*[#*
[#			[count] 前のマッチするものがない "#if" か "#else" に移
			動します。|exclusive|{Vi にはありません}

						*]#*
]#			[count] 次のマッチするものがない "#else" か "#endif" 
			に移動します。|exclusive|{Vi にはありません}

これらの2つのコマンドは #if/#else/#endif を含む C のプログラムで使います。これ
を使うと #if/#else/#endif の最初か最後に移動することができます(その場合現在の
行も含みます)。それから "%" を使うことでマッチする行に移動することができます。

						*[star* *[/*
[*  or	[/		[count] 前の C コメントの始まり "/*" に移動します。
			{Vi にはありません}

						*]star* *]/*
]*  or	]/		[count] 次の C コメントの終わり "*/" に移動します。
			{Vi にはありません}


						*H*
H			スクリーンの最上行から [count] 行目(デフォルト: スク
			リーンの最上行)の最初の非空白文字に移動します(行単位
			|linewise|)。'startofline' オプションも参照してくださ
			い。カーソル位置は 'scrolloff' オプションに合うように
			調整されます。

						*M*
M			スクリーンの中央の最初の非空白文字に移動します(行単位
			|linewise|)。'startofline' オプションも参照してくださ
			い。

						*L*
L			スクリーンの最下行から [count] 行目(デフォルト: スク
			リーンの最下行)の最初の非空白文字に移動します(行単位
			|linewise|)。'startofline' オプションも参照してくださ
			い。カーソル位置は 'scrolloff' オプションに合うように
			調整されます。

<LeftMouse>		スクリーン上でマウスがクリックされた場所に移動します
			|exclusive|。参照 |<LeftMouse>|。もしその位置がステー
			タス行の中であると、そのウィンドウがアクティブなウィン
			ドウとなりカーソルは動きません。{Vi にはありません}

 vim:tw=78:ts=8:ft=help:norl:
