*usr_24.txt*	For Vim バージョン 7.4.  Last change: 2006 Jul 23

		     VIM USER MANUAL - by Bram Moolenaar

				素早く入力する


テキストを入力するときに、キーストロークを減らしたり入力ミスを防いだりする方法
がいくつかあります。補完機能を使えば以前に入力した単語を繰り返し入力できます。
長い単語を短縮形で入力することもできます。キーボードに無い文字を入力する方法も
あります。

|24.1|	修正する
|24.2|	対応する括弧を表示する
|24.3|	補完
|24.4|	挿入を繰り返す
|24.5|	隣の行からコピーする
|24.6|	レジスタを挿入する
|24.7|	短縮形
|24.8|	特殊な文字を入力する
|24.9|	ダイグラフ (Digraph)
|24.10|	ノーマルモードコマンド

次章: |usr_25.txt|  テキストの整形
前章: |usr_23.txt|  特殊なファイルを編集する
目次: |usr_toc.txt|

==============================================================================
*24.1*	修正する

<BS> キーは既に説明しましたね。<BS> はカーソル直前の文字を削除します。<Del>
キーはカーソルの下(後)の文字を削除します。
直前の単語をまるごと削除したい場合は CTRL-W を使います:

	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~

行全体を削除して行頭から入力しなおしたい場合は CTRL-U を使います。カーソルより
後ろの文字とインデントは削除されません。最初の非空白文字からカーソルまでのテキ
ストだけが削除されます。例えば、カーソルが "fallen" の "f" にある場合、CTRL-U
を押すと次のようになります:

	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~

何個か前の単語だけを修正したい場合はカーソルを動かす必要があります。例えば、次
のように入力してから:

	The horse had follen to the ground ~

途中にある "follen" を "fallen" に修正してみます。カーソルが末尾にある場合、次
のように入力すれば修正できます: >

					<Esc>4blraA

<	挿入モードを抜ける		<Esc>
	4 単語戻る			     4b
	最初の "o" に移動する		       l
	"a" に置換する				ra
	行末に移動して挿入モードを再開		  A

他の方法もあります: >

		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>

<	4 単語戻る。			<C-Left><C-Left><C-Left><C-Left>
	最初の "o" に移動する			<Right>
	"o" を削除する				       <Del>
	"a" を挿入する					    a
	行末に移動する					     <End>

挿入モードの中で特殊キーを使って移動しています。これは普通のモードレスエディタ
の操作と似ています。操作方法は覚えやすいかもしれませんが少し面倒です (カーソル
キーを押すには手をホームポジションから離さなければならないし、<End> キーを押す
にはキーボードに視線を移さなければならない)。
特殊キーは挿入モードの中で使えるのでマップを書くときに重宝します。マップの中で
使う分には入力が面倒になることもありません。
挿入モードでは次の特殊キーが使えます:

	<C-Home>	ファイルの先頭に移動
	<PageUp>	1 画面分、逆スクロール
	<Home>		行頭へ移動
	<S-Left>	1 単語左へ移動
	<C-Left>	1 単語左へ移動
	<S-Right>	1 単語右へ移動
	<C-Right>	1 単語右へ移動
	<End>		行末へ移動
	<PageDown>	1 画面分、スクロール
	<C-End>		ファイルの末尾に移動

使えるキーは他にもあります。|ins-special-special| 参照。

==============================================================================
*24.2*	対応する括弧を表示する

")" を入力したときに、対応する "(" の場所を確認できたら便利ですよね。次のコマ
ンドでそのように設定できます: >

	:set showmatch

例えば "(example)" と入力したとき、")" を入力した瞬間に、対応する括弧にカーソ
ルが移動します。カーソルは 0.5 秒くらいその場所に留まり、再び元の場所に帰って
きます。
対応する括弧が見つからなかった場合はビープ音が鳴ります。そのときは、( を入力し
忘れてないか、) を入力し過ぎてないか、確認しましょう。
この機能は、[] や {} の組み合わせにも対応しています。カーソルが移動していると
きに、戻ってくるまで次の入力を待つ必要はありません。次の文字を入力した瞬間に
カーソルは元に戻るので、すぐに入力を再開できます。
カーソルが移動先で待機する時間は 'matchtime' オプションで設定できます。例えば、
1.5 秒待機するには次のように設定します: >

	:set matchtime=15

時間は 1/10 秒単位で指定してください。

==============================================================================
*24.3*	補完

テキストの中から単語を検索して補完することができます。単語の出だしを入力して
CTRL-P を押すと、残りの部分が入力されます。
例えば、C プログラムを書いていて、次のように入力したいとします:

	total = ch_array[0] + ch_array[1] + ch_array[2]; ~

まず、次のように入力してください:

	total = ch_array[0] + ch_ ~

ここで、CTRL-P コマンドを使って単語を補完します。カーソル直前の文字列にマッチ
する単語が検索されます。この場合なら、"ch_" にマッチする単語、つまり
"ch_array" がヒットします。したがって、CTRL-P を押すと次のようになります:

	total = ch_array[0] + ch_array ~

続けて入力し、次のようになりました (末尾に空白があります):

	total = ch_array[0] + ch_array[1] +  ~

さて、ここで CTRL-P を押すと再びカーソル直前の文字列が補完されます。今回は文字
が無いので、最初に見つかった単語、つまり "ch_array" が補完されます。もう一度
CTRL-P を押すと、さらに次の候補が補完されます。この場合は "total" です。もう一
度 CTRL-P を押せばさらに次の候補が補完されます。次の単語が見つからなかった場合
は元の文字列に戻ります。この例では空文字列です。四度目に CTRL-P を押すと再び最
初の "ch_array" が補完されます。

前方検索する場合は CTRL-N を使います。検索はファイル終端を超えて処理されるの
で、CTRL-N と CTRL-P は順番が違うだけで、同じ単語が検索されます。Hint: CTRL-N
は Next-match (次の候補)、CTRL-P は Previous-match (前の候補) です。

単語の補完では、様々な場所から単語を検索できます。初期設定では、次の場所が検索
されます:

	1. カレントファイル
	2. 他のウィンドウのファイル
	3. ロードされたファイル (隠しバッファ)
	4. ロードされてないファイル (休眠バッファ)
	5. タグファイル
	6. カレントファイルが #include しているファイル


オプション
----------

検索場所の順番は 'complete' オプションで設定できます。

検索には 'ignorecase' オプションが使われます。このオプションがオンのときは、大
文字と小文字は区別されません。

'infercase' は補完用の特別なオプションです。大文字と小文字を区別しない
('ignorecase' がオンに設定されている) ときでも、自分で入力した文字の種類をその
まま使えます。つまり、"For" と入力して "fortunately" がマッチしたとき、結果は
"Fortunately" になります。


補完タイプの指定
----------------

補完したい単語の種類がわかっている場合は、次のコマンドで補完の種類を指定できま
す:

	CTRL-X CTRL-F		ファイル名
	CTRL-X CTRL-L		行全体
	CTRL-X CTRL-D		マクロ定義 (インクルードファイルの中も探す)
	CTRL-X CTRL-I		カレントファイルとインクルードファイル
	CTRL-X CTRL-K		辞書
	CTRL-X CTRL-T		同義語辞書 (シソーラス)
	CTRL-X CTRL-]		タグ
	CTRL-X CTRL-V		Vim のコマンドライン

補完を実行した後は、CTRL-N で次の候補、CTRL-P で前の候補を検索できます。
各コマンドの詳細は |ins-completion| を参照してください。


ファイル名の補完
-----------------

例として CTRL-X CTRL-F を使って説明します。これはファイル名を補完するコマンド
です。カレントディレクトリのファイルが検索され、カーソル直前の文字列にマッチす
るファイル名が補完されます。
例えば、カレントディレクトリに次のファイルがあるとします:

	main.c  sub_count.c  sub_done.c  sub_exit.c

挿入モードに入って次のように入力します:

	The exit code is in the file sub ~

そして、CTRL-X CTRL-F を入力します。カレントディレクトリから "sub" にマッチす
るファイルが検索されます。最初にマッチするのは sub_count.c です。このファイル
は求めているファイルではありませんでした。CTRL-N を押して次の候補を検索しましょ
う。次に sub_done.c がマッチします。もう一度 CTRL-N を押すと sub_exit.c がマッ
チします。結果:

	The exit code is in the file sub_exit.c ~

ファイル名の先頭を / (Unix) や C:\ (MS-Windows) で開始すれば、ファイルシステム
全体からファイルを検索できます。例えば、"/u" と入力してから CTRL-X CTRL-F と入
力すると "/usr" がヒットします (Unix の場合):

	the file is found in /usr/ ~

もう一度 CTRL-N を押すと "/u" に戻ってしまいます。"/usr/" を確定してからさらに
深い階層へ進みたい場合は再び CTRL-X CTRL-F を使います:

	the file is found in /usr/X11R6/ ~

もちろん、ファイル構成が違えば結果は異なるでしょう。検索結果はアルファベット順
にソートされます。


ソースコードの補完

ソースコードは書式が決まっているので、より賢い補完を実装することができます。
Vim ではそれをオムニ補完 (Omni completion) と呼びます。某エディタではインテリ
センスと呼ばれていますが、それは商標です。

オムニ補完のキーは CTRL-X CTRL-O です。O は Omni の頭文字なので覚えやすいでしょ
う。C 言語のソースを使って説明します:

	{ ~
	    struct foo *p; ~
	    p-> ~

カーソルは "p->" の後ろにあります。CTRL-X CTRL-O を押すと、"struct foo" のメン
バが候補として表示されます。これは CTRL-P の補完とはまったく違います。CTRL-P
ではあらゆる単語が候補になりますが、オムニ補完は "struct foo" のメンバだけが補
完されます。

オムニ補完を使うには設定が必要です。最低でもファイルタイププラグインを有効にし
ておく必要があります。vimrc に以下の行を書き加えてください: >
	filetype plugin on
または: >
	filetype plugin indent on

C 言語の場合はタグファイルを作成して 'tags' オプションを設定する必要がありま
す。|ft-c-omni| を参照してください。他のファイルタイプでも似たような設定が必要
になります。|compl-omni-filetypes| を参照してください。オムニ補完は特定のファ
イルタイプでしか利用できません。'omnifunc' オプションを確認し、オムニ補完が利
用できるかどうか確認してください。

==============================================================================
*24.4*	挿入を繰り返す

CTRL-A を押すと、前回の挿入モードで入力したテキストを挿入できます。
例えば、次のようなファイルがあったとします:

	"file.h" ~
	/* Main program begins */ ~

一行目の行頭に "#include " を挿入します:

	#include "file.h" ~
	/* Main program begins */ ~

"j^" コマンドで次の行の行頭に移動し、再び "#include " を挿入してみます。次のよ
うに入力しましょう: >

	i CTRL-A

結果は次のようになります:

	#include "file.h" ~
	#include /* Main program begins */ ~

CTRL-A は前回に入力したテキストを挿入するコマンドなので、"#include " が挿入さ
れました。続けて "main.h"<Enter> と入力し、行を完成させましょう:

	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~

CTRL-@ コマンドは CTRL-A と同じことを実行してから挿入モードを抜けます。まった
く同じ挿入を繰り返したいときに使います。

==============================================================================
*24.5*	隣の行からコピーする

CTRL-Y コマンドを使うと、カーソルの上の文字を挿入できます。一つ上の行を複製し
たい場合に便利です。例えば、次のような C 言語のコードがあるとして:

	b_array[i]->s_next = a_array[i]->s_next; ~

"s_next" を "s_prev" に変えただけの同じ行を入力してみます。新しい行を開いて
CTRL-Y を 14 回押して、"next" の "n" の直前まで進みます:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_ ~

そして "prev" と入力します:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~

続けて、次の "next" まで CTRL-Y を押します。

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev = a_array[i]->s_ ~

"prev;" と入力すれば、行が完成です。

CTRL-Y と似たコマンドに CTRL-E があります。これはカーソルの下の文字を挿入する
コマンドです。

==============================================================================
*24.6*	レジスタを挿入する

CTRL-R {register} コマンドを使うと、レジスタの内容を挿入できます。長い単語を入
力するのが簡単になります。例えば、次の行を入力したいとします。

	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~

関数名は別のファイルで定義されています。そのファイルを開いてカーソルを関数名の
先頭に移動し、次のコマンドでレジスタ v にヤンクします: >

	"vyiw

"v はレジスタの指定、"yiw" は yank-inner-word (単語をヤンクする) です。さて、
元のファイルに戻り、挿入モードを開始して次のように入力します:

	ir = ~

ここで、CTRL-R v を押して関数の名前を挿入します:

	r = VeryLongFunction ~

続けて関数の引数などを入力し、関数名を入力するときになったら再び CTRL-R v を使
います。
同じことは補完を使ってもできますが、同じ文字で始まる単語がたくさんある場合には
レジスタが便利です。

レジスタの中に <BS> などの特殊な文字が含まれている場合、その文字は、実際にキー
ボードから入力されたのと同じように処理されます。それが望みの動作ではない場合
(例えば、<BS> をテキストとして挿入したい場合) は CTRL-R CTRL-R {register} を
使ってください。

==============================================================================
*24.7*	短縮形 (Abbreviations)

短縮形とは長い単語を置き換える短い単語のことです。例えば、"ad" は
"advertisement" の短縮形です。Vim では、入力した短縮形を自動的に展開することが
できます。
"ad" を "advertisement" の短縮形として登録するには、次のコマンドを使います: >

	:iabbrev ad advertisement

これで、"ad" と入力すると、完全形の "advertisement" がテキストに挿入されます。
短縮形の置き換えは、スペースなどの、単語の一部として認識されない文字を入力した
ときに実行されます:

	入力した文字		画面上での見え方
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~

"ad" と入力しただけでは展開されません。これは例えば "add" のような単語も入力で
きるようにするためです。単語の境界が確定してから短縮形の展開が適用されます。


複数の単語の短縮形
------------------

複数の単語に展開される短縮形を定義できます。例えば、"JB" を "Jack Benny" の短
縮形として登録するには、次のコマンドを使います: >

	:iabbrev JB Jack Benny

プログラムを書くとき、私は少し変った短縮形を使っています: >

	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/

これはコメントブロックを作成するときに使います。コメントを開始するときに #b で
最初の行を描き、コメントを書いてから、#e で末尾の行を描きます。#e の展開形がス
ペースで始まっています。別の言い方をすれば、最初の二文字がスペースとスターに
なっています。通常、短縮形と展開形の間の空白は無視されるので、スペースを入れた
い場合は <, S, p, a, c, e, > という 7 文字の特殊な表記を使います。

	Note:
	":iabbrev" は入力するのが長くて大変なので、":iab" でも構いません。
	これは短縮コマンドの短縮形です!


入力ミスを直す
--------------

入力ミスの癖ってありますよね。例えば、"the" と入力するはずが "teh" になってし
まったり。短縮形を使って修正しましょう: >

	:abbreviate teh the

このような短縮形のリストを作成し、入力ミスの癖を見つけたら追加しましょう。


短縮形を一覧表示する
--------------------

":abbreviate" コマンドで短縮形の一覧を表示できます: >

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

行頭の "i" は挿入モードの意味です。その短縮形は挿入モードの中だけで有効です。
他にも、次のような文字が表示されます:

	c	コマンドラインモード			:cabbrev
	!	挿入モードとコマンドラインモード	:abbreviate

コマンドラインモードで短縮形が役に立つことはあまりないので、"iabbrev" コマンド
を主に使うことになるでしょう。"iabbrev" なら、次のようなコマンドで "ad" が展開
される心配はありません: >

	:edit ad


短縮形の削除
------------

短縮形を取り除くには ":unabbreviate" コマンドを使います。次のような短縮形が登
録されているなら: >

	:abbreviate @f fresh

次のコマンドで削除できます: >

	:unabbreviate @f

このコマンドを入力すると @f が "fresh" に展開されてしまいますが、心配はいりま
せん。コマンドは正しく処理されます (ただし、"fresh" という別の短縮形が定義され
ている場合は期待した動作になりません。まぁそんなことはほとんどないはずですが)。
すべての短縮形を削除するには次のコマンドを使います: >

	:abclear

":unabbreviate" と ":abclear" にも、挿入モード用 (":iunabbreviate" と
":iabclear") とコマンドライン用 (":cunabbreviate" と ":cabclear") があります。


短縮形の再マップ
----------------

短縮形を定義するときに注意すべき点がもう一つあります。展開された文字列がマップ
されないようにしなくてはなりません。例をあげましょう: >

	:abbreviate @a adder
	:imap dd disk-door

"@a" を入力すると "adisk-doorer" になってしまいます。これは意図した動作ではな
いはずです。これを避けるには、":noreabbrev" コマンドを使います。":abbreviate"
と機能は同じですが、展開結果にマップが適用されません: >

	:noreabbrev @a adder

これで、展開結果がマップされなくなります。

==============================================================================
*24.8*	特殊な文字を入力する

CTRL-V コマンドを使うと、その次に入力した文字をそのまま挿入できます。つまり、
文字の特殊効果が無視されます。例えば、このように入力すると: >

	CTRL-V <Esc>
<
エスケープ文字が挿入されます。挿入モードは終了しません。(CTRL-V の後ろの空白は
見やすくするためのものなので、実際には入力しないでください)

	Note:
	MS-Windows では CTRL-V はテキストのペーストに使われています。CTRL-V の
	代わりに CTRL-Q を使ってください。Unixでは逆に一部の端末で CTRL-Q に特
	別な意味があるので使えないかもしれません。

また、CTRL-V {digits} コマンドを使うと、文字コードを 10 進数で指定して、その文
字を入力できます。例えば、文字コード 127 は <Del> 文字 (<Del> *キー*と同じとは
限りません) です。<Del> を挿入するには次のように入力します: >

	CTRL-V 127

同じやりかたで文字コード 255 までの文字を入力できます。文字コードが 2 桁以下の
場合は、数字以外の文字を入力してコマンドを確定してください。
数字以外の文字を入力したくない場合は、数値が 3 桁になるように 1 つか 2 つの
"0" を数値の前に付けてください。
次のコマンドはいずれも <Tab> と "." を挿入します:

	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.

文字コードは 16 進数でも指定できます。その場合は CTRL-V の直後に "x" を指定し
ます: >

	CTRL-V x7f

この場合もコード 255 (CTRL-V xff) までの文字が入力できます。"o" で 8 進数の数
値を指定することもできます。他にも "u" と "U" でそれぞれ 16 ビットと 32 ビット
の文字コード (例えば Unicode の文字) を指定できます: >

	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678

==============================================================================
*24.9*	ダイグラフ (Digraph)

例えば、コピーライト文字 (©) など、キーボードに無い文字がいくつかあります。そ
のような文字を Vim で入力するにはダイグラフを使います。つまり、二文字で一文字
を表現します。例えば、コピーライト文字 (©) を入力するには、次のようにします: >

	CTRL-K Co

使用できるダイグラフの一覧を表示するには、次のコマンドを使います: >

	:digraphs

一部抜粋:

  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~

これを見れば、例えば CTRL-K Pd でポンド記号 (£) が入力できることがわかります。
文字番号は 163 (10進数) です。
Pd は Pound (ポンド) の略です。ほとんどのダイグラフには、生成される文字が連想
しやすい文字が割り当てられています。法則は表を見ればだいたいわかると思います。
ダイグラフの一文字目と二文字目は逆の順番で入力しても構いません。ただし、その組
み合わせが他のダイグラフで使われていない場合に限ります。すなわち、CTRL-K dP も
ポンド記号になります。"dP" という組み合わせが他に使われていないので、"Pd" のダ
イグラフが使われるのです。

	Note:
	ダイグラフはユーザーが使っている (と Vim が認識している) 文字セットに
	依存します。MS-DOS の文字セットと MS-Windows の文字セットは違います。
	":digraphs" を使って、利用可能なダイグラフを確認してください。

自分でダイグラフを定義することもできます。例: >

	:digraph a" ä

CTRL-K a" を入力すると ä になります。文字コードを 10 進数で指定することもでき
ます。次のコマンドは上記のコマンドと同じです: >

	:digraph a" 228

ダイグラフについての詳細は |digraphs| を参照してください。
他にも、キーマップを使って特殊な文字を入力することもできます。詳しくは |45.5|
参照。

==============================================================================
*24.10*	ノーマルモードコマンド

挿入モードで使えるコマンドはそれほど多くありませんが、ノーマルモードにはたくさ
んのコマンドがあります。それらのコマンドを使うには <Esc> で挿入モードを抜けて、
ノーマルモードコマンドを実行し、"i" または "a" で挿入モードに戻ってこなければ
なりません。
もっと簡単な方法があります。CTRL-O {command} を使えばノーマルモードコマンドを
挿入モードの中で実行できます。例えば、次のコマンドでカーソル位置から行末まで削
除できます: >

	CTRL-O D

この方法で実行できるのは一つのコマンドだけです。ただし、レジスタやカウントの指
定はできます。もう少し複雑な例: >

	CTRL-O "g3dw

三つの単語を削除してレジスタ g に格納します。

==============================================================================

次章: |usr_25.txt|  テキストの整形

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
