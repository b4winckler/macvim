*usr_24.txt*	For Vim バージョン 7.3.  Last change: 2006 Jul 23

		     VIM USER MANUAL - by Bram Moolenaar

				素早く入力する


テキストを入力するときに、キーストロークを減らしたり入力ミスを防いだりする方法
がいくつかあります。補完機能を使えば以前に入力した単語を繰り返し入力できます。
長い単語を短縮形で入力することもできます。キーボードに無い文字を入力する方法も
あります。

|24.1|	修正する
|24.2|	対応する括弧を表示する
|24.3|	補完
|24.4|	挿入を繰り返す
|24.5|	隣の行からコピーする
|24.6|	レジスタを挿入する
|24.7|	短縮形
|24.8|	特殊な文字を入力する
|24.9|	二重字 (Digraph)
|24.10|	ノーマルモードコマンド

次章: |usr_25.txt|  テキストの整形
前章: |usr_23.txt|  特殊なファイルを編集する
目次: |usr_toc.txt|

==============================================================================
*24.1*	修正する

<BS> キーは既に説明しましたね。<BS> はカーソル直前の文字を削除します。<Del>
キーはカーソルの下(後)の文字を削除します。
直前の単語をまるごと削除したい場合は CTRL-W を使います:

	The horse had fallen to the sky ~
				       CTRL-W
	The horse had fallen to the ~

行全体を削除して行頭から入力しなおしたい場合は CTRL-U を使います。カーソルより
後ろの文字とインデントは削除されません。最初の非空白文字からカーソルまでのテキ
ストだけが削除されます。例えば、カーソルが "fallen" の "f" にある場合、CTRL-U
を押すと次のようになります:

	The horse had fallen to the ~
		      CTRL-U
	fallen to the ~

何個か前の単語だけを修正したい場合はカーソルを動かす必要があります。例えば、次
のように入力してから:

	The horse had follen to the ground ~

途中にある "follen" を "fallen" に修正してみます。カーソルが末尾にある場合、次
のように入力すれば修正できます: >

					<Esc>4blraA

<	挿入モードを抜ける		<Esc>
	4 単語戻る			     4b
	最初の "o" に移動する		       l
	"a" に置換する				ra
	行末に移動して挿入モードを再開		  A

他の方法もあります: >

		<C-Left><C-Left><C-Left><C-Left><Right><Del>a<End>

<	4 単語戻る。			<C-Left><C-Left><C-Left><C-Left>
	最初の "o" に移動する			<Right>
	"o" を削除する				       <Del>
	"a" を挿入する					    a
	行末に移動する 					     <End>

挿入モードの中で特殊キーを使って移動しています。これは普通のモードレスエディタ
の操作と似ています。操作方法は覚えやすいかもしれませんが少し面倒です (カーソル
キーを押すには手をホームポジションから離さなければならないし、<End> キーを押す
にはキーボードに視線を移さなければならない)。
特殊キーは挿入モードの中で使えるのでマップを書くときに重宝します。マップの中で
使う分には入力が面倒になることもありません。
挿入モードでは次の特殊キーが使えます:

	<C-Home>	ファイルの先頭に移動
	<PageUp>	1 画面分、逆スクロール
	<Home>		行頭へ移動
	<S-Left>	1 単語左へ移動
	<C-Left>	1 単語左へ移動
	<S-Right>	1 単語右へ移動
	<C-Right>	1 単語右へ移動
	<End>		行末へ移動
	<PageDown>	1 画面分、スクロール
	<C-End>		ファイルの末尾に移動

使えるキーは他にもあります。|ins-special-special| 参照。

==============================================================================
*24.2*	対応する括弧を表示する

")" を入力したときに、対応する "(" の場所を確認できたら便利ですよね。次のコマ
ンドでそのように設定できます: >

	:set showmatch

例えば "(example)" と入力したとき、")" を入力した瞬間に、対応する括弧にカーソ
ルが移動します。カーソルは 0.5 秒くらいその場所に留まり、再び元の場所に帰って
きます。
対応する括弧が見つからなかった場合はビープ音が鳴ります。そのときは、( を入力し
忘れてないか、) を入力し過ぎてないか、確認しましょう。
この機能は、[] や {} の組み合わせにも対応しています。カーソルが移動していると
きに、戻ってくるまで次の入力を待つ必要はありません。次の文字を入力した瞬間に
カーソルは元に戻るので、すぐに入力を再開できます。
カーソルが移動先で待機する時間は 'matchtime' オプションで設定できます。例えば、
1.5 秒待機するには次のように設定します: >

	:set matchtime=15

時間は 1/10 秒単位で指定してください。

==============================================================================
*24.3*	補完

テキストの中から単語を検索して補完することができます。単語の出だしを入力して
CTRL-P を押すと、残りの部分が入力されます。
例えば、C プログラムを書いていて、次のように入力したいとします:

	total = ch_array[0] + ch_array[1] + ch_array[2]; ~

まず、次のように入力してください:

	total = ch_array[0] + ch_ ~

ここで、CTRL-P コマンドを使って単語を補完します。カーソル直前の文字列にマッチ
する単語が検索されます。この場合なら、"ch_" にマッチする単語、つまり
"ch_array" がヒットします。したがって、CTRL-P を押すと次のようになります:

	total = ch_array[0] + ch_array ~

続けて入力し、次のようになりました (末尾に空白があります):

	total = ch_array[0] + ch_array[1] +  ~

さて、ここで CTRL-P を押すと再びカーソル直前の文字列が補完されます。今回は文字
が無いので、最初に見つかった単語、つまり "ch_array" が補完されます。もう一度
CTRL-P を押すと、さらに次の候補が補完されます。この場合は "total" です。もう一
度 CTRL-P を押せばさらに次の候補が補完されます。次の単語が見つからなかった場合
は元の文字列に戻ります。この例では空文字列です。四度目に CTRL-P を押すと再び最
初の "ch_array" が補完されます。

前方検索する場合は CTRL-N を使います。検索はファイル終端を超えて処理されるの
で、CTRL-N と CTRL-P は順番が違うだけで、同じ単語が検索されます。Hint: CTRL-N
は Next-match (次の候補)、CTRL-P は Previous-match (前の候補) です。

単語の補完では、様々な場所から単語を検索できます。初期設定では、次の場所が検索
されます:

	1. カレントファイル
	2. 他のウィンドウのファイル
	3. ロードされたファイル (隠しバッファ)
	4. ロードされてないファイル (休眠バッファ)
	5. タグファイル
	6. カレントファイルが #include しているファイル


オプション
----------

検索場所の順番は 'complete' オプションで設定できます。

検索には 'ignorecase' オプションが使われます。このオプションがオンのときは、大
文字と小文字は区別されません。

'infercase' は補完用の特別なオプションです。大文字と小文字を区別しない
('ignorecase' がオンに設定されている) ときでも、自分で入力した文字の種類をその
まま使えます。つまり、"For" と入力して "fortunately" がマッチしたとき、結果は
"Fortunately" になります。


補完タイプの指定
----------------

補完したい単語の種類がわかっている場合は、次のコマンドで補完の種類を指定できま
す:

	CTRL-X CTRL-F		ファイル名
	CTRL-X CTRL-L		行全体
	CTRL-X CTRL-D		マクロ定義 (インクルードファイルの中も探す)
	CTRL-X CTRL-I		カレントファイルとインクルードファイル
	CTRL-X CTRL-K		辞書
	CTRL-X CTRL-T		同義語辞書 (シソーラス)
	CTRL-X CTRL-]		タグ
	CTRL-X CTRL-V		Vim のコマンドライン

補完を実行した後は、CTRL-N で次の候補、CTRL-P で前の候補を検索できます。
各コマンドの詳細は |ins-completion| を参照してください。


ファイル名の補完
-----------------

例として CTRL-X CTRL-F を使って説明します。これはファイル名を補完するコマンド
です。カレントディレクトリのファイルが検索され、カーソル直前の文字列にマッチす
るファイル名が補完されます。
例えば、カレントディレクトリに次のファイルがあるとします:

	main.c  sub_count.c  sub_done.c  sub_exit.c

挿入モードに入って次のように入力します:

	The exit code is in the file sub ~

そして、CTRL-X CTRL-F を入力します。カレントディレクトリから "sub" にマッチす
るファイルが検索されます。最初にマッチするのは sub_count.c です。このファイル
は求めているファイルではありませんでした。CTRL-N を押して次の候補を検索しましょ
う。次に sub_done.c がマッチします。もう一度 CTRL-N を押すと sub_exit.c がマッ
チします。結果:

	The exit code is in the file sub_exit.c ~

ファイル名の先頭を / (Unix) や C:\ (MS-Windows) で開始すれば、ファイルシステム
全体からファイルを検索できます。例えば、"/u" と入力してから CTRL-X CTRL-F と入
力すると "/usr" がヒットします (Unix の場合):

	the file is found in /usr/ ~

もう一度 CTRL-N を押すと "/u" に戻ってしまいます。"/usr/" を確定してからさらに
深い階層へ進みたい場合は再び CTRL-X CTRL-F を使います:

	the file is found in /usr/X11R6/ ~

もちろん、ファイル構成が違えば結果は異なるでしょう。検索結果はアルファベット順
にソートされます。


ソースコードの補完

ソースコードは書式が決まっているので、より賢い補完を実装することができます。
Vim ではそれをオムニ補完 (Omni completion) と呼びます。某エディタではインテリ
センスと呼ばれていますが、それは商標です。

オムニ補完のキーは CTRL-X CTRL-O です。O は Omni の頭文字なので覚えやすいでしょ
う。C 言語のソースを使って説明します:

	{ ~
	    struct foo *p; ~
	    p-> ~

カーソルは "p->" の後ろにあります。CTRL-X CTRL-O を押すと、"struct foo" のメン
バが候補として表示されます。これは CTRL-P の補完とはまったく違います。CTRL-P
ではあらゆる単語が候補になりますが、オムニ補完は "struct foo" のメンバだけが補
完されます。

オムニ補完を使うには設定が必要です。最低でもファイルタイププラグインを有効にし
ておく必要があります。vimrc に以下の行を書き加えてください: >
	filetype plugin on
または: >
	filetype plugin indent on

C 言語の場合はタグファイルを作成して 'tags' オプションを設定する必要がありま
す。|ft-c-omni| を参照してください。他のファイルタイプでも似たような設定が必要
になります。|compl-omni-filetypes| を参照してください。オムニ補完は特定のファ
イルタイプでしか利用できません。'omnifunc' オプションを確認し、オムニ補完が利
用できるかどうか確認してください。

==============================================================================
*24.4*	挿入を繰り返す

CTRL-A を押すと、前回の挿入モードで入力したテキストを挿入できます。
例えば、次のようなファイルがあったとします:

	"file.h" ~
	/* Main program begins */ ~

一行目の行頭に "#include " を挿入します:

	#include "file.h" ~
	/* Main program begins */ ~

"j^" コマンドで次の行の行頭に移動し、再び "#include " を挿入してみます。次のよ
うに入力しましょう: >

	i CTRL-A

結果は次のようになります:

	#include "file.h" ~
	#include /* Main program begins */ ~

CTRL-A は前回に入力したテキストを挿入するコマンドなので、"#include " が挿入さ
れました。続けて "main.h"<Enter> と入力し、行を完成させましょう:

	#include "file.h" ~
	#include "main.h" ~
	/* Main program begins */ ~

CTRL-@ コマンドは CTRL-A と同じことを実行してから挿入モードを抜けます。まった
く同じ挿入を繰り返したいときに使います。

==============================================================================
*24.5*	隣の行からコピーする

CTRL-Y コマンドを使うと、カーソルの上の文字を挿入できます。一つ上の行を複製し
たい場合に便利です。例えば、次のような C 言語のコードがあるとして:

	b_array[i]->s_next = a_array[i]->s_next; ~

"s_next" を "s_prev" に変えただけの同じ行を入力してみます。新しい行を開いて
CTRL-Y を 14 回押して、"next" の "n" の直前まで進みます:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_ ~

そして "prev" と入力します:

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev ~

続けて、次の"next"まで CTRL-Y を押します。

	b_array[i]->s_next = a_array[i]->s_next; ~
	b_array[i]->s_prev = a_array[i]->s_ ~

"prev;" と入力すれば、行が完成です。

CTRL-Y と似たコマンドに CTRL-E があります。これはカーソルの下の文字を挿入する
コマンドです。

==============================================================================
*24.6*	レジスタを挿入する

CTRL-R {register} コマンドを使うと、レジスタの内容を挿入できます。長い単語を入
力するのが簡単になります。例えば、次の行を入力したいとします。

	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) ~

関数名は別のファイルで定義されています。そのファイルを開いてカーソルを関数名の
先頭に移動し、次のコマンドでレジスタ v にヤンクします: >

	"vyiw

"v はレジスタの指定、"yiw" は yank-inner-word (単語をヤンクする) です。さて、
元のファイルに戻り、挿入モードを開始して次のように入力します:

	ir = ~

ここで、CTRL-R v を押して関数の名前を挿入します:

	r = VeryLongFunction ~

続けて関数の引数などを入力し、関数名を入力するときになったら再び CTRL-R v を使
います。
同じことは補完を使ってもできますが、同じ文字で始まる単語がたくさんある場合には
レジスタが便利です。

レジスタの中に <BS> などの特殊な文字が含まれている場合、その文字は、実際にキー
ボードから入力されたのと同じように処理されます。それが望みの動作ではない場合
(例えば、<BS> をテキストとして挿入したい場合) は CTRL-R CTRL-R {register} を
使ってください。

==============================================================================
*24.7*	短縮形 (Abbreviations)

短縮形とは長い単語を置き換える短い単語のことです。例えば、"ad" は
"advertisement" の短縮形です。Vim では、入力した短縮形を自動的に展開することが
できます。
"ad" を "advertisement" の短縮形として登録するには、次のコマンドを使います: >

	:iabbrev ad advertisement

これで、"ad" と入力すると、完全形の "advertisement" がテキストに挿入されます。
短縮形の置き換えは、スペースなどの、単語の一部として認識されない文字を入力した
ときに実行されます:

	入力した文字		画面上での見え方
	I saw the a		I saw the a ~
	I saw the ad		I saw the ad ~
	I saw the ad<Space>	I saw the advertisement<Space> ~

"ad" と入力しただけでは展開されません。これは例えば "add" のような単語も入力で
きるようにするためです。単語の境界が確定してから短縮形の展開が適用されます。


複数の単語の短縮形
------------------

複数の単語に展開される短縮形を定義できます。例えば、"JB" を "Jack Benny" の短
縮形として登録するには、次のコマンドを使います: >

	:iabbrev JB Jack Benny

プログラムを書くとき、私は少し変った短縮形を使っています: >

	:iabbrev #b /****************************************
	:iabbrev #e <Space>****************************************/

これはコメントブロックを作成するときに使います。コメントを開始するときに #b で
最初の行を描き、コメントを書いてから、#e で末尾の行を描きます。#e の展開形がス
ペースで始まっています。別の言い方をすれば、最初の二文字がスペースとスターに
なっています。通常、短縮形と展開形の間の空白は無視されるので、スペースを入れた
い場合は <, S, p, a, c, e, > という 7 文字の特殊な表記を使います。

	Note:
	":iabbrev" は入力するのが長くて大変なので、":iab" でも構いません。
	これは短縮コマンドの短縮形です!


入力ミスを直す
--------------

入力ミスの癖ってありますよね。例えば、"the" と入力するはずが "teh" になってし
まったり。短縮形を使って修正しましょう: >

	:abbreviate teh the

このような短縮形のリストを作成し、入力ミスの癖を見つけたら追加しましょう。


短縮形を一覧表示する
--------------------

":abbreviate" コマンドで短縮形の一覧を表示できます: >

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

行頭の "i" は挿入モードの意味です。その短縮形は挿入モードの中だけで有効です。
他にも、次のような文字が表示されます:

	c	コマンドラインモード			:cabbrev
	!	挿入モードとコマンドラインモード	:abbreviate

コマンドラインモードで短縮形が役に立つことはあまりないので、"iabbrev" コマンド
を主に使うことになるでしょう。"iabbrev" なら、次のようなコマンドで "ad" が展開
される心配はありません: >

	:edit ad


短縮形の削除
------------

短縮形を取り除くには ":unabbreviate" コマンドを使います。次のような短縮形が登
録されているなら: >

	:abbreviate @f fresh

次のコマンドで削除できます: >

	:unabbreviate @f

このコマンドを入力すると @f が "fresh" に展開されてしまいますが、心配はいりま
せん。コマンドは正しく処理されます (ただし、"fresh" という別の短縮形が定義され
ている場合は期待した動作になりません。まぁそんなことはほとんどないはずですが)。
すべての短縮形を削除するには次のコマンドを使います: >

	:abclear

":unabbreviate" と ":abclear" にも、挿入モード用 (":iunabbreviate" と
":iabclear") とコマンドライン用 (":cunabbreviate" と ":cabclear") があります。


短縮形の再マップ
----------------

短縮形を定義するときに注意すべき点がもう一つあります。展開された文字列がマップ
されないようにしなくてはなりません。例をあげましょう: >

	:abbreviate @a adder
	:imap dd disk-door

"@a" を入力すると "adisk-doorer"になってしまいます。これは意図した動作ではない
はずです。これを避けるには、":noreabbrev" コマンドを使います。":abbreviate" と
機能は同じですが、展開結果にマップが適用されません: >

	:noreabbrev @a adder

これで、展開結果がマップされなくなります。

==============================================================================
*24.8*	特殊な文字を入力する

CTRL-V コマンドを使うと、その次に入力した文字をそのまま挿入できます。つまり、
文字の特殊効果が無視されます。例えば、このように入力すると: >

	CTRL-V <Esc>
<
エスケープ文字が挿入されます。挿入モードは終了しません。(CTRL-V の後ろの空白は
見やすくするためのものなので、実際には入力しないでください)

	Note:
	MS-Windows では CTRL-V はテキストのペーストに使われています。CTRL-V の
	代わりに CTRL-Q を使ってください。Unixでは逆に一部の端末で CTRL-Q に特
	別な意味があるので使えないかもしれません。

また、CTRL-V {digits} コマンドを使うと、文字コードを 10 進数で指定して、その文
字を入力できます。例えば、文字コード 127 は <Del> 文字 (<Del> *キー*と同じとは
限りません) です。<Del> を挿入するには次のように入力します: >

	CTRL-V 127

同じやりかたで文字コード 255 までの文字を入力できます。文字コードが 2 桁以下の
場合は、数字以外の文字を入力してコマンドを確定してください。
数字以外の文字を入力したくない場合は、数値が 3 桁になるように 1 つか 2 つの
"0" を数値の前に付けてください。
次のコマンドはいずれも <Tab> と "." を挿入します:

	CTRL-V 9.
	CTRL-V 09.
	CTRL-V 009.

文字コードは 16 進数でも指定できます。その場合は CTRL-V の直後に "x" を指定し
ます: >

	CTRL-V x7f

この場合もコード 255 (CTRL-V xff) までの文字が入力できます。"o" で 8 進数の数
値を指定することもできます。他にも "u" と "U" でそれぞれ 16 ビットと 32 ビット
の文字コード (例えば Unicode の文字) を指定できます: >

	CTRL-V o123
	CTRL-V u1234
	CTRL-V U12345678

==============================================================================
*24.9*	二重字 (Digraph)

例えば、コピーライト文字 (©) など、キーボードに無い文字がいくつかあります。
そのような文字を Vim で入力するには二重字を使います。つまり、二文字で一文字を
表現します。例えば、コピーライト文字 (©) を入力するには、次のようにします: >

	CTRL-K Co

使用できる二重字の一覧を表示するには、次のコマンドを使います: >

	:digraphs

一部抜粋:

  AC ~_ 159  NS |  160  !I ¡  161  Ct ¢  162  Pd £  163  Cu ¤  164  Ye ¥  165 ~
  BB ¦  166  SE §  167  ': ¨  168  Co ©  169  -a ª  170  << «  171  NO ¬  172 ~
  -- ­  173  Rg ®  174  'm ¯  175  DG °  176  +- ±  177  2S ²  178  3S ³  179 ~

これを見れば、例えば CTRL-K Pd でポンド記号 (£) が入力できることがわかります。
文字番号は 163 (10進数) です。
Pd は Pound (ポンド) の略です。ほとんどの二重字には、生成される文字が連想しや
すい文字が割り当てられています。法則は表を見ればだいたいわかると思います。
二重字の一文字目と二文字目は逆の順番で入力しても構いません。ただし、その組み合
わせが他の二重字で使われていない場合に限ります。すなわち、CTRL-K dP もポンド記
号になります。"dP" という組み合わせが他に使われていないので、"Pd" の二重字が使
われるのです。

	Note:
	二重字はユーザーが使っている (と Vim が認識している) 文字セットに依存
	します。MS-DOS の文字セットと MS-Windows の文字セットは違います。
	":digraphs" を使って、利用可能な二重字を確認してください。

自分で二重字を定義することもできます。例: >

	:digraph a" ä

CTRL-K a" を入力すると ä になります。文字コードを 10 進数で指定することもでき
ます。次のコマンドは上記のコマンドと同じです: >

	:digraph a" 228

二重字についての詳細は |digraphs| を参照してください。
他にも、キーマップを使って特殊な文字を入力することもできます。詳しくは |45.5|
参照。

==============================================================================
*24.10*	ノーマルモードコマンド

挿入モードで使えるコマンドはそれほど多くありませんが、ノーマルモードにはたくさ
んのコマンドがあります。それらのコマンドを使うには <Esc> で挿入モードを抜けて、
ノーマルモードコマンドを実行し、"i" または "a" で挿入モードに戻ってこなければ
なりません。
もっと簡単な方法があります。CTRL-O {command} を使えばノーマルモードコマンドを
挿入モードの中で実行できます。例えば、次のコマンドでカーソル位置から行末まで削
除できます: >

	CTRL-O D

この方法で実行できるのは一つのコマンドだけです。ただし、レジスタやカウントの指
定はできます。もう少し複雑な例: >

	CTRL-O "g3dw

三つの単語を削除してレジスタ g に格納します。

==============================================================================

次章: |usr_25.txt|  テキストの整形

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
