*editing.txt*   For Vim バージョン 7.4.  Last change: 2013 Aug 03


		VIMリファレンスマニュアル    by Bram Moolenaar


ファイルの編集						*edit-files*

1.  はじめに			|edit-intro|
2.  ファイルの編集		|edit-a-file|
3.  引数リスト			|argument-list|
4.  書き込み			|writing|
5.  書き込みと終了		|write-quit|
6.  ダイアログ			|edit-dialogs|
7.  カレントディレクトリ	|current-directory|
8.  バイナリファイルの編集	|edit-binary|
9.  暗号化			|encryption|
10. タイムスタンプ		|timestamps|
11. ファイル検索		|file-searching|

==============================================================================
1. はじめに						*edit-intro*

「Vimでファイルを編集する」とは、以下のことを表す。

1. バッファへファイルを読み込む
2. 編集コマンドによりバッファの内容を変更する
3. バッファをファイルへ書き込む

							*current-file*
バッファを書き込まない限り、元のファイルは変更を受けないままで残っている。ファ
イルの編集を始めると (バッファにファイルを読み込むと)、そのファイルの名前は
「カレントファイル名」として記憶される。これをカレントバッファの名前とも呼ぶ。
コマンドラインでは "%" で表せる。|:_%|

							*alternate-file*
カレントファイル名が既に存在したときは、前の方は「オルタネートファイル名」にな
る。これはコマンドラインでは "#" で表され|:_#|、|CTRL-^|を使うとカレントファイル
とオルタネートファイルを切り替えることが出来る。ただし|:keepalt|を使ったときは
オルタネートファイル名は変わらない。

							*:keepalt* *:keepa*
:keepalt {cmd}		現在のオルタネートファイル名を変えずに{cmd}を実行する。
                        Note 間接的に呼び出されるコマンド(例えば関数によって)
                        はオルタネートファイル名を変えてしまう。{Vi にはない}

全てのファイル名はバッファリストに記憶される。編集 (例えば ":e filename") や保
存(例えば ":w filename") のためにファイル名を入力すると、そのファイル名がリス
トに追加される。このリストを使えば、どのファイルを編集したかを覚えておいたり、
コマンド CTRL-^ によってあるファイルから別のファイルへ素早く移行できる (例えば
テキストをコピーするとき)。まずファイルの番号を、次に CTRL-^ を打ち込む。{Vi:
オルタネートファイル名は1個だけ使える}

CTRL-G		または				*CTRL-G* *:f* *:fi* *:file*
:f[ile]			カレントファイル名 (これは ":cd" が使われたとき以外は
			打ち込まれた通り {訳注: 普通、カレントディレクトリの
			ファイルを編集するときはパスを省いて打ち込むと思うが、
			そうするとパスなしのファイル名になる})、カーソル位置
			(これはオプション 'ruler' がオフのとき) とファイルの状
			態 (読込専用、変更あり、読込エラー、新規ファイル) を表
			示する。このメッセージを短くする方法については、オプショ
			ン 'shortmess' を参照。{Vi では列番号が表示されない}

:f[ile]!		|:file|と同様だが、'shortmess' が設定されているときで
			も名前を切り詰めない。
			
{count}CTRL-G		CTRL-G と同様だが、カレントファイル名をフルパスで表示
			する。{count} が2以上なら、カレントバッファの番号も表
			示する。 {Vi にはない}

					*g_CTRL-G* *word-count* *byte-count*
g CTRL-G		カーソルの現在の位置を、列、行、単語、文字、バイト、の
			5種類の単位で表示する。文字数とバイト数が同じのときは
			文字位置が省略される。
			行の中に画面上で1文字分以上の幅を占める文字 (<Tab> ま
			たは特殊文字) があるときは、「実際」の列番号と画面上の
			列番号の両方が、ダッシュで区切られて表示される {訳注:
			例えば、タブ幅 'tabstop' が8のとき、行頭の <Tab> の次
			では「実際」の列番号は2、画面上の列番号は9となり、
			"1-8" と表示される}。オプション 'ruler' も参照。
			{Vi にはない}

							*v_g_CTRL-G*
{Visual}g CTRL-G	"g CTRL-G" と似ているが、単語、文字、行、バイトの項目
			はビジュアル選択領域内で数えられて表示される。矩形ビジュ
			アルモードでは、何列目かも表示される。
			矩形ビジュアルモードでは桁数も表示される({Visual}につ
			いては|Visual-mode| を参照)
			{Vi にはない}

							*:file_f*
:f[ile][!] {name}	カレントファイル名を {name} に設定する。!をつけると
			|:file|のようにメッセージを切り詰めなくなる。
			バッファが名前を持つならその名前がオルタネートファイル名
			|alternate-file|になる。元の名前を保持するためにリスト
			されない(unlisted)バッファが作成される。
							*:0file*
:0f[ile][!]		カレントバッファの名前を削除する。!をつけると|:file|の
			ようにメッセージを切り詰めなくなる。{Vi にはない}

:buffers
:files
:ls			現在認識しているファイル名を全て一覧表示する。
			|windows.txt| |:files| |:buffers| |:ls| を参照。
			{Vi にはない}

Vim は入力したファイル名のフルパス名を記憶している。ファイル名が表示されるとき、
大抵は打ち込んだ名前だけが表示されるが、コマンド |:cd| でディレクトリを移動し
た後では、フルパス名が使われる。

							*home-replace*
環境変数 $HOME が設定されていて、ファイル名がその文字列で始まっているならば、
ファイル名のその部分は "~" に置き換えられて表示される。これはファイル名を短く
するためである。ファイルを読み書きするときはフルパス名が使われ、"~" はファイル
名を表示するときだけ使われる。ファイル名の置き換えを行ったところ "~" だけになっ
てしまうときは、代わりに "~/" が使われる (オプション 'backupext' が "~" に設定
されたときに混乱を防ぐため)。

バッファを書き出すとき、既定ではカレントファイル名を用いる。そのため、コマンド
"ZZ" や ":wq" を使うと、元のファイルは上書きされてしまうことになる。これを望ま
ないならば、コマンド ":write" の引数にファイル名を与えることで、バッファを別の
ファイルに書き出せる。例: >

	vim テスト用 {訳注: これはシェルに対して}
	[コマンドでバッファを編集する]
	:w 新ファイル
	:q

こうすると "新ファイル" が生成されるが、これは "テスト用" を編集してコピーした
ものである。ファイル "テスト用" は変更されないまま残る。しかしどちらにしろ、オ
プション 'backup' がオンのときは、Vim は元のファイルを上書きする前に、元のファ
イルの名前を変更するかコピーする。元のファイルが必要なことに気付いたときは、こ
のファイルを使える。'patchmode' も参照。普通、バックアップファイルの名前は元の
ファイル名に 'backupext' を追加したものである。既定値は "~" という妙なものだが、
これはたまたま存在しているファイルに上書きするのを避けるためである。 ".bak" の
方がよければ、'backupext' を変更すること。MS-DOS 機等で、MS-DOS 系のファイルシ
ステム (例えば、messydos や crossdos ) が使われていることが検出されたときや、
'shortname' がオンのときには、余分なドットは '_' に置き換えられる。'backupdir'
を設定することで、バックアップファイルを他のディレクトリに置くことができる。

							*auto-shortname*
技術的情報: Amiga ではファイル名に 30 文字まで使える。しかし MS-DOS 互換のファ
	    イルシステムで有効なのは 8 文字＋ 3 文字に過ぎない。Vim は ".swp"
	    ファイルを生成するときにファイルシステムの判別を試みる。MS-DOS 系
	    のファイルシステムと思われるときは、'shortname' をオンにするのと同
	    じ効果を持つフラグがオンになる。このフラグは新ファイルの編集を開始
	    するとすぐにオフにされる。このフラグはカレントファイルのための
	    ".swp" ファイルと ".~" ファイルの名前を作るときに使われる。しかし、
	    ユーザーが普通のファイルシステムで編集作業を行い、MS-DOS 系のファ
	    イルシステムに保存するときには、フラグはオンにならない。そのとき
	    は、".~" ファイルの生成が失敗してエラーメッセージが表示される。そ
	    のときはオプション 'shortname' を使うこと。

ファイル名を指定せずに編集を始めたときは、メッセージ欄に "[無題]" と表示される。
コマンド ":write" がファイル名引数付きで使われたときは、そのファイル名がカレン
トファイルのファイル名に設定される。こうなるのはフラグ 'F' |cpo-F| がオプション
'cpoptions' に含まれているときだけである (既定では含まれている)。これは空のバッ
ファにテキストを入力してから、それをファイルに保存するときに便利である。
'cpoptions' が 'f' |cpo-f| を含んでいるときは (既定では含まれて「いない」)、
":read file" でファイル名が設定される。これは引数なしでVimを起動してから、
":read file" でファイルの編集を開始するときに便利である。
ファイル名が設定されていて 'filetype' が空のとき、ファイルタイプ判別オートコマ
ンドが発生する。
							*not-edited*
ファイル名が設定されるのはその名前のファイルの編集を本当に始めるより前なので、
そのファイルを誤って上書きしないようになっている。これはフラグ "notedited" を
設定することで可能になる。このフラグの状態はコマンド CTRL-G か ":file" で確認
できる。フラグ "notedited" がオンのときは "[Not edited]" と表示される。
カレントファイルの名前でバッファ内容を書き出すとき (":w!" で)、フラグ
"notedited" はオフに設定される。

							*abandon*
Vim はバッファが変更されたかどうかを記憶していて、変更点が誤って失われないよう
になっている。保存せずに終了しようとしたり、別のファイルの編集を開始しようとす
ると、Vim は拒否する。この保護を無効にするためには、コマンドに '!' を追加する
こと。その場合、変更は失われる。例えばバッファの内容が変更されているとき、":q"
は使えないが ":q!" は使える。バッファの内容が変更されたかどうかを見るためには
コマンド CTRL-G を使うこと。バッファが変更されていたときは、メッセージに文字列
"[変更あり]" が含まれる。

確認なしで変更を保存してほしいなら、オプション 'autowriteall' をオンにすること。
関連するオプションには 'autowrite' があるが、これは Vi 互換で、全てのコマンド
に対して動作するわけではない。

変更されたバッファを保存せずにそのままにしておきたいなら、オプション 'hidden'
をオンにすること。 |hidden-buffer| を参照。いくつかのコマンドは 'hidden' がオ
ンになっていなくてもこのように振る舞うので、コマンドについてはヘルプを参照。

==============================================================================
2. ファイルの編集					*edit-a-file*

							*:e* *:edit* *reload*
:e[dit] [++opt] [+cmd]	カレントファイルを開く。これは Vim 外部でカレントファ
			イルに変更が加えられたとき、開き直すのに便利である。
			カレントバッファに変更が加えられているのに、オプション
			'autowriteall' がオフであるか、ファイルが書き込み可能
			でないときは、実行に失敗する。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt は使えない}

							*:edit!* *discard*
:e[dit]! [++opt] [+cmd]
			どのような場合でもカレントファイルを開く。カレントバッ
			ファに対する変更は全て失われる。これは編集作業をもう一
			度最初からやり直したいときに便利である。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt は使えない}

							*:edit_f*
:e[dit] [++opt] [+cmd] {file}
			{file} を開く。
			カレントバッファに変更が加えられていると実行に失敗する。
			ただしオプション 'hidden' がオンであるときと、
			'autowriteall' がオンであり、かつファイルが書き込み可
			能なときには実行できる。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt は使えない}

			
:e[dit]! [++opt] [+cmd] {file}				*:edit!_f*
			どのような場合でも {file} を開く。カレントバッファに対
			する変更は全て失われる。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt は使えない}

:e[dit] [++opt] [+cmd] #[count]
			[count] 番目のバッファ (コマンド |:files| で表示される
			もの) を開く。このコマンドは [count] CTRL-^ と同じであ
			る。しかしオルタネートバッファがファイル名を持たないと
			":e #" は機能しないが、CTRL-^ はそのときも機能する。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt は使えない}

							*:ene* *:enew*
:ene[w]			無名のバッファの編集を新規に開始する。カレントバッファ
			に変更が加えられていると実行に失敗する。ただしオプショ
			ン 'hidden' がオンであるときと、'autowriteall' がオン
			であり、かつファイルが書き込み可能なときには実行できる。
			'fileformats' の値が空でないとき、その先頭の形式が新バッ
			ファに適用される。'fileformats' の値が空のときは、カレ
			ントバッファの 'fileformat' の値が使われる。
			{Vi にはない}

							*:ene!* *:enew!*
:ene[w]!		無名のバッファの編集を新規に開始する。カレントバッファ
			に対する変更は全て失われる。
			オプション 'fileformat' の値はコマンド |:enew| と同様
			に設定される。
			{Vi にはない}

							*:fin* *:find*
:fin[d][!] [++opt] [+cmd] {file}
			オプション 'path' 内のディレクトリから {file} を探し、
			それを |:edit| する。
			{Vi にはない} {Vimが |+file_in_path| 機能付きでコンパ
			イルされたときのみ有効}

:{count}fin[d][!] [++opt] [+cmd] {file}
			コマンド ":find" と同様だが、オプション 'path' 内のディ
			レクトリで {count} にマッチしたファイルを編集する。つ
			まり ":2find file" とすると 'path' 内で2番目に見つかっ
			た "file" を編集する。'path' 内で見つかったマッチが
			{count} より少ないと、エラーメッセージが表示される。

			
:ex [++opt] [+cmd] [file]				*:ex*
			:editと同じ。

							*:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [file]
			Ex モード内では: Ex モードからノーマルモードに戻る。そ
			れ以外はコマンド |:edit| と同じ。

							*:vie* *:view*
:vie[w][!] [++opt] [+cmd] file
			Ex モード内では: Ex モードからノーマルモードに戻る。そ
			れ以外はコマンド |:edit| と同じだが、そのバッファに対
			してオプション 'readonly' をオンにする。{Vi にはない}

							*CTRL-^* *CTRL-6*
CTRL-^			オルタネートファイルを編集する。たいていの場合、オルタ
			ネートファイルは前に編集したファイルである。これを使う
			と2つのファイル間を素早く切り替えることができる。これ
			は ":e #" と同じだが、対象のファイル名が無い場合も機能
			する。
			オプション 'autowrite' か 'autowriteall' がオンならば、
			バッファを移動するときに書き込みをする。
			たいていは "^" と "6" は同じキーである。CTRL を押しな
			がら 6 のキーを押せば CTRL-^ を押したのと同じ効果を得
			られる。しかし英語配列でないキーボードでは他のキーが割
			り当てられる。

[count]CTRL-^		[count] 番目のオルタネートファイルを編集する (コマンド
			":e #[count]" と同じ)。[count] が指定されないと、前に
			編集したファイルを編集する。これを使うと2つ (かそれ以
			上) のファイル間を素早く行き来できる。
			さらに詳しくは上の|CTRL-^|を参照。
			{Vi にはない}

[count]]f						*]f* *[f*
[count][f		コマンド "gf" と同じ。推奨されない。

							*gf* *E446* *E447*
[count]gf		カーソルの下か後ろの名前のファイルを編集する。
			覚え方: "goto file"。
			オプション 'isfname' により、どの文字がファイル名に使
			われるはずなのかを調べる。ファイル名に続く句読点の
			".,:;!" は無視される。
			'path' により、ファイルを探すディレクトリ名のリストを
			調べる。カレントファイルに対して相対的なファイルも探
			される。
			'suffixesadd' により、拡張子を補ったファイル名を調べる。
			ファイルが見つからないと、'includeexpr' によってファイ
			ル名を修正し、再びファイルを探す。
			[count] が指定されると、'path' 内で見つかった [count]
			番目のファイルを編集する。
			Vim がカレントファイルの破棄 |abandon| を拒否したとき
			は、このコマンドの実行は失敗する。
			このファイルを新しいウィンドウで編集したいときは
			|CTRL-W_CTRL-F| を使うこと。
			新しいファイルを編集したいならば、次のようにする。 >
				:e <cfile>
<			どのような場合でもコマンド gf を機能させるには、次のよ
			うにする。 >
				:map gf :e <cfile><CR>
<			カーソル下のファイル名が "type://machine/path" のよう
			なハイパーテキスト・リンクであるならば、プラグイン
			|netrw| が必要になる。
			Unixでは、文字 '~' は "~user/file" のように展開される。
			環境変数も展開される |expand-env|。
			{Vi にはない} {Vimが |+file_in_path| 機能付きでコンパ
			イルされたときのみ有効}

							*v_gf*
{Visual}[count]gf	コマンド "gf" と同様だが、編集するファイルの名前にはビ
			ジュアル選択されたテキストが使われる。オプション
			'isfname' の値は無視される。先頭の空白は無視されるが、
			それ以外の空白や特殊文字はファイル名に含まれる。
			({Visual} については |Visual-mode| を参照。)
			{Vi にはない}

							*gF*
[count]gF		"gf" と同じだが、ファイル名の後に番号があるとき、その
			行へカーソルが移動する点が異なる。ファイル名と行番号は
			ファイル名でない文字('isfname' を参照)かつ数字でない文
			字で区切られてなければならない。ファイル名、区切り文字、
			番号の間の空白文字は無視される。
			例:
				eval.c:10 ~
				eval.c @ 20 ~
				eval.c (30) ~
				eval.c 40 ~

							*v_gF*
{Visual}[count]gF	"v_gf" と同じ。

以上のコマンドは1つのファイルの編集を開始するために使用される。これはファイル
がバッファに読み込まれ、カレントファイル名が設定されることを意味する。開かれる
ファイルはカレントディレクトリに依存する。コマンド |:cd| を参照。

ファイルが読み込まれた後に表示されるメッセージの説明については、
|read-messages| を参照。

バッファ内がめちゃめちゃになって最初からもう1度やり直したいときには、コマンド
":e!" が使える。コマンド ":e" が便利なのは、カレントファイル名を変更したときだ
けである。

							*:filename* *{file}*
ファイル名を指定する場所で使える特殊なアイテムについては、この節に書かれている
ことの他に |cmdline-special| に書かれている。

Note Unix と MS-DOS 以外に対する注意: 1つのファイル名を受け付けるコマンド
(":edit file" 等) では、ファイル名に空白が入っていても構わないが、ファイル名末
尾の空白は無視される。これは、空白を含むファイル名が普通にあるシステム
(MS-Windows, Amiga等) では便利である。例: ":e   Long File Name " を実行すると、
ファイル "Long File Name" を開く。2つ以上のファイル名を受け付けるコマンド
(":next file1 file2" 等) では、ファイル名内の空白は '\' でエスケープしなければ
ならない。

						*wildcard* *wildcards*
{file} 内のワイルドカードは展開される。ただし、ファイル名補完と同様に
'wildignore' と 'suffixes' が適用される。使用できるワイルドカードの種類はシス
テムによって異なる。以下は標準的なものである。
	?	あらゆる1文字にマッチ
	*	何もないのも含め、全てにマッチ
	**	何もないのも含め、全てにマッチ。ディレクトリを再帰的にたどる。
	[abc]	'a', 'b' または 'c' にマッチ
ワイルドカードとしての特別な意味を無効にするには、前に '\' を置くこと。しかし
MS-Windowsでは '\' がパスの区切り文字なので、オプション 'isfname' の値に "["
が含まれていると、"path\[abc]" はワイルドカード扱いになってしまう。これを避け
る単純な方法は、"path\[[]abc]" とすることである。すると文字通りのファイル
"path[abc]" を編集できる。

					*starstar-wildcard*
"**" の展開は、Unix, Win32, Mac OS/X、その他数種類のシステムでのみ使用できる。
"**" はディレクトリツリーを再帰的に検索する。深さの上限は100ディレクトリである。
Note: いくつかのコマンドでは、この挙動が少し異なる。|file-searching| を参照。
例: >
	:n **/*.txt
これは次のファイルにマッチする:
	ttt.txt
	subdir/ttt.txt
	a/b/c/d/ttt.txt
ワイルドカードでない文字を使うと、それらは最初のディレクトリにのみマッチする。
例: >
	:n /usr/inc**/*.h
これは次のファイルにマッチする:
	/usr/include/types.h
	/usr/include/sys/types.h
	/usr/inc_old/types.h
					*backtick-expansion* *`-expansion*
Unix などではファイル名にバッククォート '`' も使える。例: >
	:e `find . -name ver\\*.c -print`
アスタリスク '*' の前の '\' は、シェルが find を実行する前に "ver*.c" を展開し
てしまうのを防ぐために必要となる。
これは、必ず項目全体がバッククォートで括られているという制限付きで、他の多くの
システムでも機能する。最初のバッククォートの直前や最後のバッククォートの直後に
文字列を書くことはできない。

							*`=*
バッククォート内を、外部コマンドとしてではなく Vim の式として展開させることも
できる。そのためには `={expr}` という構文を使えばよい。例: >
	:e `=tempname()`
この式はほとんど何を含んでもよい。そのため、これを使って '"', '|', '%', '#' の
特別な意味を打ち消すこともできる。ただし、他のワイルドカードと同様に
'wildignore' は適用される。
式が文字列を返したときは名前は改行で区切られる。式の結果がリスト (|List|) のと
きは各要素が名前として扱われる。改行によっても名前は区切られる。

							*++opt* *[++opt]*
引数のうち [++opt] はオプション 'fileformat', 'fileencoding' または
'binary' の値を、そのコマンドに限ってある値に指定し、不正な文字への対応を指定
するために使われる。指定の形式は次の通り。  >
	++{optname}
または >
	++{optname}={value}

{optname} は次のうちのどれか:	    *++ff* *++enc* *++bin* *++nobin* *++edit*
    ff  または  fileformat	'fileformat'	を指定
    enc  または  encoding	'fileencoding'	を指定
    bin または binary		'binary'	を指定
    nobin または nobinary	'binary'	を無効にする
    bad				不正な文字への対応を指定する
    edit			|:read| 用。ファイルを編集するときと同じように
				オプションの値を保つ。

{value} に空白を含めてはいけない。値は、そのオプションに対して適切なものなら何
でもよい。例: >
	:e ++ff=unix
こうすると 'fileformat' を "unix" に設定して同じファイルを編集し直す。 >

	:w ++enc=latin1 newfile
こうするとカレントバッファの内容を latin1 の文字コードで "newfile" に書き出す。

引数 [++opt] は空白で区切って複数指定してもよい。それらはみな引数 |+cmd| より
前に指定しなければならない。

								*++bad*
"++bad=" の引数は、変換できない文字と不正なバイトをどうするかを指定する。とり
うる値は次の3つのうちどれかである: 
    ++bad=X      不正な文字をこの1バイト文字で置き換える。
    ++bad=keep   不正な文字を変換せずにそのままにしておく。Note これを使うとテ
		 キスト中に不正なバイトが現れることになる。
    ++bad=drop   不正な文字を削除する。

既定値は "++bad=?" となっている。つまり、不正な文字をそれぞれクエスチョンマー
クで置き換える。逆クエスチョンマーク(latin-1 の 0xBF)が使われる場所もある。

Note ++bad をつけてエラーにならなかったとしても、すべてのコマンドが ++bad に対
応しているわけではない。

Note 読み込み時に上の方法で 'fileformat' と 'fileencoding' を指定すると、それ
らは以後その値に設定されることに注意。書き込み時に設定してもそうはならず、次に
書き込むときには以前の値が使われる。'binary' オプションも同様。

							*+cmd* *[+cmd]*
引数 [+cmd] は、新しく開いたファイルでカーソルの位置を指定したり、他のあらゆる
コマンドを実行するために使われる:
	+		最後の行で編集を開始する。
	+{num}		{num} 行目で編集を開始する。
	+/{pat}		{pat} を含んだ最初の行で編集を開始する。
	+{command}	新しいファイルを開いた後に {command} を実行する。
			{command} には任意の Ex コマンドが使える。
{pat} や {command} に空白を含めるためには、その前に '\' を付ける。'\' そのもの
を使うには、2回ずつ繰り返すこと。 >
	:edit  +/The\ book           ファイル
	:edit  +/dir\ dirname\\      ファイル
	:edit  +set\ dir=c:\\\\temp  ファイル
Note 最後の例では '\' の繰り返しが2回行われていることに注意。"+cmd" の引数なの
で1回、コマンド ":set" のためにもう1回だ。

							*file-formats*
オプション 'fileformat' はファイルに対して <EOL> の形式を設定する。
'fileformat'    <EOL>の文字	      形式の名称 ~
  "dos"		<CR><NL> または <NL>  DOS形式		*DOS-format*
  "unix"	<NL>		      Unix形式		*Unix-format*
  "mac"		<CR>		      Mac形式		*Mac-format*
以前はオプション 'textmode' が使われていた。現在ではそれは時代遅れである。

ファイルを読み込むときに、上で述べた文字は <EOL> として解釈される。DOS 形式
(MS-DOS、OS/2 と Win32 での既定値) では、<CR><NL> と <NL> の両方が <EOL> と解
釈される。 Note DOS 形式でファイルを保存するときには、<NL> 1 個ごとに対して
<CR> が追加されることに注意。|file-read| も参照。

ファイルを書き込むときには、上で述べた文字が <EOL> として使われる。DOS形式では
<CR><NL> が使われる。|DOS-format-write| も参照。

DOS 形式でファイルを読み込んで、Unix 形式でそれを保存することも可能である。
('fileformats' が "dos" を含んでいると仮定すると) 以下の操作は全ての <CR><NL>
を <NL> で置き換えることになる。 >
	:e ファイル
	:set fileformat=unix
	:w
('fileformats' の値に "unix" が含まれているとき) Unix形式でファイルを読み込ん
で、DOS形式で保存すると、<NL> は全て <CR><NL> で置き換えられる。 >
	:e ファイル
	:set fileformat=dos
	:w

新しいファイルの編集を開始したときオプション 'fileformats' の値が空でないなら
ば(それがデフォルト)、Vim はファイルが指定された形式で改行されているかどうか検
出を試みる。値が "unix,dos" であるときは、Vim は1個の <NL> (Unix と Amiga 形
式)か <CR><NL> の組 (MS-DOS 形式) が使われるものとして行を調べる。全ての行が
<CR><NL> で終わっているときだけ、'fileformat' の値は "dos" に設定され、そうで
なければ "unix" に設定される。'fileformats' の値が "mac" を含んでいて、ファイ
ルに <NL> が1個も見つからないときは、'fileformat' の値は "mac" に設定される。

'fileformat' の値が MS-DOS 以外のシステム上で "dos" に設定されると、普通でない
ことが起きていることを気付かせるために、メッセージ "[dosフォーマット]" が表示
される。'fileformat' の値が "unix" であると、MS-DOSシステムでは
"[unixフォーマット]" のメッセージが表示される。'fileformat' の値が "mac" であ
ると、Macintosh以外の全てのシステムでは、メッセージ "[macフォーマット]" が表示
される。

オプション 'fileformats' の値が空で、DOS 形式が使用されているが、ファイルを読
み込んでいるときにいくつかの行が <CR><NL> で終わっていなかったならば、ファイル
のメッセージ内に "[CR無]" が含まれる。
'fileformats' の値が空で、Mac 形式が使用されているが、ファイルを読み込んでいる
ときに <NL> が見つかったならば、ファイルのメッセージ内に "[NL無]" が含まれる。

新しいファイルが存在しないと、'fileformats' の値が空のときにはカレントバッファ
の 'fileformat' の値が使われる。そうでなければ、'fileformats' 内の1番目の形式
が新しいファイルに対して用いられる。

実行可能ファイルやバイナリファイル、Vim スクリプトファイルを編集する前には、
オプション 'binary' をオンに設定するべきだ。これにはオプション "-b" を付けて
Vimを起動するのが簡単である。こうすると 'fileformat' が使われなくなる。こうし
ないと1個の <NL> が不意に <CR><NL> で置き換えられてしまうことを覚悟しなければ
ならない。

オプション 'key' をオンに設定することで、保存されるファイルを暗号化できる。こ
れは他人がユーザーのファイルを読むことに対して、ある程度の安全を保証する。
|encryption|

==============================================================================
3. 引数リスト					*argument-list* *arglist*

Vim の開始時に複数のファイル名を与えると、それらは引数リストとして記憶される。
リスト内のファイルにはどれでも移動できる。

これをコマンド |:buffers| で表示されるバッファリストと混同してはいけない。引数
リストは Vi から既にあったが、バッファリストは Vim で新たに導入された。引数リ
スト内のファイルはバッファリストにも含まれる (コマンド |:bdel| や |:bwipe| で
消去されない限り)。逆にバッファリスト内のファイルが引数リストに含まれないこと
は普通にある。

この話題はユーザーマニュアルの第 |07.2| 章で紹介されている。

グローバルな引数リストが1個あり、これは既定では全てのウィンドウに使われる。ウィ
ンドウについてローカルな引数リストを新たに創ることもできる。|:arglocal| を参照。

引数リストは以下のコマンド及び expression 用関数 |argc()| と |argv()| で利用で
きる。これらはみなカレントウィンドウの引数リストに対して働く。

							*:ar* *:args*
:ar[gs]			引数リストを表示する。カレントファイルは '[' ']' で挟
			まれて表示される。

:ar[gs] [++opt] [+cmd] {arglist}			*:args_f*
			{arglist} を新たな引数リストとして定義し、そのうち最初
			のファイルの編集を始める。変更点があり、Vimがカレント
			バッファを放棄 |abandon| したくないときには失敗する。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt はない}

:ar[gs]! [++opt] [+cmd] {arglist}			*:args_f!*
			{arglist} を新たな引数リストとして定義し、そのうち最初
			のファイルの編集を始める。カレントバッファに対する変更
			点は全て失われる。
			|++opt| と |+cmd| も参照。
			{Vi: ++opt はない}

:[count]arge[dit][!] [++opt] [+cmd] {name}		*:arge* *:argedit*
			引数リストに {name} を追加し、その編集を始める。
			{name} が既に引数リスト内にあるときは、その編集を始め
			る。
			これはコマンド |:argadd| を使い、次に |:edit| を使うの
			と同じである。
			Note 指定できるファイルは1個であり、|:edit| と同様ファ
			イル名の中に空白が使えることに注意。[count] は
			|:argadd| と同様に使われる。
			カレントファイルが放棄 |abandon| できないときは '!' が
			必要になる。
			|++opt| と |+cmd| も参照。
			{Vi にはない}

:[count]arga[dd] {name} ..				*:arga* *:argadd*
			引数リストに {name} を追加する。
			[count] が省かれると {name} は引数リストの現在の項目の
			次に挿入される。指定されると [count] 番目の項目の次に
			挿入される。引数リストが "a b c" で "b" が現在の引数の
			場合のコマンドの結果一覧:
				コマンド	新たな引数リスト ~
				:argadd x	a b x c
				:0argadd x	x a b c
				:1argadd x	a x b c
				:99argadd x	a b c x
			重複検査はないので、1個のファイルを引数リストに2回加え
			ることもできる。
			現在編集中のファイルは変更されない。
			{Vi にはない} {Vimが |+listcmds| 機能付きでコンパイル
			されたときのみ有効}
			Note 次の方法が使えることに注意。 >
				:args ## x
<			これは項目 "x" を追加し、新たなリストを並び替える。

:argd[elete] {pattern} ..			*:argd* *:argdelete* *E480*
			{pattern} にマッチするファイルを引数リストから削除する。
			{pattern} の意味はファイルパターンと同様なので、
			|file-pattern| を参照。現在の項目を削除するには "%" が
			使える。
			このコマンドは現在編集中のファイルが引数リストから削除
			されたときでも、それをそのままに保つ。
			例: >
				:argdel *.obj
<			{Vi にはない} {Vimが |+listcmds| 機能付きでコンパイル
			されたときのみ有効}

:{range}argd[elete]	引数リストから {range} の範囲のファイルを削除する。
			範囲の上限が大きすぎるときは、最後の引数までが削除され
			る。例: >
				:10,1000argdel
<			とすると10以降が削除され、1から9は残る。
			{Vi にはない} {Vimが |+listcmds| 機能付きでコンパイル
			されたときのみ有効}

							*:argu* *:argument*
:[count]argu[ment] [count] [++opt] [+cmd]
			引数リスト内で [count] 番目のファイルを編集する。
			[count] が省かれると現在の項目を編集する。変更点があり、
			Vimがカレントバッファを放棄 |abandon| したくないときに
			は失敗する。
			|++opt| と |+cmd| も参照。
			{Vi にはない} {Vimが |+listcmds| 機能付きでコンパイル
			されたときのみ有効}

:[count]argu[ment]! [count] [++opt] [+cmd]
			引数リスト内で [count] 番目のファイルを編集する。カレ
			ントバッファに対するいかなる変更も失われる。[count] が
			省かれると現在の項目を編集する。
			|++opt| と |+cmd| も参照。
			{Vi にはない} {Vimが |+listcmds| 機能付きでコンパイル
			されたときのみ有効}

:[count]n[ext] [++opt] [+cmd]			*:n* *:ne* *:next* *E165* *E163*
			引数リストの中で [count] 個次のファイルを編集する。
			変更点があり、Vimがカレントバッファを放棄 |abandon| し
			たくないときには失敗する。
			|++opt| と |+cmd| も参照。 {Vi: count や ++opt はない}

:[count]n[ext]! [++opt] [+cmd]
			引数リストの中で [count] 個次のファイルを編集する。カ
			レントバッファに対するいかなる変更も失われる。
			|++opt| と |+cmd| も参照。
			{Vi: count や ++opt はない}

:n[ext] [++opt] [+cmd] {arglist}			*:next_f*
			コマンド |:args_f| と同じ。

:n[ext]! [++opt] [+cmd] {arglist}
			コマンド |:args_f!| と同じ。

:[count]N[ext] [count] [++opt] [+cmd]			*:Next* *:N* *E164*
			引数リストの中で [count] 個前のファイルを編集する。変
			更点があり、Vimがカレントバッファを破棄 |abandon| した
			くないときには失敗する。
			|++opt| と |+cmd| も参照。 {Vi: count や ++opt はない}

:[count]N[ext]! [count] [++opt] [+cmd]
			引数リスト内で [count] 個前のファイルを編集する。カレ
			ントバッファに対するいかなる変更も失われる。
			|++opt| と |+cmd| も参照。 {Vi: count や ++opt はない}

:[count]prev[ious] [count] [++opt] [+cmd]		*:prev* *:previous*
			コマンド |:Next| と同じ。
			|++opt| と |+cmd| も参照。 {Vi: 幾つかのバージョンにの
			み存在}

							*:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			引数リスト内で最初のファイルの編集を始める。変更点があ
			り、Vimがカレントバッファを放棄 |abandon| したくないと
			きには失敗する。
			|++opt| と |+cmd| も参照。 {Vi: ++opt はない}

:rew[ind]! [++opt] [+cmd]
			引数リスト内で最初のファイルを編集する。カレントバッ
			ファに対するいかなる変更も失われる。
			|++opt| と |+cmd| も参照。 {Vi: ++opt はない}

							*:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			コマンド |:rewind| の別名。 {Vi にはない}

							*:la* *:last*
:la[st] [++opt] [+cmd]
			引数リスト内で最後のファイルの編集を始める。変更点があ
			り、Vimがカレントバッファを放棄 |abandon| したくないと
			きには失敗する。
			|++opt| と |+cmd| も参照。  {Vi にはない}

:la[st]! [++opt] [+cmd]
			引数リスト内で最初のファイルを編集する。カレントバッ
			ファに対するいかなる変更も失われる。
			|++opt| と |+cmd| も参照。  {Vi にはない}

							*:wn* *:wnext*
:[count]wn[ext] [++opt]
			カレントファイルを書き込み、引数リスト内で [count] 個
			次のファイルの編集を始める。
			|++opt| と |+cmd| も参照。 {Vi にはない}

:[count]wn[ext] [++opt] {file}
			カレントファイルを {file} に書き込み、引数リスト内で
			[count] 個次のファイルの編集を始める。ただし {file} が
			既に存在し、オプション 'writeany' がオフのときは失敗す
			る。
			|++opt| と |+cmd| も参照。 {Vi にはない}

:[count]wn[ext]! [++opt] {file}
			カレントファイルを {file} に書き込み、引数リスト内で
			[count] 個次のファイルの編集を始める。
			|++opt| と |+cmd| も参照。 {Vi にはない}

:[count]wN[ext][!] [++opt] [file]		*:wN* *:wNext*
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			コマンド |:wnext| と同じだが、次でなく前のファイルに移
			る。 {Vi にはない}

上のコマンドの [count] の既定値は1である。[count] を2回使えるコマンドもある。
最後 (最も右) のものが使われる。

引数 [+cmd] が存在しないならば、カーソルはそのファイルに対して最後に認識された
位置に置かれる。オプション 'startofline' がオンのときは、カーソルは行の最初の
非空白文字に置かれ、オフのときは最後に認識された列が使われる。最後に認識された
カーソル位置がないときは、カーソルは最初の行 (Exモードでは最後の行) に置かれる。

							*{arglist}*
引数リスト内のワイルドカードは展開され、ファイル名は並び替えられる。だからCの
ソースファイルを全て編集するには、コマンド "vim *.c" が使える。 Vimの中でコマ
ンド ":n *.c" としても同じである。

ファイル名は空白文字によって区切られる。ファイル名にスペースまたはタブを含める
には、その前にバックスラッシュを書くこと。例えば、"foo bar" という1つのファイ
ルを開くにはこうする: >
	:next foo\ bar

Unix およびその他いくつかのシステムではバッククォートも使える。例: >
	:n `find . -name \\*.c -print`
アスタリスクの前の '\' は、"*.c" がプログラム find を実行する前にシェルで展開
されるのを防ぐために必要となる。

							*arglist-position*
引数リストがあるときは、ウィンドウのタイトル (それがあって、オプション 'title'
オンならば) やコマンド CTRL-G で出るファイル・メッセージで編集しているファイル
を知ることができる。次のようなものが表示されるだろう。
	(file 4 of 11)
オプション 'shortmess' の値が 'f' を含んでいるときは以下のようになる。
	(4 of 11)
実際は引数リスト内の現在の位置でないファイルを編集しているならば、以下のように
なる。
	(file (4) of 11)
これは、引数リストの中の4番目にいるが、編集中のファイルは引数リストの中の4番目
でないことを意味する。これは ":e file" をするときに起こる。


ローカルな引数リスト

{Vi にはない}
{Vimが |+windows| 機能と |+listcmds| 機能付きでコンパイルされたときのみ有効}

							*:arglocal*
:argl[ocal]		グローバルな引数リストのローカルなコピーを作る。
			別のファイルの編集は始めない。

:argl[ocal][!] [++opt] [+cmd] {arglist}
			カレントウィンドウについてローカルな、新たな引数リスト
			を定義する。
			ウィンドウが1個のときは |:args_f| と同じである。

							*:argglobal*
:argg[lobal]		カレントウィンドウにグローバルな引数リストを使う。
			別のファイルの編集は始めない。

:argg[lobal][!] [++opt] [+cmd] {arglist}
			カレントウィンドウにグローバルな引数リストを使う。
			コマンド |:args_f| と同様、グローバルな引数リストを新
			たに定義する。グローバルな引数リストを使っているウィン
			ドウは全てこの新しいリストを参照するようになる。

複数の引数リストが存在可能であり、それらはウィンドウ同士で共有できる。共有され
ているときは、あるウィンドウ内で引数リストに変更を加えると、別のウィンドウの引
数リストも影響を受ける。

ウィンドウが分割されると、新しいウィンドウはカレントウィンドウから引数リストを
受け継ぐ。すると2個のウィンドウは、片方でコマンド |:arglocal| か |:argglobal|
を使って別の引数リストを使うようになるまで、そのリストを共有することになる。


引数リストを使う

						*:argdo*
:argdo[!] {cmd}		引数リスト内の全てのファイルで {cmd} を実行する。
			以下と同様の動作になる。 >
				:rewind
				:{cmd}
				:next
				:{cmd}
				etc.
<			カレントファイルを放棄 |abandon| できず、'!' も付けら
			れていないときは、実行は失敗する。どれかのファイル内で
			エラーが検出されると、引数リスト内の以降のファイルには
			進まない。
			引数リスト末尾のファイル (またはエラーの起きたファイル)
			がカレントファイルになる。
			{cmd} の中では '|' で複数のコマンドを連結できる。
			{cmd} は引数リストに変更を加えてはならない。
			Note: このコマンドの実行中、オプション 'eventignore'
			でオートコマンドのイベント Syntax を指定することでそれ
			を無効化できる。こうすると各ファイルの処理がかなり高速
			になる。
			{Vi にはない} {Vimが |+listcmds| 機能付きでコンパイル
			されたときのみ有効}
			コマンド |:windo| や |:bufdo| も参照。

例: >
	:args *.c
	:argdo set ff=unix | update
こうするとオプション 'fileformat' の値を "unix" に設定し、変更があったファイル
を保存する。それが全ての *.c ファイルについて行われる。

例: >
	:args *.[ch]
	:argdo %s/\<my_foo\>/My_Foo/ge | update
こうすると全ての *.c ファイルと *.h ファイルで単語 "my_foo" を "My_Foo" に変え
る。コマンド ":substitute" でフラグ "e" を使って "my_foo" という単語の使われて
いないファイルでエラーが起きるのを防いでいる。コマンド ":update" は変更のあっ
たファイルのみを保存する。

==============================================================================
4. 書き込み					*writing* *save-file*

Note: オプション 'write' がオフのときは、どのファイルも書き込めないことに注意。

							*:w* *:write*
						*E502* *E503* *E504* *E505*
						*E512* *E514* *E667* *E796*
:w[rite] [++opt]	バッファ全体をカレントファイルに書き込む。これはファイ
			ルに対する変更点を保存するときの普通の方法である。
			オプション 'readonly' がオンであるかファイルに書き込め
			ない理由が何かあるときには実行に失敗する。

:w[rite]! [++opt]	":write" と似ているが、'readonly' がオンであったり書き
			込みが拒否される理由があっても無理矢理書き込みを行う。
			Note: これはファイルの権限や所属を変更したり、(シンボ
			リック) リンクを途切れさせるかもしれないので注意。それ
			を避けるには 'cpoptions' にフラグ 'W' を追加すること。

:[range]w[rite][!] [++opt]
			指定された範囲の行をカレントファイルに書き出す。これは
			普通の操作ではない。ファイルがバッファ内の全ての行を
			含むようにならないからだ。

							*:w_f* *:write_f*
:[range]w[rite]	{file}	指定された範囲の行をファイル {file} に書き出す。ただし
			それが既に存在し、かつオプション 'writeany' がオフのと
			きは失敗する。

							*:w!*
:[range]w[rite]! [++opt] {file}
			指定された範囲の行をファイル {file} に書き出す。既存の
			ファイルは上書きされる。

						*:w_a* *:write_a* *E494*
:[range]w[rite][!] [++opt] >>	
			指定された範囲の行をカレントファイルに追加する。

:[range]w[rite][!] [++opt] >> {file}
			指定された範囲の行をファイル {file} に追加する。'!' を
			付けるとそのファイルがまだ存在しなくても書き込みを行う。

							*:w_c* *:write_c*
:[range]w[rite] [++opt] !{cmd}
			[range] の行を標準入力として {cmd} を実行する ('!' の
			前の空白に注意)。{cmd} は ":!{cmd}" のように実行され、
			全ての '!' は前回のコマンドに置き換えられる |:!|。

コマンド ":w" での [range] の既定値はバッファ全体 (1,$) である。バッファ全体を
書き込むと、そのバッファは変更されていないとみなされるようになる。
":w somefile" によって別のファイルに書き出した場合は、'cpoptions' の "+" フラ
グに依存する。"+" が含まれている場合は、バッファがまだ元のファイルと異なってい
たとしても、書き込みコマンドによって 'modified' フラグがオフになる。

":w" にファイル名が与えられるとそれがオルタネートファイルになる。これは例えば
書き込みに失敗した後に ":w #" でもう一度試したいときに使える。オプション
'cpoptions' からフラグ 'A' を取り除くとこれを無効化できる。

							*:sav* *:saveas*
:sav[eas][!] [++opt] {file}
			カレントファイルをファイル名 {file} として保存し、カレ
			ントバッファのファイル名を {file} に変える。それまでの
			カレントファイルの名前はオルタネートファイルの名前にな
			る。既存のファイルを上書きするには [!] が必要になる。
			'filetype' が空の場合、保存の前に新しいファイル名に対
			してファイルタイプ検出が行われる。
			保存が成功すると 'readonly' がオフになる。
			{Vi にはない}

							*:up* *:update*
:[range]up[date][!] [++opt] [>>] [file]
			":write" と似ているが、バッファに変更点があるときのみ
			書き込みを行う。 {Vi にはない}


複数バッファでの書き込み				*buffer-write*

							*:wa* *:wall*
:wa[ll]			変更点のあるバッファを全て書き込む。ファイル名を持たな
			いバッファや読み込み専用のバッファは書き込まれない。
			{Vi にはない}

:wa[ll]!		変更点のあるバッファを、読み込み専用であっても全て書き
			込む。ファイル名を持たないバッファは書き込まれない。
			{Vi にはない}


Vimは別の場所で変更を受けたファイルを上書きしようとしたときには警告する。
|timestamp| を参照。

			    *backup* *E207* *E506* *E507* *E508* *E509* *E510*
オプション 'backup', 'writebackup' または 'patchmode' がオンのときに既存のファ
イルに (追加でなく) 書き込もうとすると、元のファイルのバックアップが作られる。
ファイルは元のコピーかリネームしたものである ('backupcopy' を参照)。ファイルの
書き込みに成功したとき 'writebackup' がオンで 'backup' がオフだと、バックアッ
プファイルは削除される。'patchmode' がオンのときはバックアップファイルはリネー
ムされるかも知れない。

							*backup-table*
'backup' 'writebackup'	動作	~
   off	     off	バックアップは作られない
   off	     on		カレントファイルをバックアップし、後で消去する (既定)
   on	     off	古いバックアップを消去し、カレントファイルをバックアッ
			プする
   on	     on		古いバックアップを消去し、カレントファイルをバックアッ
			プする

'backupskip' に指定したパターンが書き込まれるファイルの名前にマッチしたときは、
バックアップファイルは作られない。その場合 'backup' と 'writebackup' の値は無
視される。

'backup' がオンのときは、古いバックアップファイル (新しいバックアップファイル
と同名) は削除される。'backup' がオフだが 'writebackup' がオンのときは、既存の
バックアップファイルは削除されない。ファイルの書き込み中に作られたバックアップ
ファイルは別の名前になる。

ファイルシステムによってはクラッシュで新しいファイルとバックアップを両方失うこ
ともあり得る (新しいファイルは存在はしても中身が滅茶苦茶になっていたり)。その
場合は復帰機能を試すこと。スワップファイルがまだディスクに残っているかもしれな
いからだ。 |:recover|

オプション 'backupdir' で指定されたディレクトリはバックアップファイルをしまう
のに使われる。 (既定値: 書き込まれたファイルと同じディレクトリ)

バックアップが、元のファイルのコピーである新規のファイルになるか、元のファイル
がリネームされたものになるかは、オプション 'backupcopy' で決まる。コピーが作ら
れるのがいつでファイルがリネームされるのがいつかについてはその箇所を参照。

バックアップファイルの生成に失敗すると、書き込みは行われない。それでも書き込み
たいときにはコマンドに '!' を追加すること。

							*write-permissions*
新しいファイルを書き込むときは読み書きの権限が付く。unix ではマスクの値は 0666
に umask を適用させたものになる。Vim で開いたファイルに書き込むときは権限は維
持されるが、s ビットはクリアされる。

							*write-readonly*
オプション 'cpoptions' の値にフラグ 'W' が含まれるときは、Vimは読み込み専用
ファイルの上書きを拒否する。'W' が含まれないと、システムが許可すれば (ディレク
トリは書き込み可能でなければならない) ":w!" は読込専用ファイルを上書きする。

							*write-fail*
新ファイルの書き込みに失敗したときは、変更点と元のファイルを同時に失わないよう
注意しなければならない。バックアップファイルがないときに書き込みに失敗すると、
その時点で元のファイルはなくなっているのだ！ファイルを書き出すまでVIMを終了し
てはいけない！バックアップが作られていたら、それが元のファイルの所に戻される 
(可能ならば)。Vimを終了して変更点が失われても、大抵は元のファイルはそこに残っ
ている。Vimが元のファイルを戻すのに失敗すると、元のファイルが失われた旨のエ
ラーメッセージが出る。

						*DOS-format-write*
オプション 'fileformat' の値が "dos" のときは、<EOL> には <CR> <NL> が使われ
る。これは MS-DOS, Win32とOS/2での既定値である。その他のシステムでは
"[dos format]" というメッセージが表示され、普通でない <EOL> が使われていること
を知らせてくれる。
						*Unix-format-write*
'fileformat' の値が "unix" のときは、<EOL> には <NL> が使われる。MS-DOS, Win32
とOS/2では "[unix format]" というメッセージが表示される。
						*Mac-format-write*
'fileformat' の値が "mac" のときは、<EOL> には <CR> が使われる。Mac以外のシス
テムでは "[mac format]" というメッセージが表示される。

|file-formats| やオプション 'fileformat' 及び 'fileformats' も参照。

						*ACL*
ACLは Access Control List を表す。これはファイルのアクセス権を制御するための先
進的な手段である。新しいMS-WindowsとUnixシステムで使われるが、ファイルシステム
がそれをサポートするときのみである。
Vimはファイルを書き込むときにACL情報を保とうとする。バックアップファイルは元の
ファイルのACL情報を受け継ぐ。
ACL情報は (ファイルを開くときに) ファイルが読込専用かどうか調べるのにも使われ
る。

						*read-only-share*
MS-Windowsがネットワーク上でドライブを共有するとき、そこは読込専用にすることが
できる。つまりファイルに読込専用の属性がなく、NCネットワーク共有ドライブ上の
ACL設定が書き込みを許可していても、そのファイルには書き込みができない。Win32プ
ラットフォーム上のVimは読込専用のネットワークドライブを判別し、ファイルを読込
専用とマークする。そのファイルは |:write| で上書きできない。

						*write-device*
ファイル名が実際はデバイス名のとき、Vimはバックアップを作ろうとはしない (無理
な話だ)。デバイスは既に存在するので、保存にはフラグ "!" が必要である。
Unixでの例: >
	:w! /dev/lpt0
MS-DOSやMS-Windowsでの例: >
	:w! lpt0
Unixでは、ファイル名が通常ファイルやディレクトリを指していないときにデバイスと
判断される。VimはFifo及び名前付きパイプもデバイスと判断する。
MS-DOSとMS-Windowsでは、デバイスは名前から判断される:
	AUX
	CON
	CLOCK$
	NUL
	PRN
	COMn	n=1,2,3... 等
	LPTn	n=1,2,3... 等
ファイル名は大文字でも小文字でもよい。

==============================================================================
5. 書き込みと終了					*write-quit*

							*:q* *:quit*
:q[uit]			カレントウィンドウを閉じる。最後のウィンドウで使うとを
			Vimを終了させる。変更点があってVimがカレントバッファを
			放棄 |abandon| しようとしないときや、引数リスト内で末
			尾にないファイルを編集しているときには失敗する。
			他のタブページが存在するとき、カレントタブページ内の最
			後のウィンドウを閉じるとカレントタブページが閉じられる。
			|tab-page|
			|QuitPre| オートコマンドイベントが発行される。

:conf[irm] q[uit]	終了だが、変更点があるときや、引数リスト内で末尾にない
			ファイルを編集しているときにはプロンプトを表示する。
			コマンド |:confirm| やオプション 'confirm' を参照。
			{Vi にはない}

:q[uit]!		可視なバッファに変更点があっても書き込みをせずに終了す
			る。隠れバッファに変更点があると終了しない。必ず終了す
			るにはコマンド ":qall!" を使うこと。

:cq[uit]		書き込みをせずに必ず終了し、エラーコードを返す。コマン
			ド |:cq| を参照。Manx の QuickFix モードで使われる
			(|quickfix| を参照)。  {Vi にはない}

							*:wq*
:wq [++opt]		カレントファイルを書き込んでVimを終了する。ファイルが
			読込専用であるときや、バッファに名前が付いていないとき
			には書き込みに失敗する。引数リスト内の末尾のファイルが
			まだ編集されていないときには終了に失敗する。

:wq! [++opt]		カレントファイルを書き込んでVimを終了する。バッファに
			名前が付いていないときには書き込みに失敗する。

:wq [++opt] {file}	{file} に書き込んでVimを終了する。引数リスト内の末尾の
			ファイルがまだ編集されていないときには終了に失敗する。

:wq! [++opt] {file}	{file} に書き込んでVimを終了する。

:[range]wq[!] [++opt] [file]
			上と同様だが、[range] の範囲内の行のみを書き込む。

							*:x* *:xit*
:[range]x[it][!] [++opt] [file]
			|:wq| と似ているが、変更点があるときのみ書き込む。
			オプション 'hidden' がオンで複数のウィンドウが存在する
			とき、ファイルを書き込んだ後はカレントバッファは隠れ
			バッファになる。

							*:exi* *:exit*
:[range]exi[t][!] [++opt] [file]
			|:xit| と同様。

							*ZZ*
ZZ			変更点があればカレントファイルを書き込み、Vimを終了す
			る (コマンド |:x| と同様)。 Note: カレントファイルを複
			数のウィンドウで開いているときは、ファイルに変更点があ
			れば書き込まれ、そしてウィンドウが閉じられることに注意。

							*ZQ*
ZQ			変更点を確かめずに終了する (コマンド ":q!" と同様)。
			{Vi にはない}

複数のウィンドウとバッファ				*window-exit*

							*:qa* *:qall*
:qa[ll]		変更点のあるバッファがない限り、Vimを終了する  (変更点のある次
		のバッファに移動するにはコマンド ":bmod" を使うこと)。
		オプション 'autowriteall' がオンのときは、|:wqall| と同様に変
		更点のあるバッファが全て書き込まれる。 {Vi にはない}

:conf[irm] qa[ll]
		Vimを終了する。変更点のあるバッファがあるときはプロンプトを表
		示する。コマンド |:confirm| を参照すること。 {Vi にはない}

:qa[ll]!	Vimを終了する。バッファの変更点は全て失われる。 {Vi にはない}
		終了コードを非ゼロにしたい場合は |:cquit| を使う。

							*:quita* *:quitall*
:quita[ll][!]	コマンド |:qall| と同様。 {Vi にはない}

:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		変更点のあるバッファを全て書き込み、Vimを終了する。ファイル名
		のないバッファや読込専用または何らかの理由で書き込めないバッ
		ファがあるときは、Vimを終了しない。 {Vi にはない}

:conf[irm] wqa[ll] [++opt]
:conf[irm] xa[ll]
		変更点のあるバッファを全て書き込み、Vimを終了する。読込専用ま
		たは何らかの理由で書き込めないバッファがあるときは、プロンプト
		を表示する。コマンド |:confirm| を参照。 {Vi にはない}

:wqa[ll]! [++opt]
:xa[ll]!	変更点のあるバッファを、読込専用であっても全て書き込み、Vimを
		終了する。ファイル名のないバッファや何らかの理由で書き込めない
		バッファがあるときは、Vimを終了しない。 {Vi にはない}

==============================================================================
6. ダイアログ						*edit-dialogs*

							*:confirm* *:conf*
:conf[irm] {command}	{command} を実行する際、確認が必要ならばダイアログを表
			示する。コマンド |:q|, |:qa| や |:w| あるいは、
			|:only|, |:buffer|, |:bdelete| など、同様に失敗しうる
			コマンドと共に使える(|:w| では読み取り専用属性を無視す
			るかどうかを尋ねる)。

例: >
  :confirm w foo
<	ファイル "foo" が既に存在するときに確認を取る。 >
  :confirm q
<	バッファに修正個所があるときに確認を取る。 >
  :confirm qa
<	修正個所があり、保存されていないバッファがあるとき、各バッファについて
	保存するか破棄するか尋ねる。「全て保存」や「全て破棄」という選択肢もあ
	る。

常に ":confirm" を使いたいなら、代わりにオプション 'confirm' をオンにすること。

			*:browse* *:bro* *E338* *E614* *E615* *E616* *E578*
:bro[wse] {command}	{command} の引数のためにファイル選択ダイアログを開く。
			現在の所、これらのコマンドと共に使える |:e|, |:w|,
			|:wall|, |:wq|, |:wqall|, |:x|, |:xall|, |:exit|,
			|:view|, |:sview|, |:r|, |:saveas|, |:sp|, |:mkexrc|,
			|:mkvimrc|, |:mksession|, |:mkview|, |:split|,
			|:vsplit|, |:tabe|, |:tabnew|, |:cfile|, |:cgetfile|,
			|:caddfile|, |:lfile|, |:lgetfile|, |:laddfile|,
			|:diffsplit|, |:diffpatch|, |:open|, |:pedit|,
			|:redir|, |:source|, |:update|, |:visual|, |:vsplit|,
			'confirm' がオンのときは |:qall| も。
			{VimのWin32版、Motif、Athena、GTKやMacのGUI版でのみ利
			用可能。}
			|:browse|が使えない時はエラーが表示される。|+browse|
			の機能がなかったり、{command} が :browse に対応してい
			ない場合、{command} はダイアログなしで実行される。
			":browse oldfiles" については |:oldfiles| を参照。

使用法については、例をいくつか見るのが一番分かりやすい。 >
	:browse e $vim/foo
<		ファイル選択ダイアログをディレクトリ $vim/foo 内で開き、選択さ
		れたファイルを編集する。 >
	:browse e
<		ファイル選択ダイアログを 'browsedir' で指定されたディレクトリ
		内で開き、選択されたファイルを編集する。 >
	:browse w
<		ファイル選択ダイアログをカレントファイルのディレクトリ内で、カ
		レントファイルの名前を既定値として開き、選択されたファイル名を
		使ってバッファを保存する。 >
	:browse w C:/bar
<		ファイル選択ダイアログをディレクトリ C:/bar 内で、カレントファ
		イルの名前を既定値として開き、選択されたファイル名を使ってバッ
		ファを保存する。
オプション 'browsedir' も参照すること。
Vimのファイル選択ダイアログをサポートしないバージョンでは、コマンドはそのまま
実行される。

							*browsefilter*
MS-Windows と GTK では、ファイル選択ダイアログで使われるフィルタを指定できる。
グローバル変数 g:browsefilter かローカル変数 b:browsefilter を設定すると、フィ
ルタをグローバルにまたはバッファについてローカルに変更できる。この変数を指定す
る際の書式は "{filter label}\t{pattern};{pattern}\n" で、{filter label} はコン
ボボックス「ファイルの種類」に使われるテキスト、{pattern} はファイル名を選別す
るフィルタである。';' で区切れば複数のパターンを指定できる。

Motif上のVimでは同じ書式が使えるが、実際には1番目のパターンだけが使われる
(Motifではパターンは1種類しか使えないが、それをユーザーが編集できる)。

例えばダイアログでVim関連ファイルだけを表示するには、以下のコマンドを使う。 >

     let g:browsefilter = "Vim Scripts\t*.vim\nVim Startup Files\t*vimrc\n"

フィルタは、変数 b:browsefilter を設定することでバッファ毎に設定できる。
b:browsefilter はファイルタイププラグインで設定することが一番多いだろう。
するとファイルブラウザ・ダイアログには現在編集中のファイルのタイプに関連した候
補が表示される。弊害: 別の種類のファイルの編集が始め辛くなる。対策は、フィルタ
の最後の項目に "All Files\t*.*\n" を加え、ユーザーが望みのファイルにアクセスで
きる道を残すことだ。

Vim が browsefilter をサポートしていないときにそれを設定しないようにするには、
has("browsefilter") が使える: >

	if has("browsefilter")
	   let g:browsefilter = "whatever"
	endif

==============================================================================
7. カレントディレクトリ					*current-directory*

コマンド |:cd| や |:lcd| を使って別のディレクトリに移ることができる。すると
{訳注: そのディレクトリ内のファイルを編集するとき} そのディレクトリ名をファイ
ル名の前に付けなくても良くなる。また違いは ":!ls" 等の外部コマンドの実行の際に
も現れる。

'cpoptions' にフラグ '.' が含まれている場合、カレントバッファが変更されている
と、"!" をつけない限りディレクトリ変更は失敗する。

							*:cd* *E747* *E472*
:cd[!]			Unix以外のシステムでは: カレントディレクトリ名を表示す
			る。Unixシステムでは: カレントディレクトリをホームディ
			レクトリに変更する。全てのシステムで、カレントディレク
			トリの表示にはコマンド |:pwd| が使える。

:cd[!] {path}		カレントディレクトリを {path} に変更する。
			{path} が相対的な指定なら、オプション 'cdpath' 内に列
			挙されたディレクトリを基準に判断される。既に開かれたファ
			イルについては、フルパスが把握されているので変化はない。
			しかし引数リスト |arglist| 内のファイルの意味は変わる
			かもしれない！
			MS-DOSではアクティブなドライブも変更する。
			カレントファイルのディレクトリに移るにはこうする。 >
				:cd %:h
<
							*:cd-* *E186*
:cd[!] -		前のカレントディレクトリ (前にコマンド ":cd {path}" で
			移った所) に移る。 {Vi にはない}

							*:chd* *:chdir*
:chd[ir][!] [path]	コマンド |:cd| と同じ。

							*:lc* *:lcd*
:lc[d][!] {path}	コマンド |:cd| と似ているが、カレントウィンドウのカレ
			ントディレクトリのみを変更する。別のウィンドウのカレン
			トディレクトリに変化はない。 {Vi にはない}

							*:lch* *:lchdir*
:lch[dir][!]		|:lcd| と同じ。 {Vi にはない}

							*:pw* *:pwd* *E187*
:pw[d]			カレントディレクトリ名を表示する。 {Vi: pwdはない}
			|getcwd()| も参照。

コマンド |:lcd| が使われない限り、全てのウィンドウは同じカレントディレクトリを
共有する。別のウィンドウに移るコマンドを使ってもカレントディレクトリについての
変化は何もない。
コマンド |:lcd| があるウィンドウ内で使われると、指定されたディレクトリがそのウィ
ンドウに対してのカレントディレクトリになる。コマンド |:lcd| が使われたことのな
いウィンドウはグローバルなカレントディレクトリを使い続ける。別のウィンドウに移っ
たときは、カレントディレクトリは {訳注: 移動先に対して} 最後に指定されたローカ
ルなカレントディレクトリになる。何も指定されていなかったら、グローバルなカレン
トディレクトリが使われる。
コマンド |:cd| が使われると、カレントウィンドウは固有のローカルなカレントディ
レクトリを失い、グローバルなカレントディレクトリを使うようになる。

|:cd| を使った後は、ファイルの読み書きにはフルパス名が使われる。ネットワーク接
続されたファイルシステムではこれが問題を起こすことがある。フルパス名を使った結
果、現在使用中のファイル名は同じファイルを指し続けることになる。例: ファイル
a:test とディレクトリ a:vim があるとき、":e test" ":cd vim" ":w" とするとファ
イル a:test を上書きし、a:vim/test には書き込まない。しかし ":w test" とすると
ファイル a:vim/test が書き込まれる。それは新しいファイル名が指定され、":cd" 以
前のファイル名には言及してないからだ。

==============================================================================
8. バイナリファイルの編集				*edit-binary*

Vimはテキストファイルの編集のために作られたが、バイナリファイルを編集すること
もできる。Vimの引数 |-b| (バイナリ "binary" の 'b') はVimにファイル入出力をバ
イナリモードで行わせ、バイナリファイルの編集のためにいくつかのオプションを設定
する ('binary' をオン、'textwidth' を0、'modeline' をオフ、'expandtab' をオフ
にする)。オプション 'binary' をオンにすることも同じ効果を持つ。これはファイル
の読み込み前にするということを忘れてはならない。

バイナリファイルを編集するときに忘れてはならないことがいくつかある:
- 実行可能ファイルを編集するときには、文字数が変わってはならない。テキストを変
  更するには "R" か "r" だけを使用すること。"x" やバックスペースで文字を削除し
  てはならない。
- オプション 'textwidth' の値を0に設定する。そうしないと行が不意に2つに分割さ
  れてしまう。
- <EOL> の数があまり多くないときは、一行は非常に長くなる。スクリーンに収まりき
  らない行を編集したいならば、オプション 'wrap' をオフにすること。その時には水
  平スクロールが使われる。行が余りにも長いならば (Amigaでは約32767文字以上、
  32bitシステムではそれ以上、|limits| を参照)、その行は編集できない。ファイル
  を読み込むときに、その行は分割される。ファイルを読み込むときに
  "out of memory" エラーが出る可能性もある。
- ファイルを読み込む前にオプション 'binary' がオンになっていることを確かめるこ
  と。さもないと <CR> <NL> と <NL> の両方が行末とみなされ、ファイルが保存され
  るときに <NL> が <CR> <NL> で置き換えられてしまう。
- <Nul> 文字はスクリーンでは ^@ として表示される。それは "CTRL-V CTRL-@" か
  "CTRL-V 000" で入力できる。{Vi ファイル内で <Nul> 文字を扱えない}
- <NL> 文字を挿入すると、行が分割される。バッファをファイルに保存するときには、
  <NL> が <EOL> として保存される。
- ファイルの終わりに <EOL> が一つもないとき、通常Vimはそれを追加する。これを防
  ぐにはオプション 'binary' をオンにすること。最後の <EOL> を追加したいならば、
  オプション 'endofline' をオンにする。最後の行に <EOL> があったかどうかを知る
  ためにこのオプションの値を見てもよい (テキストからは判断できない)。

==============================================================================
9. 暗号化						*encryption*

Vimはファイルを暗号化して保存し、再び読み取ることができる。暗号化されたテキス
トは正しい鍵がないと読むことができない。
{Vimが |+cryptv| 機能付きでコンパイルされたときのみ有効}  *E833*

スワップファイルやアンドゥファイル内のテキストも暗号化される。  *E843*

Note: メモリ内のテキストは暗号化されない。ユーザーがテキストを編集している間、
システム管理者はそれを見ることができる。":!filter" や ":w !command" によって
フィルタに通しているときはテキストは暗号化されておらず、他人に見られる可能性が
ある。'viminfo' ファイルは暗号化されない。

警告: 鍵の入力時にタイプミスをしてファイルを保存し、Vimを終了すると、テキスト
は失われてしまう！

暗号化を利用する通常の方法は、コマンド |:X| を使うことだ。これは鍵を入力するよ
う求める。次の保存コマンドでファイルを暗号化するためにその鍵が使われる。後で同
じファイルを編集するときは、Vimは鍵の入力を求める。保存に使われたものと同じ鍵
を打ち込むと、再びテキストを読み込むことができる。間違ったキーを使うと、テキス
トはめちゃめちゃになって表示される。

							*:X*
:X	暗号化キーを入力するよう求める。ディスプレイを見ている誰かが鍵を見ない
	ように、打ち込むときには実際のテキストは表示されない。
	打ち込まれた鍵はオプション 'key' に保存される。これはファイルを書き込
	むときの暗号化に使われる。Vimの引数 |-x| も参照。

オプション 'key' の値はテキストが書き込まれるときに使われる。値が空でないとき、
書き込まれたファイルは、その値を鍵として暗号化されている。Vimがファイルが暗号
化されていることを認識できるよう、ファイル先頭に特殊な数が付加される。

暗号化を無効にするには、オプション 'key' に空の値を入れてリセットする。 >
	:set key=

'cryptmethod' オプションを設定することで暗号化メソッドを選択できる。次のうち
一つを使うこと: >
	:setlocal cm=zip       " 弱いメソッド。後方互換。
	:setlocal cm=blowfish  " 強いメソッド。
ファイルを保存する前に設定する。暗号化されたファイルを読み込んだとき、このオプ
ションは自動的にファイル保存時に使われたメソッドに設定される。ファイルを保存す
る前に 'cryptmethod' を変更することで使用するメソッドを変更できる。
新しいファイルに使われるデフォルトのメソッドを設定したい場合は |vimrc| ファイ
ルで次のどちらかを設定すること: >
	set cm=zip
	set cm=blowfish
ファイルを読み込んだり書き込んだりしたとき、zip なら "[crypted]"、blowfish な
ら "[blowfish]" とメッセージが表示される。

アンドゥファイルが保存されるとき、同じキーとメソッドがアンドゥファイル内のテキ
ストに適用される。|persistent-undo|。

						*E817* *E818* *E819* *E820*
暗号化が正しく機能しないと、保存したファイルが後で読めなくなってしまう。そのた
め、暗号化が期待したとおりに機能しているかどうかを確認するための検査が実行され
る。これらのエラーが表示されたときはファイルを暗号化して保存しないこと。これを
直すためには Vim を再ビルドする必要があるだろう。

*E831* これは内部エラーで普通は発生しない。このエラーの再現手順を見つけた方は
開発者へ連絡していただきたい。

暗号化されたファイルを読み込んだとき、'key' オプションの値が空でなければその値
が復号に使われる。空のときは入力プロンプトが表示される。キーを入力しないか間
違ったキーを入力するとファイルは復号されずに開かれる。キーが間違っていても警告
は表示されない (総当たり攻撃を難しくするため)。

異なる鍵で暗号化したファイルの読み込みを始めたいときは、オプション 'key' の値
に空文字列を設定すること。するとVimが新しい値の入力を求める。値の入力にコマン
ド ":set" を使ってはならない。他の人が肩越しにコマンドの入力を読むことができる
からだ。

オプション 'key' の値は秘密であることになっているので、その値は決して見られて
はならない。vimrcファイル内でこのオプションを設定してはいけない。

"/etc/magic", "/usr/share/misc/magic" 等、システムの持っている "magic" ファイ
ルならどれでもよいが、下の行を追加すると、暗号化されたファイルが "file" コマン
ドに認識されるようになる: >
     0	string	VimCrypt~	Vim encrypted file
     >9	string	01	- "zip" cryptmethod
     >9	string	02	- "blowfish" cryptmethod


Note:
- オプション 'charconvert' でコード変換をしているときには暗号化はできない。
- コピーや削除したテキストは番号付きレジスタに格納される。レジスタの内容は
  .viminfoファイル内に保存できるが、ここからは読み出せるかもしれない。安全のた
  めオプション 'viminfo' を変更すること。
- コンピュータからしばらく離れているときには誰かがVimにコマンドを入力できるが、
  鍵を入手できるようになっていてはいけない。
- キーを入力しているときにタイプミスをすると、テキストを復元できなくなってしま
  うだろう！
- コマンド ":set key=value" で鍵を入力すると、それは履歴の中に保存され、
  viminfoファイル内に 'key' の値を晒すことになる。
- 100パーセント安全ということは決してない。Vimの暗号化は強度についてはテストさ
  れていない。
- 'cryptmethod' が "zip" のときに使用されるアルゴリズムは簡単に破れる。4 文字
  の鍵なら約1時間以内、6文字の鍵なら1日以内で破れる (Pentium 133 PCで)。これに
  はファイル内に必ず現れるはずのテキストをいくつか知っている必要がある。暗号破
  りの熟練者はどのような鍵であっても破ることができる。テキストが復号化されたと
  いうことは鍵も明らかになったということであり、同じ鍵で暗号化された他のテキス
  トも復号化できてしまう。
- Pkzip は 'cryptmethod' の "zip" と同じ暗号化を用いており、合衆国政府はその輸
  出に対して異議を唱えていない。Pkzipの公開ファイル APPNOTE.TXT にはこのアルゴ
  リズムが詳細に記述されている。
- Vimはオランダに起源を持つ。そこがソースの出処である。従って、暗号化コードは
  アメリカ合衆国から輸出されてはいない。

==============================================================================
10. タイムスタンプ				*timestamp* *timestamps*

Vimは編集を始めたときのファイルの修正タイムスタンプを覚えている。これは同じ
ファイルの別のバージョンを (知らずに) 作ってしまうのを防ぐためである。

シェルコマンド (|:!cmd| |suspend| |:read!| |K|) の実行後、ウィンドウ内の全ての
バッファでタイムスタンプが比較される。Vimは変更を受けたファイルに関して、イベ
ント |FileChangedShell| に関連付けられた任意の自動コマンドを実行するか、警告を
表示する。GUIを使っているときは、それらはVimに入力フォーカスが戻ってきたときに
行われる。

							*E321* *E462*
ファイルがVimの外部で変更を受けたときに自動的に読み直して欲しいなら、オプショ
ン 'autoread' をオンにすること。しかしこれはファイルを書き込んだ時点では機能し
ない。ファイルがVim内部で変更されていないときだけだ。

Note イベント |FileChangedShell| に自動コマンドが定義されていると、警告メッセー
ジやプロンプトは表示されない。その自動コマンドが対処するものとされている。

ディレクトリに関する警告はない (例えば |netrw-browse| で)。しかし新しいファイ
ルの編集を始めた後、同名のディレクトリが作られたときには警告される。

ファイルのタイムスタンプが変更されたことにVimが気付いたとき、そのファイルが
バッファ内で編集されているがまだ変更されていないならば、Vimはファイルの中身が
同じかどうかを調べる。このためにはファイルを読み直し、テキストを比較する (隠れ
バッファに読み込むが、これはすぐに削除される)。内容が同じならば警告は出ない。

自動警告では足りないと思ったならば、以下のコマンドが使える。

							*:checkt* *:checktime*
:checkt[ime]		Vimの外部で変更を受けたバッファがないかどうか調べる。
			これはファイルのバージョンが2個になってしまわないかど
			うかを調べ、警告する。
			これがオートコマンドや ":global" コマンドから呼ばれた
			ときや、直に打ち込まれたのではないときは、実際に調べる
			のは副作用 (ファイルの再読み込み) が無害となる時点まで
			延期される。
			読み込まれているバッファそれぞれについて関連付けられた
			ファイルが変更を受けていないか調べる。変更を受けていた
			ら、 Vimは対処動作を行う。すなわちバッファに変更点が無
			く、かつオプション 'autoread' がオンのときは、バッファ
			は読み直される。そうでなければ、ファイルを読み直すかど
			うかの選択肢が与えられる。ファイルが削除されていたら、
			エラーメッセージが表示される。
			以前には存在しなかったファイルが存在していたら、エラー
			メッセージが表示される。
			一度ファイルが調べられるとタイムスタンプ情報が更新され、
			再び警告されることは無い。

:[N]checkt[ime] {filename}
:[N]checkt[ime] [N]
			特定のバッファのタイムスタンプを調べる。バッファの指定
			は名前、番号またはパターンでもよい。

							*E813* *E814*
ここでユーザーがバッファを再読み込みすることを選ぶと、再読み込みされる。そのバッ
ファを含むウィンドウが表示されている場合、再読み込みはそのウィンドウの中で行わ
れる。そのようなウィンドウがなければ、オートコマンドが正常に動作するよう、特殊
なウィンドウが使われる。このウィンドウを閉じることはできない。他にもいくつかの
制限が適用される。カレントバッファの外では何も起こらないようにするのがベストで
ある。例えば、ウィンドウローカルなオプションをセットすると、間違ったウィンドウ
の中でセットされてしまう。ウィンドウを分割し、そこで何かをして、閉じることは大
丈夫である(他のオートコマンドによる副作用が何もなければ)。無関係なウィンドウや
バッファを閉じると問題を引き起こすだろう。

書き込み前にはタイムスタンプが調べられる。もし変更されていたら、Vimはそのファ
イルを本当に上書きするかどうかを尋ねる。

	警告: 読込んだ後にファイルに変更がありました!!!
	本当に上書きしますか (y/n)?

'y' を打ち込むと、Vimは続けて書き込みを行う。'n' を打ち込むと、書き込みは中止
される。コマンド ":wq" や "ZZ" を使った場合にはVimは終了せず、書き込む機会が再
び得られる。

普通、メッセージは編集セッションが始まった後に誰かがファイルに書き込んだことを
示している。それは別の人物かもしれない。この場合、あなたの行った変更とその人物
が行った変更が合併されるべきか調べたいことだろう。ファイルを別の名前で書き込み、
差分を調べること (これにはプログラム "diff" が使える)。

別の編集セッションや別のコマンドで (例えばフィルタコマンド) そのファイルに自分
自身で変更を加えたということもあり得る。その場合、どちらのバージョンを保管した
いかは自分でお分かりだろう。

何も間違ったことはしていないのにこのメッセージが現れる場合が1つある:
Win32 でサマータイムが始まる日である。Win32 ライブラリにより、Vim が時間の差を
混乱してしまう。この問題は次の日には直る。

==============================================================================
11. ファイル検索					*file-searching*

{Vimが |+path_extra| 機能付きでコンパイルされたときのみ有効}

現在の所、オプション 'path', 'cdpath', 'tags' と|finddir()|, |findfile()| で、
本節で説明する「ファイル検索」にしたがってワイルドカードの展開が行われる。
それ以外のコマンドでは |wildcards| という少し異なるルールにしたがう。

ファイル検索には以下の3種類がある:

1) 下向き検索:						 *starstar*
   下向き検索にはワイルドカード '*' と '**' 及びユーザーのOSがサポートするその
   他のものが使える。'*' と '**' はVim内部で処理されるので、全てのOSで機能する。
   Note "**" はパス名の先頭で使われた場合のみ特別なワイルドカードとなる。

   '*' の使用法はきわめて単純: 0 個以上の文字にマッチする。
   正規表現パターンでいうと ".*" と同じである。正規表現と異なり "." は必要ない
   ことに注意。

   '**' はもっとすばらしい。
      - これはディレクトリのみにマッチする。
      - これはデフォルトで 30 段階までの深さのディレクトリにマッチするので、ディ
	レクトリ・ツリー全体の検索に使える。
      - マッチする深さの最大値は '**' の後に数字を付け加えて指定できる。
	だから '/usr/**2' は下のようにマッチする。 >
		/usr
		/usr/include
		/usr/include/sys
		/usr/include/g++
		/usr/lib
		/usr/lib/X11
		....
<	'/usr/include/g++/std' には、深さが3なのでマッチしない。
	指定可能な範囲は 0 ('**0' は無視される) から 100 である。
	負数を指定すると 30 を、100 より大きい数を指定すると 100 を指定したも
	のとされる。システムにもパスの長さの限界が存在する場合がある。通常は
	256 または 1024 バイトである。
      - '**' はパスの末尾にのみ使える。後ろにパス区切り文字か、数字とパス区切
	り文字の組み合わせを付けてもよい。

   '*' と '**' を組み合わせる順番は自由である。 >
	/usr/**/sys/*
	/usr/*tory/sys/**
	/usr/**2/sys/*

2) 上向き検索:
   この方法ではディレクトリを指定すると、そのディレクトリから上に遡ってファイ
   ルを探す。上向き探索の上限となるディレクトリが指定できる。それはパス (オプ
   ション 'path') かファイル名 (オプション 'tags') の末尾に ';' で区切って指定
   する。複数のディレクトリを指定したいときはそれらを ';' で区切る。上限ディレ
   クトリを指定したくないときは (ルートディレクトリまで上向き検索したいとき)
   ';' だけを付ける。 >
	/usr/include/sys;/usr
<  で検索されるディレクトリは: >
	/usr/include/sys
	/usr/include
	/usr
<
   相対パスを使うと上向き検索はVimのカレントディレクトリから始まる。相対パスの
   指定が './' で始まり、'cpoptions' にフラグ 'd' が含まれていないときはカレン
   トファイルのディレクトリから始まる。

   Vimのカレントパスが /u/user_x/work/release のときに >
	:set path=include;/u/user_x
<  とすると、コマンド |gf| でファイルを探す範囲は: >
	/u/user_x/work/release/include
	/u/user_x/work/include
	/u/user_x/include

3) 複合検索:
   Vimのカレントパスが /u/user_x/work/release のときに >
	set path=**;/u/user_x
<  とすると、コマンド |gf| でファイルを探す範囲は: >
	/u/user_x/work/release/**
	/u/user_x/work/**
	/u/user_x/**
<
   注  意  !  これはかなりの時間を食うかもしれない。'/u/user_x/**' は
   '/u/user_x/work/**' や '/u/user_x/work/release/**' を含むからだ。つまり
   '/u/user_x/work/release/**' は3回、'/u/user_x/work/**' は2回繰り返して検索
   される。

   上の例では次のように設定したほうがいいかもしれない: >
	:set path=**,/u/user_x/**
<  これに含まれる範囲は
	/u/user_x/work/release/** ~
	/u/user_x/** ~
   となり、同じディレクトリだが順番が違う。

   Note: 現在 ":find"、":sfind"、":tabfind" コマンドは、'path' アイテムに url
   や深さ制限付きのダブルスター (/usr/**2) や 上方検索 (;) などが含まれている
   と機能しない。
>
 vim:tw=78:ts=8:ft=help:norl:
