*insert.txt*    For Vim バージョン 7.4.  Last change: 2013 Apr 12


		VIMリファレンスマニュアル    by Bram Moolenaar


						*Insert* *Insert-mode*
テキストの挿入と置換					*mode-ins-repl*

よく使われるコマンドの概要がユーザーマニュアルの24章|usr_24.txt|にある。

このファイルの大部分は挿入と置換モードについて記述してある。終わりのほうにテキ
ストを挿入する別の方法を記述している。

1. 特別なキー						|ins-special-keys|
2. もっと特別なキー					|ins-special-special|
3. 'textwidth'と'wrapmargin'オプション			|ins-textwidth|
4. 'expandtab'、'smarttab'それと'softtabstop'オプション	|ins-expandtab|
5. 置換モード						|Replace-mode|
6. 仮想置換モード					|Virtual-Replace-mode|
7. 挿入モードの補完					|ins-completion|
8. 挿入モードのコマンド					|inserting|
9. Exの挿入コマンド					|inserting-ex|
10. ファイルを挿入する					|inserting-file|

文字のない場所にカーソルと移動するためには 'virtualedit' も参照すること。表を
編集するときに便利である。

==============================================================================
1. 特別なキー						*ins-special-keys*

挿入と置換モードでは、以下の文字には特別な意味がある。その他の文字はそのまま入
力される。それらの特別な文字をバッファに入力するには、CTRL-Vに続けて入力する。
<Nul>文字を入力するには "CTRL-V CTRL-@" か "CTRL-V 000" を使用する。あるシステ
ムでは、CTRL-Cを入力するのに "CTRL-V 003" を使わなければならない。Note: CTRL-V
に他の動作がマップされているときは、多くの場合、代わりにCTRL-Qを使う
|i_CTRL-Q|。

テキストを入力する際に特別な言語のモードを使用している場合、いつもこのモードが
ON/OFFと切り替えられてしまうのをどう避けるかを知るには 'langmap' オプション
(|'langmap'|) を参照すること。

'insertmode' を設定した場合には、<Esc>と他の幾つかのキーに別の意味が与えられ
る。|'insertmode'| を参照。

文字		アクション	~
-----------------------------------------------------------------------
						*i_CTRL-[* *i_<Esc>*
<Esc> or CTRL-[	挿入/置換モードを終了し、ノーマルモードに戻る。短縮入力を終了
		する。
		Note: キーボードによっては<Esc>が押し難いかもしれないが、その
		時にはCTRL-[を使うようにする。
						*i_CTRL-C*
CTRL-C		挿入モードを終了し、ノーマルモードに戻る。短縮入力はチェック
		しない。CTRL-C で挿入モードを抜けると |InsertLeave| が発生しな
		い。

						*i_CTRL-@*
CTRL-@		直前に挿入されたテキストをもう一度挿入し、挿入を終了する。{Vi:
		最初に入力された時だけ、かつ最大128文字まで}
						*i_CTRL-A*
CTRL-A		直前に挿入されたテキストをもう一度挿入する。 {Vi にはない}

						*i_CTRL-H* *i_<BS>* *i_BS*
<BS> or CTRL-H	カーソルの前の文字を削除する(行同士の連結については
		|i_backspacing|参照)。
		<BS>キーが想定するように働かない場合には|:fixdel|を参照。
		{Vi: 自動字下げは消すことができない}
						*i_<Del>* *i_DEL*
<Del>		カーソルの下の文字を削除する。カーソルが行末にあり、
		'backspace' オプションに "eol" が含まれている場合には、<EOL>が
		削除される; 現在の行の後ろに次の行が接続される。
		<Del>キーが想定するように働かない場合には|:fixdel|を参照。
		{Vi にはない}
						*i_CTRL-W*
CTRL-W		カーソルの前にある単語を削除する(行同士の連結については
		|i_backspacing|参照)。単語の定義については "word motions" の節
		|word-motions|を参照。
						*i_CTRL-U*
CTRL-U		現在の行の入力済み文字全部を削除する(行同士の連結については
		|i_backspacing|参照)。

						*i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> or CTRL-I タブを挿入する。'expandtab' オプションが設定されていれば、同じ
		数の空白文字が挿入される(展開を避けるためにはCTRL-V <Tab>を使
		う。CTRL-Vに他の動作がマップされているときはCTRL-Q <Tab>を使
		う|i_CTRL-Q|)。'smarttab' オプションと|ins-expandtab|も参照。
						*i_CTRL-J* *i_<NL>*
<NL> or CTRL-J	新しい行を始める。
						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	新しい行を始める。
						*i_CTRL-K*
CTRL-K {char1} [char2]
		ダイグラフ(|digraphs|参照)を入力する。{char1}が特別なキーだっ
		た場合、そのキーのコードが<>の形で挿入される。例えば、
		<C-K><S-Space>(キー2つ)と入力することで、文字列 "<S-Space>" が
		入力される。マッピングも考慮されない。 {Vi にはない}

CTRL-N		次のキーワードを探す(|i_CTRL-N|を参照)。 {Vi にはない}
CTRL-P		前のキーワードを探す(|i_CTRL-P|を参照)。 {Vi にはない}

CTRL-R {0-9a-z"%#*+:.-=}					*i_CTRL-R*
		レジスタの内容を挿入する。CTRL-Rをタイプしてから2つ目の文字を
		タイプするまで、レジスタの名前の入力が期待されていることを示す
		ため、'"'が表示される。
		テキストはタイプしたかのように挿入されるが、マッピングや短縮入
		力の展開はされない。'textwidth'や'formatoptions'や'autoindent'
		のようなオプションが設定されている場合には、入力されたテキスト
		に対して効力を持つ。これは "p" コマンドやマウスによる貼り付け
		とは、違う動作になる。
		特別なレジスタ:
			'"'	最後に削除されたりヤンクされたテキストの入って
				いる、名前なしレジスタ
			'%'	現在のファイル名
			'#'	代替バッファのファイル名
			'*'	クリップボードの内容 (X11: プライマリセレク
				ション)
			'+'	クリップボードの内容
			'/'	最後に検索を行ったパターン
			':'	最後に実行したコマンドライン
			'.'	最後に挿入したテキスト
			'-'	最後に削除した小さい(行単位以下の)領域
							*i_CTRL-R_=*
			'='	式評価レジスタ: 式評価の入力を求められる
				(|expression|参照)。
				0x80 (10進数で 128) は特殊なキーのために使われ
				る。例:次のコマンドでカーソルを上に移動できる:
					CTRL-R ="\<Up>"
				文字をそのまま挿入するには CTRL-R CTRL-R を使
				うこと。
				結果が |List| のときは各要素を行として挿入する。
				要素の中に改行文字があってもよい。
				結果が浮動小数点数のときは自動的に文字列に変換
				される。
		レジスタについては|registers|を参照。 {Vi にはない}

CTRL-R CTRL-R {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-R*
		レジスタの内容を挿入する。CTRL-Rが一つの時と同様に働くが、タイ
		プされたようにではなく、テキストは文字通りに挿入される。これは
		レジスタに<BS>のような文字が含まれていた場合に違いを生じる。例
		えば "ab^Hc" という内容のレジスタaがあった場合: >
	CTRL-R a		結果は "ac".
	CTRL-R CTRL-R a		結果は "ab^Hc".
<		'textwidth' や 'formatoptions' などのオプションは適用される。
		これらのオプションを無効にするには "<C-R><C-O>r" を使用する。
		'.' レジスタ (最後に挿入されたテキスト) だけは、CTRL-R と同様
		に、タイプされたように挿入される。 {Vi にはない}

CTRL-R CTRL-O {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-O*
		レジスタの内容が文字通り挿入され、自動字下げも行われない。マウ
		スによる貼り付け|<MiddleMouse>|と同様である。
		キャラクタは置き換えられない!
		'.' レジスタ (最後に挿入されたテキスト) だけは、CTRL-R と同様
		に、タイプされたように挿入される。 {Vi にはない}

CTRL-R CTRL-P {0-9a-z"%#*+/:.-=}			*i_CTRL-R_CTRL-P*
		レジスタの内容が文字通りに挿入され、インデントが
		|[<MiddleMouse>|同様に修正される。
		キャラクタは置き換えられない!
		'.' レジスタ (最後に挿入されたテキスト) だけは、CTRL-R と同様
		に、タイプされたように挿入される。 {Vi にはない}

						*i_CTRL-T*
CTRL-T		現在の行の先頭にshiftwidth一単位分の字下げを挿入する。字下げ幅
		は 'shiftwidth' に丸められる(これはviと同じ)。{Vi: 字下げされ
		ている時だけ}
						*i_CTRL-D*
CTRL-D		現在の行の先頭の字下げを、shiftwidth一単位分削除する。字下げ幅
		は 'shiftwidth' に丸められる(これはviと同じ)。{Vi: CTRL-Dは自
		動字下げの適用後にしか使えない}
						*i_0_CTRL-D*
0 CTRL-D	現在行の字下げを完全に削除する。{Vi: CTRL-Dは自動字下げの適用
		後にしか使えない}
						*i_^_CTRL-D*
^ CTRL-D	現在行の字下げを完全に削除する。次の行では字下げは元に戻され
		る。これはラベルを入力する際に役に立つ。{Vi: CTRL-Dは自動字下
		げの適用後にしか使えない}

						*i_CTRL-V*
CTRL-V		続く非数字文字を文字通りに挿入する。特別なキーはターミナルコー
		ドが挿入される。10進数、8進数、16進数、の数字で文字コードを直
		接指定することもできる|i_CTRL-V_digit|。CTRL-Vの後の入力には
		マップは適用されない。{Vi: 数字文字をバイトに変換できない}
		Note: CTRL-Vに他の動作がマップされているとき(例えばテキストを
		ペーストするなど)、その場合には代わりにCTRL-Qを使用する
		|i_CTRL-Q|。

						*i_CTRL-Q*
CTRL-Q		CTRL-Vと同じ。
		Note: ある種のターミナルではCTRL-Qを使用できない。GUIでは使え
		る。

CTRL-X		CTRL-Xモードに入る。これは単語の補完やウィンドウスクロールのコ
		マンドを入力する、サブモードである。|i_CTRL-X|と
		|ins-completion|を参照。{Vi にはない}

						*i_CTRL-E*
CTRL-E		カーソルの下の行の同じ位置の文字を挿入。{Vi にはない}
						*i_CTRL-Y*
CTRL-Y		カーソルの上の行の同じ位置の文字を挿入。{Vi にはない}
		'textwidth' はCTRL-EとCTRL-Yには、長い行から文字をコピーするこ
		とを可能にするために、効力を発揮しないことに注意。

						*i_CTRL-_*
CTRL-_		次に示すように言語を切り替える:
		-  右→左ウィンドウでは、revinsとnohkmapに切り替えられ、この場
		   合英語を挿入できるようになる。
		-  右→左ウィンドウ以外ではrevinsとhkmapに切り替えられ、この場
		   合ヘブライ語を挿入できるようになる。

		CTRL-_はカーソルをタイプ済みテキストの末尾に移動させる。

		このコマンドは 'allowrevins' オプションが設定されている時のみ
		有効。
		右→左モードについての詳しい情報は|rileft.txt|を参照。
		{Vi にはない}
		|+rightleft|機能を有効(にしてコンパイルした時にだけ使用可能。

						*i_CTRL-^*
CTRL-^		入力言語を切替える。
		言語マッピング|:lmap|が定義されているとき:
		  'iminsert' が1(言語マッピングが使われている)なら0(言語マッ
		  ピングを使わない)になる。
		  'iminsert' が他の値なら1になる。したがって言語マッピングが
		  有効になる。
		言語マッピングが定義されていないとき:
		  'iminsert' が2(インプットメソッドが使われている)なら0(イン
		  プットメソッドを使わない)になる。
		  'iminsert' がその他の値なら2になる。したがってインプットメ
		  ソッドが有効になる。
		'iminsert' を1にすると "b:keymap_name" の値、または 'keymap'
		オプションか "<lang>" がステータスラインに表示される。
		言語マッピングは通常はキーボードにない文字を打つのに使われる。
		これらの値を設定するために 'keymap' オプションを使える。
		{Vi にはない}

						*i_CTRL-]*
CTRL-]		文字を入れることなく、短縮入力をトリガーする。{Vi にはない}

						*i_<Insert>*
<Insert>	挿入と置換モードを交互に切り替える。{Vi にはない}
-----------------------------------------------------------------------

						*i_backspacing*
<BS>、CTRL-WそしてCTRL-Uの効果は 'backspace' オプションに依存している('revins'
が設定されていなければ)。これは下記の項目をカンマで区切ったリストになっている:

項目	    アクション ~
indent	    字下げをバックスペースで消去可能
eol	    行末をバックスペースで消去可能(行を連結)
start	    挿入の開始点を超えてバックスペースで消去可能; CTRL-WとCTRL-Uは一度
	    スタート地点で停止する。

'backspace' が空の時、Vi互換のバックスペースが使用される。自動字下げや、第1カ
ラムの前、そして挿入の開始点を超えてのバックスペースはできない。

下位互換性のために、値として "0"、"1" そして "2" を使用することもできる。
|'backspace'| 参照。

'backspace' オプションが "eol" を含まれている時に、カーソルが第1カラムにあり、
3つのキーのうちどれかが押されると、現在の行が1行前の行に連結される。これはカー
ソルの前にある<EOL>を事実上消している。
{Vi: 行をまたいだり、挿入の開始点を超えての削除はできない}

						*i_CTRL-V_digit*
CTRL-Vに続けて、10進数、8進数、16進数のどれかで文字コードを直接入力することが
できる。この方法で改行 (<NL>, 数値 10) 以外のどんな文字でも入力することができ
る。文字コードを入力するには5つの方法がある。

最初の文字	モード		最大文字数	最大値 ~
(なし)		10進数		    3		 255
o か O		8進数		    3		 377	  (255)
x か X		16進数		    2		 ff	  (255)
u		16進数		    4		 ffff	  (65535)
U		16進数		    8		 7fffffff (2147483647)

入力できる文字数の最大まで入力すると、例えば<C-V>032と入力した場合にはスペー
ス(値32)が入る。一番上の桁のゼロは省略することができる。その場合には数値を入
力した後に入力する文字は数字以外でなければならない。これは他のモードでも同じ
である。モード中で無効な文字を入力した場合には、それ以前に入力されたものが使
われ無効な文字は通常の入力として扱われる。

値10を入力すると、それは0になってしまう。数値10は<NL>であり、内部で<Nul>文字
を表すのに使われている。バッファをファイルに書き出すときに<NL>は<Nul>に変換
される。<NL>は各行末に出力されるので、<NL>をファイルに書きたければ改行するこ
と。

						*i_CTRL-X* *insert_expand*
CTRL-Xを押すと、幾つかのコマンドを使用することが出来る、サブモードに入る。これ
らのコマンドの多くはキーワードの補完である; |ins-completion|参照。Vimのコンパ
イル時に|+insert_expand|機能を無効にした場合には、この機能は使用できない。

次の2つのコマンドは、挿入モードを抜けることなくウィンドウを上下にスクロールさ
せることができる:

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		ウィンドウを一行上にスクロール。
			補完途中での機能については |complete_CTRL-E| を参照。

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		ウィンドウを一行下にスクロール。
			補完途中での機能については |complete_CTRL-E| を参照。

CTRL-Xを押した後にCTRL-E(もしくはCTRL-Y)を押すと、現在のファイル内でカーソルを
現在の位置から動かすことなく、ウィンドウが一行上(下)にスクロールする。関係ない
キーが押されると、すぐにCTRL-Xモードは終了し、そのキーが挿入モードで押されたも
のとして解釈される。


==============================================================================
2. もっと特別なキー				*ins-special-special*

下のキーは特別である。これらは現在の挿入を中断し、何かを行い、そして挿入を再開
する。これは挿入モード出ることなく、何かをすることができることを意味している。
これはモードが分かれていない普通のエディタのように、常に挿入モードを使用するの
が好みの場合には、とても便利である。これには 'backspace' オプションに
"indent,eol,start" を設定し、'insertmode' オプションを設定すると良いだろう。コ
マンドにファンクションキーをマップしたいならば、CTRL-Oを使うことができる。

これらのキーを使用する前後の変更(文字の挿入や削除)は、別々に取り消すことができ
る。最後の変更だけがやり直すことができ、常に "i" コマンドのように振舞う。

char		action	~
-----------------------------------------------------------------------
<Up>		カーソルを1行上へ移動する		     *i_<Up>*
<Down>		カーソルを1行下へ移動する		     *i_<Down>*
CTRL-G <Up>	1行上の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_<Up>*
CTRL-G k	1行上の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_k*
CTRL-G CTRL-K	1行上の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	1行下の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_<Down>*
CTRL-G j	1行下の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_j*
CTRL-G CTRL-J	1行下の、挿入開始位置と同じ列へ移動	     *i_CTRL-G_CTRL-J*
<Left>		カーソルを1文字左へ移動する		     *i_<Left>*
<Right>		カーソルを1文字右へ移動する		     *i_<Right>*
<S-Left>	カーソルを1単語前へ("b"コマンドのように)     *i_<S-Left>*
<C-Left>	カーソルを1単語前へ("b"コマンドのように)     *i_<C-Left>*
<S-Right>	カーソルを1単語後へ("w"コマンドのように)     *i_<S-Right>*
<C-Right>	カーソルを1単語後へ("w"コマンドのように)     *i_<C-Right>*
<Home>		カーソルを行の最初の文字へ		     *i_<Home>*
<End>		カーソルを行の最後の文字の後へ		     *i_<End>*
<C-Home>	カーソルをファイルの最初の文字へ	     *i_<C-Home>*
<C-End>		カーソルをファイルの最後の文字の後へ	     *i_<C-End>*
<LeftMouse>	カーソルをマウスでクリックした位置へ	     *i_<LeftMouse>*
<S-Up>		1ページ上へ				     *i_<S-Up>*
<PageUp>	1ページ上へ				     *i_<PageUp>*
<S-Down>	1ページ下へ				     *i_<S-Down>*
<PageDown>	1ページ下へ				     *i_<PageDown>*
<ScrollWheelDown>    ウィンドウを3行下へ移動		*i_<ScrollWheelDown>*
<S-ScrollWheelDown>  ウィンドウを1ページ下へ移動	*i_<S-ScrollWheelDown>*
<ScrollWheelUp>      ウィンドウを3行上へ移動		*i_<ScrollWheelUp>*
<S-ScrollWheelUp>    ウィンドウを1ページ上へ移動	*i_<S-ScrollWheelUp>*
<ScrollWheelLeft>    ウィンドウを6列左へ移動		*i_<ScrollWheelLeft>*
<S-ScrollWheelLeft>  ウィンドウを1ページ左へ移動	*i_<S-ScrollWheelLeft>*
<ScrollWheelRight>   ウィンドウを6列右へ移動		*i_<ScrollWheelRight>*
<S-ScrollWheelRight> ウィンドウを1ページ右へ移動	*i_<S-ScrollWheelRight>*
CTRL-O		1つコマンドを実行して、挿入モードに戻る      *i_CTRL-O*
CTRL-\ CTRL-O	CTRL-O と同様だがカーソルを移動させない	     *i_CTRL-\_CTRL-O*
CTRL-L		'insertmode' がオンのとき: ノーマルモードへ  *i_CTRL-L*
CTRL-G u	 undo で元に戻す地点を新たに設定	     *i_CTRL-G_u*
-----------------------------------------------------------------------

Note: カーソルキーを押した時に挿入モードから抜けてしまったら、'noesckeys' オプ
ションをチェックする。

CTRL-Oコマンドは時々副作用を生じる: カーソルが行末を越えている場合に、行の最後
の文字の上へ移動してしまうかもしれない。マッピングでは<Esc>を使うのが無難であ
る (まず "x" を入力し、<Esc>を押すとカーソルは常にその文字の上に置かれる)。ま
たは CTRL-\ CTRL-O を使う。しかしその場合はカーソルが行末を越えてしまう可能性
があることに注意。Note: CTRL-\ CTRL-O で実行するコマンドではカーソルを移動する
ことができる。カーソル位置は復元されない。

CTRL-O コマンドではノーマルモードに移動できる。その最中にノーマルモードに再突
入するコマンドを使ってもそれはモードが入れ子になるわけではない。例えば
"a<C-O>a" と入力してから <Esc> を押した場合にはノーマルモードに戻る。<Esc> を
二度タイプする必要はない。タイピングではない方法、例えばマッピングや source し
たスクリプトから実行した時は例外で、モードは入れ子になる。そのため上記の
「"a<C-O>a" と入力してから <Esc>」をマッピングにより入力した場合には、ノーマル
モードではなく挿入モードになる。

Shiftキーを押しながらのカーソルキー操作は、全ての端末で可能なわけではない。

更に副作用として、"i" や "a" コマンドでの回数指定は無視される。そうしないと
CTRL-Oでのコマンドの繰り返しが複雑になってしまう。

CTRL-G u を使う例: >

	:inoremap <C-H> <C-G>u<C-H>

これは undo できるバックスペースキーを再定義している。これで以前の入力を変
更することなく CTRL-O u を使ってバックスペースの結果を元に戻せる。もう一つの
例: >

	:inoremap <CR> <C-]><C-G>u<CR>

これは改行ごとに undo を分割する。また、それを行う前に短縮入力の展開も行う。

CTRL-O は undo 位置を分割する。つまり、その前後に入力したテキストが別々にundo 
されるようになる。これを避けたい場合(マッピングの中などで)は CTRL-R =
|i_CTRL-R| が使えるだろう。例: 関数を呼ぶ: >
	:imap <F2> <C-R>=MyFunc()<CR> 

'whichwrap' オプションが適切に設定されているならば、行の先頭/末尾での<Left>と
<Right>キーは、カーソルを上の行や下の行へ移動させる。

CTRL-G j と CTRL-G k コマンドはカラムの前にテキストを挿入するのに使える。
例: >
   int i;
   int j;
カーソルが最初の "int" にあるとき、"istatic <C-G>j       " と入力するとこうな
る: >
   static int i;
	  int j;
全ての行のカラムに同じテキストを挿入するには矩形ビジュアルコマンド "I" |v_b_I|
を使う。

==============================================================================
3. 'textwidth'と'wrapmargin'オプション			*ins-textwidth*

'textwidth' オプションは入力中の行が長くなりすぎる前に、自動的に改行を行うため
に使うことができる。'textwidth' オプションには望む最大行長を設定する。それを超
えて文字(空白とタブを除く)を入力すると最後の単語が(それがその行の唯一の単語で
無いならば)次の行に置かれる。'textwidth' に0を設定すれば、この機能を無効にする
ことができる。

'wrapmargin' オプションはこれとほとんど同じことをする。違いは 'textwidth' は固
定幅なのに対して、'wrapmargin' はスクリーンの幅に依存する。'wrapmargin' を使用
することは、'textwidth' に(スクリーンのカラム数 - 'wrapmargin' に与えた値)を設
定することに等しい。

'textwidth' と 'wrapmargin' が両方とも設定されていた場合には、'textwidth' が使
用される。

もしも本当には改行をしたくないけれども、見かけ上は具合の良い場所で折り返されて
ほしい場合には、'linebreak' オプションを参照。

自動的に改行されるのは、挿入モードを使用している時か、行に追加している時だけで
ある。置換モードで行の長さが代わらない時には、改行は行われない。

長い行は、マージンを超えて非空白文字を入力すると、改行される。この改行がなされ
る位置は、'formatoptions' オプションに与える文字で制御することが可能である:
"l"  挿入を始めた時に 'textwidth' よりも既に長くない時にだけ、改行を行う。
"v"  現在の挿入コマンドの間に挿入された空白文字の位置でのみ、改行を行う。これ
     はほぼVi互換。
"lv" 挿入を始めた時に 'textwidth' よりも長くない行にだけ、かつその挿入コマンド
     の間に挿入された空白文字の位置でのみ、改行を行う。'textwidth' の境界を越
     えて非空白文字を入力した時に、"l" と違う。

通常は、どこで改行するかを内部関数を使って決定する。この挙動を変えたい場合は、
'formatexpr' に改行を処理する式を設定すること。

テキストのブロックを整形(format)したいならば、"gq" オペレータを使うことができ
る。"gq" に続けて、ブロックの末尾までカーソルを動かす移動コマンドをタイプする。
多くの場合、コマンド "gq}" が、望むこと(段落の最後までを整形)をしてくるだろう。
代わりに、現在カーソルがどこにあるかに関わらず、パラグラフ全体をフォーマットし
てくれるコマンド、"gqap" を使うこともできる。またはビジュアル選択モードを使う
こともできる: "v" を押し、ブロックの最後まで移動し、"gq" とタイプする。|gq|も
参照。

==============================================================================
4. 'expandtab'、'smarttab'それと'softtabstop'オプション	*ins-expandtab*

'expandtab' オプションがオンになっていると、タブ文字は空白文字(スペース)に展開
され、その空白文字が挿入される。もし本当の<Tab>文字を挿入したいのならば、
CTRL-Vを押してから入力する(CTRL-Vに他の動作がマップされているときはCTRL-Qを使
う|i_CTRL-Q|)。
'expandtab' は初期状態でオフになっている。置換モードでは、1文字が複数のスペー
スで置換されることに注意。この結果、行の中の文字数は増える。バックスペースをす
ると、1度に1つの空白が削除される。元々そこにあった文字は、1つのスペース(最後の
1つ)を削除しただけで元に戻される。{Vi には 'expandtab' オプションはない}

							*ins-smarttab*
'smarttab' オプションがオンの時には、1度の<Tab>で、行の先頭で<Tab>を1度押すと
'shiftwidth' の位置まで、その他の場所では 'tabstop' の位置まで空白が挿入され
る。これは<Tab>文字の代わりに、度々スペースが挿入されることを意味している。
'smarttab' がオフの時には、<Tab>では常に 'tabstop' の位置まで空白が挿入され、
'shiftwidth' は ">>" などの時にだけ使用される。{Vi には無い機能}

							*ins-softtabstop*
'softtabstop' オプションが零ではない時、<Tab>は 'softtabstop' で指定されるタブ
位置まで空白を挿入し、<BS>は 'softtabstop' で指定されるタブ位置までの空白を削
除する。これは 'softtabstop' に指定した値を 'tabstop' に設定したのと同様に働く
が、しかし本当の<Tab>文字は依然 'tabstop' の幅に展開されるので、他のアプリケー
ションでそのファイルを使う時にも正しく表示されるだろう。

もしも 'softtabstop' がゼロでないならば、直前に挿入された文字が1つの空白文字
(スペース)で、そのカーソルの直前の(空白)文字だけを削除する時を除き、<BS>は空白
文字を一つ前の 'softtabstop' の位置まで削除しようと試みる。そうでないとカーソ
ルの直前の単一の文字を消すということができなくなってしまう。まず 'softtabstop'
のキャラクタを消してから、それから望む場所にカーソルを持っていくために、余分な
空白文字を置く必要がある。

==============================================================================
5. 置換モード			*Replace* *Replace-mode* *mode-replace*

ノーマルモードで "R" コマンドを使うと置換モードに入る。

置換モードでは、タイプされた全て文字のために行の文字が削除される。消す文字が無
い場合(行末)、タイプされた文字は(挿入モードのように)追加される。このように行末
に至るまで、行内のまとまった数の文字が同じままとどまる。<NL>がタイプされると、
文字は消されずに改行が挿入される。

<Tab>文字には注意。<Tab>のある場所に通常の印刷可能文字をタイプすると、文字数は
同じだけど、見た目上のカラム数はより短くなってしまう。

置換モードで文字を消す(<BS>、CTRL-WもしくはCTRL-U)場合、変更を取り消すことにな
る。置き換えられてしまった文字が復帰する。存在していたテキストよりも多くタイプ
していた場合には、その追加した分は削除される。これは効果的に1度に1文字ずつの
UNDOになる。

'expandtab' オプションがオンの場合、<Tab>は幾つかのスペースで置き換えられる。
結果として行中の文字数は増えることになる。バックスペースは一度に1つの文字を消
す。もともとの文字は1つのスペース(最後の1つ)をバックスペースするだけで戻され
る。{Vi には 'expandtab' オプションはない}

==============================================================================
6. 仮想置換モード		*vreplace-mode* *Virtual-Replace-mode*

ノーマルモードで "gR" コマンドを使うと仮想置換モードに入る。
{|+vreplace| 機能を付けずにコンパイルした場合は利用できない}
{Vi には仮想置換モードはない}

仮想置換モードは置換モードに良く似ているが、ファイルの実際の文字ごとにではな
く、スクリーン上の文字幅単位で置換することができ、そのためファイル内の他の文字
の見た目の位置が移動することはない。

<Tab>をタイプすると通常のキャラクタを幾つか置換し、<Tab>の先頭で文字をタイプし
たならば、<Tab>は以前と同じ場所に存在することになるから、何も置換されないこと
になる。

<NL>をタイプしても、ファイル内の後の文字がその(見かけ上の)位置を変えることはな
い。現在行の残りの部分は<NL>によって置き換えられ(それはつまり、消されるという
こと)、次の行で置換が続行される。ファイルの終端に達するまで、新しい行は挿入さ
れない。

CTRL-TとCTRL-Dを使用したときには面白い効果がある。カーソルの前のキャラクタは普
通に横にシフトされるが、しかしカーソルの後のキャラクタはそのままそこに残ろうと
する。CTRL-Tはシフトされた文字の下にある古い行を隠していくが、CTRL-Dはそれらを
再び表示してくれる。

置換モード同様に、<BS>他を使用すると置換されてしまった文字を戻すことができる。
この機能は 'smartindent', CTRL-TそれにCTRL-D, 'expandtab', 'smarttab',
'softtabstop', その他などが考慮される。

'list' モードで 'cpoptions' に "L" が含まれない時には、仮想置換モードはまるで
'list' モードでないかのように振舞う。

Note: カーソルより後ろの文字が移動して見えることがあるが、それは List モード
|'list'| がオンのとき、そしてまれに 'wrap' がオンのとき (そして変更によって行
の長さがスクリーンの幅より短くなるか長くなるとき) だけである。それ以外では、後
ろの文字が動かないようにスペースが挿入される。

このモードは<Tab>でカラムが区切られた表へ、新しいデータをカラムを揃えて入力す
るような編集作業に便利である。

==============================================================================
7. 挿入モードの補完					*ins-completion*

挿入・置換モードでは、既にタイプしたキーワードや行の一部を補完するコマンドを使
用できる。これは複雑なキーワード(例えば大文字やアンダースコアを含む関数名など)
を使用しているときに便利である。

この機能はコンパイル時に|+insert_expand|機能を有効にしておかないと使用できな
い。

補完には次のような種類がある:

1. 行全体						|i_CTRL-X_CTRL-L|
2. 現在のファイルのキーワード				|i_CTRL-X_CTRL-N|
3. 'dictionary' のキーワード				|i_CTRL-X_CTRL-K|
4. 'thesaurus' のキーワード, thesaurus-style		|i_CTRL-X_CTRL-T|
5. 編集中と外部参照しているファイルのキーワード		|i_CTRL-X_CTRL-I|
6. タグ							|i_CTRL-X_CTRL-]|
7. ファイル名						|i_CTRL-X_CTRL-F|
8. 定義もしくはマクロ					|i_CTRL-X_CTRL-D|
9. Vimのコマンドライン					|i_CTRL-X_CTRL-V|
10. ユーザー定義補完					|i_CTRL-X_CTRL-U|
11. オムニ補完						|i_CTRL-X_CTRL-O|
12. スペリング補完					|i_CTRL-X_s|
13. 'complete' のキーワード				|i_CTRL-N|

これら全て(2の「現在の..」を除く)はCTRL-Xモードで動作する。CTRL-Xモードとは挿
入・置換モードのサブモードである。CTRL-XとCTRL-Xコマンドのどれか1つをタイプす
ることでCTRL-Xモードに移行する。CTRL-Xモードから抜けるにはコマンドとして有効で
はないキーをタイプする。有効なキーとはCTRL-Xコマンドそれ自身、CTRL-N(次の候
補)、そしてCTRL-P(前の候補)である。

マッチの大文字/小文字を調節したいのならばオプション 'infercase' を参照。

							*complete_CTRL-E*
補完が動作中のとき、CTRL-E で補完を中止し、もともと入力したテキストに戻すこと
ができる。CTRL-E は挿入されない。

							*complete_CTRL-Y*
ポップアップメニューが表示されているとき、CTRL-Y で補完を中止し、現在選択され
ている候補を挿入できる。CTRL-Y は挿入されない。スペース、エンターなど
unprintable な文字を入力すると、その文字を挿入して補完モードを終了する。

ポップアップメニューが表示されているときに使える特殊なキーがもういくつかある。
|popupmenu-keys| を参照。

Note: CTRL-Xモードでの有効なキーはマップされない。これは ":map ^F ^X^F" な指定
を可能にする(^Fと^XはそれぞれCTRL-FとCTRL-Xの意味)。これに対して、CTRL-Xモード
を終了させるキー(つまりCTRL-Xモードのコマンドとして有効ではないキー)はマップさ
れる。'complete' を使って補完をするとき、マップは通常通りに適用される。

Note: 補完が動作中は、再帰的に挿入モードに入ることはできない。":normal i.." の
ようなマッピングを使うとエラー E523 が発生する。

次のマッピングは補完コマンドのタイピングをちょっとだけ楽にしようと提案された
(これらは他のコマンドを覆い隠してしまうけれど): >
    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^D ^X^D
    :inoremap ^L ^X^L

例外として、レジスタの値を挿入するCTRL-RはCTRL-Xモードを終了しない。これは主
に '=' レジスタを使って関数などを呼び次の操作を決定することを可能にする。レジ
スタの内容(や '=' レジスタの評価結果)がCTRL-Xモードで無効なキーだった場合、そ
れが入力されたものとしてCTRL-Xモードは終了する。

以下のものは現在の行がスペースだけなら<Tab>を入力し、違うならCTRL-Nの補完をす
る<Tab>をマッピングする例である: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	   endif
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>


行全体を補完する					*compl-whole-line*

							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		現在行のカーソルの前にあるのと同じ文字で始まる行を、後
			方(上方向)に探す。インデントは無視される。見つかった行
			がカーソルの前に挿入される。
			どのバッファから探すのかを決める際に 'complete' オプ
			ションが参照される。読み込まれたバッファ(loaded buffer)
			と読み込まれていないバッファ(unloaded buffer)の両方が
			対象となる。
	CTRL-L	or
	CTRL-P		後方に、次にマッチする行を探す。これによりみつかった行
			で、以前のマッチした行を置き換える。

	CTRL-N		前方に、次のマッチする行を探す。これによりみつかった行
			で以前のマッチした行を置き換える。

	CTRL-X CTRL-L	行を展開した後で再びCTRL-X CTRL-Lをタイプすれば、それ
			に続けて付加的に行を取得でき、CTRL-Xを2回押すことで終
			了する。読み込まれているバッファのみ検索対象となる。
			
現在のファイルのキーワードで補完する			*compl-current*

							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		カーソルの前にあるキーワードで始まる単語を、前方に検索
			する。みつかったキーワードはカーソルの前に挿入される。

CTRL-X CTRL-P		カーソルの前にあるキーワードで始まる単語を、後方に検索
			する。みつかったキーワードはカーソルの前に挿入される。

	CTRL-N		次にマッチするキーワードを前方に検索する。このキーワー
			ドは前回マッチしたキーワードを置き換える。

	CTRL-P		次にマッチするキーワードを後方に検索する。このキーワー
			ドは前回マッチしたキーワードを置き換える。

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	続けてCTRL-X CTRL-NやCTRL-X CTRL-Pを使用することで、
			最後の展開に続けて違うコンテキストで単語を補完すること
			ができる。これはCTRL-Xを2度押すことで終了できる。

カーソルの直前にあるキーワード(アルファベットと 'iskeyword' の文字で構成される
名前)が、直前に "\<" (単語の開始の意味)が補われて検索パターンとして使用される。
キーワードがない場合には "\<\k\k" (少なくとも2文字以上のキーワードの開始位置)
が検索パターンに用いられる。

置換モードでは、置換される文字数はマッチした文字列の長さに依存する。これはマッ
チした文字列を置換モードでタイピングしたのと同じように振舞う。

カーソルの直前に有効なキーワードの文字がなかった場合、少なくとも2文字以上のあ
らゆるキーワードがマッチする。
	例えば、次の結果を得るには:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	このようにタイプする:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

検索はファイルの最後から最初へ循環する。ここでは 'wrapscan' の値は使われない。

同じ補完結果が繰り返される場合にはそれがスキップされる; そのためCTRL-NやCTRL-P
を押すたびに違うマッチ文字列が挿入されることになる(1つしかマッチするキーワード
がない場合は除く)。

マッチ結果が1文字となる補完候補文字列は、通常の使用で実際に補完して欲しいもの
ではないことがほとんどなので、補完候補に含まない。
	例えば、次の結果を得るには:
		printf("name = %s\n", name);
	このようにタイプする:
		printf("name = %s\n", n^P);
	こうでも良い:
		printf("name = %s\n", ^P);
'\n' の中の文字 'n' はスキップされる。

単語補完を開始した後で、補完済み単語に続く単語を検索するのに、CTRL-X CTRL-Pも
しくはCTRL-X CTRL-Nを使うことができる。これらのシーケンスはテキストから探さ
れ、単語を拡張補完し、さらに拡張補完していくことができる。これは複雑な単語の
シーケンスを繰り返す必要があるときに役に立つ。CTRL-PとCTRL-Nは少なくとも2文字
以上の文字列を探すけれども、CTRL-X CTRL-PとCTRL-X CTRL-Nは1文字の文字列も探し
出す。
	例えば、次の結果を得るには:
		M&eacute;xico
	このようにタイプする:
		M^N^P^X^P^X^P
CTRL-Nは補完を開始し、CTRL-Pで最初の1文字 "M" に戻し、次の2つのCTRL-X CTRL-Pが
"&eacute" と ";xico" を得る。

直前の補完が 'textwidth' よりも長いために分裂している場合、現在の行のテキスト
だけが使用される。

マッチ文字列が行末で見つかった場合には、次の行の最初の単語が挿入され "word
from next line" というメッセージが表示される。さらに続けてCTRL-X CTRL-Pもしく
はCTRL-X CTRL-Nで検索を行うと、その単語のある行で続く文字が検索される。


'dictionary'のキーワードで補完する			*compl-dictionary*

							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		カーソルの直前のキーワードで始まる単語をオプション
			'dictionary' で与えられたファイルから検索する。これは
			CTRL-Nに似ているが、現在のファイル内は検索せずに辞書
			ファイル内だけを検索する。見つけたキーワードはカーソル
			の直前に挿入される。最初のマッチが使用される前に全ての
			マッチが検索されるので、かなり遅くなる可能性がある。オ
			プション 'dictionary' の初期値は空である。
			どこから単語リストを見つけ出すかについては、オプション
			'dictionary' を参照。

	CTRL-K	or
	CTRL-N		マッチするキーワードの前方検索。直前にマッチしたキー
			ワードは新しいもので置き換えられる。

	CTRL-P		マッチするキーワードの後方検索。直前にマッチしたキー
			ワードは新しいもので置き換えられる。

							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		CTRL-X CTRL-Kと同じだが、'dictionary' ではなく
			'thesaurus' オプションを使う。たとえ単語が完全でなくて
			も、類語ファイルの中に単語が見つかると、その行の他の単
			語も一致とみなされる。したがって単語は完全に置き換えら
			れる。

			例えば、'thesaurus' ファイルにこのような行があるとし
			て: >
				angry furious mad enraged
<			カーソルが "ang" の後にあり、CTRL-X CTRL-Tを押すと
			"angry" が補完される。続けて補完すると
			"furious"、"mad"、...、と置き換えられる。
			他にも二つの言語間の単語の置き換えや、API関数をキー
			ワードによってグループ分けするのに使える。

	CTRL-T	or
	CTRL-N		次のキーワードを前方に探す。見つかったキーワードはそ
			の前のキーワードを置き換える。

	CTRL-P		次のキーワードを後方に探す。見つかったキーワードはそ
			の前のキーワードを置き換える。


編集中と外部参照しているファイルのキーワードで補完する	*compl-keyword*

'include' オプションは外部参照(インクルード)ファイルを含む行を指定するのに使
う。'path' オプションはインクルードファイルを探す場所を指定するのに使う。

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		カーソルの直前と同じ文字で始まる最初のキーワードを、現
			在のファイルとインクルードファイルから探し出す。マッチ
			したキーワードはカーソルの直前に挿入される。

	CTRL-N		次にマッチするキーワードを前方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。
			Note: CTRL-Iは補完が成功した時に入力する<Tab>と同じで
			ある。従ってCTRL-Iを次のマッチを探すために使用すること
			はできない。

	CTRL-P		次にマッチするキーワードを後方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。

	CTRL-X CTRL-I	直前の補完の文脈で続けてCTRL-X CTRL-Iによる単語補完を
			行う。2連CTRL-Xが使用されるまで続く。


タグで補完する						*compl-tag*
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		カーソルの直前と同じ文字で始まる最初のタグを探し出す。
			マッチしたタグはカーソルの直前に挿入される。アルファ
			ベットと 'iskeyword' で指定される文字が、タグ名にどの
			文字が含まれるかを決定する(これはキーワードと同じルー
			ル)。|CTRL-]|も参照。'showfulltag' オプションはタグ定
			義の周辺からコンテキストに含めるために使用される。
	CTRL-]	or
	CTRL-N		次にマッチするタグを前方検索する。直前にマッチしたタグ
			は新しいもので置き換えられる。

	CTRL-P		次にマッチするタグを後方検索する。直前にマッチしたタグ
			は新しいもので置き換えられる。


ファイル名で補完する					*compl-filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		カーソルの直前と同じ文字で始まる最初のファイル名を探し
			出す。マッチしたファイル名はカーソルの直前に挿入され
			る。アルファベットと 'isfname' で指定される文字が、ファ
			イル名にどの文字が名前に含まれるかを決定する。Note: こ
			の段階では(まだ) 'path' オプションは使用されない。
	CTRL-F	or
	CTRL-N		次にマッチするファイル名を前方検索する。直前にマッチし
			たファイル名は新しいもので置き換えられる。


	CTRL-P		次にマッチするファイル名を後方検索する。直前にマッチし
			たファイル名は新しいもので置き換えられる。


定義もしくはマクロで補完する				*compl-define*

定義を含んだ行を特定するのに 'define' オプションが使用される。インクルードファ
イルを含んだ行を特定するのに 'include' オプションが使用される。インクルードファ
イルを探すのに 'path' オプションが使用される。

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		カーソルの直前と同じ文字で始まる最初の定義(もしくはマ
			クロ)名を、現在のファイルとインクルードファイルから探
			し出す。マッチした定義名はカーソルの直前に挿入される。
	CTRL-D	or
	CTRL-N		次にマッチするマクロ名を前方検索する。直前にマッチした
			マクロ名は新しいもので置き換えられる。

	CTRL-P		次にマッチするマクロ名を後方検索する。直前にマッチした
			マクロ名は新しいもので置き換えられる。

	CTRL-X CTRL-D	直前の補完の文脈で続けて CTRL-X CTRL-D による単語補完
			を行う。2連 CTRL-X が使用されるまで続く。

Vimコマンドの補完					*compl-vim*

補完は文脈に左右される。コマンドラインでの入力時のように機能する。Exコマンドと
その引数も補完する。これは Vim スクリプトを書いているときに便利である。

							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		カーソルの前に何があるかを推測し、最初に一致するもの
			を探す。
			Note: CTRL-Vがマッピングに使われていれば、たいていは
			CTRL-Qが代わりに使える|i_CTRL-Q|。
	CTRL-V or
	CTRL-N		次の一致を前方に探す。そしてその前のものを置き換え
			る。

	CTRL-P		次の一致を後方に探す。そしてその前のものを置き換え
			る。

	CTRL-X CTRL-V	加えて言うと CTRL-X CTRL-V は CTRL-V と同じように働
			く。これはVimコマンドの補完をマッピングをするのに使
			える。例えば: >
				:imap <Tab> <C-X><C-V>

ユーザー定義補完						*compl-function*

ユーザー定義補完は、オプション 'completefunc' で設定した関数(ユーザー定義関数
でもよい)によって補完する方法である。この関数がどう呼び出されるかについては後
述。また |complete-functions| の例を参照。

							*i_CTRL-X_CTRL-U*
CTRL-X CTRL-U		カーソルの前にどの種類の項目があるか推測し、最初の候補
			を探す。
	CTRL-U	または
	CTRL-N		次の候補を選択し、現在の候補と置き換える。

	CTRL-P		前の候補を選択し、現在の候補と置き換える。

オムニ補完						*compl-omni*

オムニ補完は、オプション 'omnifunc' で設定した関数(ユーザー定義関数でもよい)に
よって補完する方法である。ファイル形式に特化した補完をするために使われる。

この関数がどう呼び出されるかについては後述。また |complete-functions| も参照。
特定のファイル形式についての説明は |compl-omni-filetypes| を参照。
今後、www.vim.org でより多くの補完スクリプトが公開されるだろう。現在のところ、
C++ 用の最初のバージョンが存在する。

							*i_CTRL-X_CTRL-O*
CTRL-X CTRL-O		カーソルの前にどの種類の要素があるか推測し、最初の候補
			を探す。
	CTRL-O	または
	CTRL-N		次の候補を選択し、現在の候補と置き換える。

	CTRL-P		前の候補を選択し、現在の候補と置き換える。


スペリング補完						*compl-spelling*

カーソル前、またはカーソル位置の単語を探しだし、正しい単語の候補に置換する。カ
レント行のカーソル位置以前にスペルの間違った単語が存在する場合、カーソルがその
単語の直後に移動する。間違った単語が存在しない場合はカーソルの直前の単語(その
単語が間違っていなくても)の訂正候補が表示される。

NOTE: Unix 端末の多くでは CTRL-S は画面をサスペンドさせるため、代わりに 's' を
使うこと。サスペンドした画面を元に戻すには CTRL-Q を押す。

						*i_CTRL-X_CTRL-S* *i_CTRL-X_s*
CTRL-X CTRL-S   または
CTRL-X s		カーソル前の単語を探し、その単語の正しい綴りの候補を探
			す。
	CTRL-S	または
	CTRL-N		次の候補を選択する。これによって以前の候補は置換される。
			Note ここでは代わりに 's' は使えないことに注意。

	CTRL-P		前の候補を選択する。これによって以前の候補は置換される。


キーワードを別のソースから補完する。			*compl-generic*

							*i_CTRL-N*
CTRL-N			カーソルの直前と同じ文字で始まる単語を、'complete' オ
			プションで指定された場所から後方検索する。マッチした
			キーワードはカーソルの直前に挿入される。

							*i_CTRL-P*
CTRL-P			カーソルの直前と同じ文字で始まる単語を、'complete' オ
			プションで指定された場所から前方検索する。マッチした
			キーワードはカーソルの直前に挿入される。

	CTRL-N		次にマッチするキーワードを前方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。

	CTRL-P		次にマッチするキーワードを後方検索する。直前にマッチし
			たキーワードは新しいもので置き換えられる。

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	直前の補完の文脈で続けて CTRL-X CTRL-N もしくは CTRL-X
			CTRL-P による単語補完を行う。2連 CTRL-X が使用されるま
			で続く。


補完候補を検索する関数					*complete-functions*

ここでは 'completefunc' と 'omnifunc' について説明する。

これらの関数は次の2通りの形で呼ばれる:
- 最初に、補完するテキストの始点を見つけるために呼ばれる。
- 次に実際に候補を検索するために呼ばれる。

最初の形での呼び出しでは、次の引数が与えられる:
   a:findstart  1
   a:base	empty

これらの関数は補完するテキストの始点の桁番号を返す責任を負う。桁番号は 0 以上
"col('.')" 未満でなければならない。カーソル直前の文字列を見て、補完候補の一部
となりうる文字を含める処理が必要となる。この桁とカーソル位置の間のテキストが補
完され、候補で置き換わることになる。

特別な戻り値:
   -1 補完を行えない場合。補完はキャンセルされ、エラーメッセージが表示される。
   -2 メッセージなしでキャンセルし、補完モードに留まりたい場合。
   -3 メッセージなしでキャンセルし、補完モードから抜けたい場合。

2番目の形での呼び出しでは、次の引数が与えられる:
   a:findstart  0
   a:base	補完対象のテキスト。つまり最初の呼び出しで指定したテキスト(空
		文字列の場合もありうる)

これらの関数は見つかった候補のリストを返す責任を負う。通常、候補の中には
"a:base" そのものも含まれている。候補が存在しない場合は空リストを返すこと。

補完候補以外の情報を返したいときはそのリストを持った辞書を返す。辞書には以下の
アイテムを含めることができる:
	words		補完候補のリスト (必須)
	refresh		関数の再呼び出しを制御する文字列 (オプション)
			現在有効な値は "always" だけである。"always" を指定す
			ると、補完対象のテキストが変更されるたびに補完関数が呼
			ばれるようになる。
その他のアイテムは無視される。

補完後に何かを実行したい場合はオートコマンドの |CompleteDone| イベントを使う。

例えば、次のようにして使う: >
	let matches = ... list of words ...
	return {'words': matches, 'refresh': 'always'}
<
						*complete-items*
リストの各要素は文字列か辞書のどちらかであること。文字列の場合はそれが候補とな
る。辞書の場合は以下の要素を含んでいること:
	word		挿入されるテキスト。必須
	abbr		"word" の略。これが空でなければ、メニューで "word" の
			代わりに表示される。
	menu		ポップアップメニューにおける追加情報。"word" または
			"abbr" の後に表示される。
	info		この要素についての追加情報。プレビューウィンドウに表示
			することができる。
	kind		候補の種類を表す1文字
	icase		0 でないならば、候補同士を比較するとき大文字小文字は無
			視される。省略された場合は 0 となり、大文字小文字の違
			いしかない候補も追加される。
	dup		0 でないならば、すでに同じ候補があってもこの候補を追加
			する。
	empty		0 でないならば、空文字であってもこの候補を追加する。

これらのうち 'icase'、'dup'、'empty' 以外は文字列でなければならない。これらの
要件が満たされない場合はエラーメッセージが表示され、リスト中のそれ以降の要素は
無視される。リストの中で文字列と辞書が混在していてもよい。

"menu" はポップアップメニューに表示される。長すぎる場合は切り詰められるので、
短くするとよい。"info" は 'completeopt' に "preview" が含まれている場合にプ
レビューウィンドウに表示される。これはもっと長くてもよい。"info" はまた、ポッ
プアップメニューが消えた後にもそのまま表示される。これは関数の引数を表示する
場合などに便利である。"info" にスペース1個を指定すると、プレビューウィンドウ
に表示されているテキストが消去される。プレビューウィンドウの大きさは 3 行だ
が、'previewheight' が 1 か 2 のときはその高さで表示される。

"kind" は候補の種類を示す1文字である。候補の表示方法(色やアイコンなど)を区別
するために使われる。
現在のところ、指定可能な種類は次の通りである:
	v	変数
	f	関数やメソッド
	m	構造体やクラスのメンバ
	t	typedef
	d	#define やマクロ

候補の検索に時間がかかるときは |complete_add()| を使って候補を1つずつリスト
に加えるとよい。その場合、それらの候補は戻り値のリストに現れるべきではない。
ときどき |complete_check()| を呼んで、候補の検索中にユーザーがキーを押して検索
を中断できるようにすること。complete_check() が非 0 を返すと中断する。

							*E839* *E840*
関数の中でカーソルを移動させてもよい。カーソルは実行後に復元される。
関数の中で他のウィンドウに移動したりテキストを削除することはできない。

月の名前を補完する例: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " 単語の始点を検索する
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " "a:base" にマッチする月を探す
	    let res = []
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call add(res, m)
	      endif
	    endfor
	    return res
	  endif
	endfun
	set completefunc=CompleteMonths
<
検索が遅い場合のシミュレーション: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " 単語の始点を検索する
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " "a:base" にマッチする月を探す
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' . a:base
		call complete_add(m)
	      endif
	      sleep 300m	" 次の候補の検索をシミュレートする
	      if complete_check()
		break
	      endif
	    endfor
	    return []
	  endif
	endfun
	set completefunc=CompleteMonths
<

補完ポップアップメニュー				*ins-completion-menu*
							*popupmenu-completion*
候補を簡単なポップアップメニューで表示することができる。

ポップアップメニューは次のとき表示される:
- 'completeopt' が "menu" か "menuone" を含んでいる。
- 端末が 8 色以上の表示をサポートしている。
- 候補が 2 個以上ある。"menuone" を設定している場合は 1 個以上。

ポップアップメニューの高さの最大値はオプション 'pumheight' で設定できる。既
定値は利用可能なスペースをすべて使うようになっている。

ポップアップメニューには 3 つの状態がある:
1. 候補が挿入された状態。例えば CTRL-N や CTRL-P の後。
2. カーソルキーを使って他の候補を選択した後。候補はまだ挿入されていなく、1
   つの候補が強調表示されている状態。
3. 候補の一部だけが挿入されており、文字の入力やバックスペースキーを使用でき
   る状態。カーソルの前にある文字列によって候補のリストが増減する。

普通、最初は1番目の候補が挿入された状態(状態1)から始まる。'completeopt'
に "longest" が含まれており、2 個以上の候補があるときは状態3から始まる。

CTRL-N や CTRL-P を押すことなどによって他の候補を選択すると状態1へ遷移す
る。このとき候補のリストは変化しない。

元のテキストへ戻ると状態3になる。すぐに状態3へしたい場合は、次のように補完の直
後に CTRL-P を行うマッピングを使えばよい: >
	:imap <F7> <C-N><C-P>
<
						*popupmenu-keys*
状態1では以下のキーは特別な意味を持つ:
<BS> と CTRL-H   1文字削除し、カーソル前の単語の候補を検索する。これによって候
		 補の数は少なくなり、しばしば1個だけになって状態2へ遷移する。
特殊文字でない任意の文字:
		 候補を変更せずに補完を停止し、入力された文字を挿入する。

状態2と状態3では以下のキーは特別な意味を持つ:
<BS> と CTRL-H   1文字削除し、カーソル前の(短くなった)単語の候補を検索する。候
		 補の数は増える。
CTRL-L		 現在の候補から1文字を挿入する。候補の数は少なくなる。
印字可能で空白文字でない任意の文字:
		 その文字を挿入する。候補の数は少なくなる。

以上すべての状態で以下のキーが使える: 
CTRL-Y		  Yes: 現在選択されている候補に決定し、補完を終了する。
CTRL-E		  補完を終了し、候補を選択する前の状態(タイプした状態または最
		  長共通文字列)へ戻る。
<PageUp>	  数個上の候補を選択するが、挿入はしない。
<PageDown>	  数個下の候補を選択するが、挿入はしない。
<Up>		  CTRL-P と同様に上の候補を選択するが、挿入はしない。
<Down>		  CTRL-N と同様に下の候補を選択するが、挿入はしない。
<Space> or <Tab>  候補を変更せずに補完を終了し、タイプされた文字を挿入する。

<Enter>キーの挙動は状態に依存する:
状態1:		テキストはそのままにし、改行を挿入する。
状態2:		選択されている候補を挿入する。
状態3:		テキストはそのままにし、改行を挿入する。

言い換えると: カーソルキーでリストから他の候補を選択した後 <Enter> を押すとそ
の候補を挿入する。それ以外をタイプした後で <Enter> を押すと改行が挿入される。


メニューの色は以下のハイライトグループで設定できる:
Pmenu		通常の要素  |hl-Pmenu|
PmenuSel	選択されている要素  |hl-PmenuSel|
PmenuSbar	スクロールバー  |hl-PmenuSbar|
PmenuThumb	スクロールバーのつまみ |hl-PmenuThumb|

ポップアップメニューが表示されているとき用の特別なマッピングというものは存在し
ない。しかし挿入モードマッピングで関数 |pumvisible()| を使えばポップアップメ
ニューが表示されているときだけ用にマッピングを作ることができる。例: >
	:inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>

マッピングで <expr> を使うと、入力中ある条件が満たされたとき自動的にポップアッ
プメニューを表示させることができる。例えば、ドットを入力したとき補完を行う、ま
たはドットそのものを入力するようにするには: >
	inoremap <expr> . MayComplete()
	func MayComplete()
	    if (can complete)
	      return ".\<C-X>\<C-O>"
	    endif
	    return '.'
	endfunc

より詳しくは |:map-<expr>| を参照。

オムニ補完についてファイル形式ごとの注意点	    *compl-omni-filetypes*

ファイル形式 {filetype} に対して使われるファイルは 'runtimepath' 中の
{filetype}complete.vim とする。つまり、"java" に対するファイルは
autoload/javacomplete.vim となる。


C							*ft-c-omni*

C のソースでオムニ補完を行うには tags ファイルが必要である。Exuberant ctags は
補完に必要な付加情報を出力するため、Exuberant ctags を使うとよい。Exuberant
ctags はこのサイトからダウンロードできる: http://ctags.sourceforge.net/
バージョン 5.6 以降が推奨されている。

バージョン 5.5.4 を使うときは "typename:" フィールドを追加するこのパッチをあて
ること:
	ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch
MS-Windows 用の exe ファイルは次のサイトからダウンロードできる:
	http://georgevreilly.com/vim/ctags.html

システム関数を補完するには、次のような方法がある。ctags を使って全システムヘッ
ダファイルの tags ファイルを作る: >
	% ctags -R -f ~/.vim/systags /usr/include /usr/local/include
そして .vimrc で 'tags' オプションにこの tags ファイルを追加する: >
	set tags+=~/.vim/systags

カーソル前の単語が "." や "->" を含まないとき、CTRL-X CTRL-O を押すと tags 
ファイルから直接補完される。これはすべての識別子、関数名に対して有効である。
tags ファイルに含まれないローカル変数名を補完するには CTRL-P を使うしかない。

カーソル前の単語が "." または "->" を含むとき、CTRL-X CTRL-O を押すと、変数の
型が推測され、その型のメンバが推測される。よって、その変数に対して有効なメンバ
だけが補完候補に現れる。

メンバ名がすでに補完されたとき CTRL-X CTRL-O を押すと、複合型に対する "." また
は "->" が挿入される。

Vim は C コンパイラを内蔵しているわけではないので、きれいに整形された宣言しか
認識できない。プリプロセッサが関係すると混乱してしまう可能性がある。同じ構造体
名が複数の場所に現れる場合、それらのすべてのメンバが補完候補に含まれる。


CSS							*ft-css-omni*

CSS 2.1 仕様に従って、プロパティとその適切な値を補完できる。


HTML							*ft-html-omni*
XHTML							*ft-xhtml-omni*

HTML, XHTML ファイルにおいて、CTRL-X CTRL-O で (X)HTML の色々な要素を補完でき
る。補完スクリプトは XHTML 1.0 Strict なファイルを書くために設計されているが、
他の HTML のバージョンに対しても動作するようになっている。以下の機能がある:

- "<" の後では文脈に依存してタグ名を補完する(a タグの内側では div は候補に現れ
  ない)。'/>' は空タグを示す。
- タグの内側では適切な属性の補完が行われる(a タグに対しては width 属性は候補に
  現れない)。属性の型も表示される。'*' は必須な属性を意味する。
- 属性のとりうる値が有限個しかない場合は、それらの補完を支援する。
- エンティティの名前を補完する。
- <style> タグとインクルードされた CSS ファイルから得られたデータにより、
  "class" と "id" の値を補完する。
- "style" 属性の値を補完するときや、"style" タグの内側にいるときは
  |ft-css-omni| モードへ移行する。
- イベント属性の値を補完するときや、"script" タグの内側にいるときは
  |ft-javascript-omni| モードへ移行する。
- "</" の後で CTRL-X CTRL-O を押すと、最後に開いたタグを閉じる。

Note: 初回実行時は補完メニューが表示されるまでに少し時間がかかる。
- これはデータファイルを読み込むのに時間がかかっている。
Note: 整形されていないファイルでは補完が失敗する場合がある。その場合は |:make|
を実行して整形上の問題を検出してみるとよい。

HTML flavor						*html-flavor*

既定の HTML 補完はファイルタイプに依存して動作が変わる。HTML ファイル
('filetype' が "html" の場合) に対しては HTML 4.01 Transitional となり、XHTML
ファイル ('filetype' が "xhtml" の場合) に対しては XHTML 1.0 Strict となる。

タグの外側で補完を行うと DOCTYPE を選択することができ、適切なデータファイルが
読み込まれ、それ以降の補完に利用される。

データファイルのフォーマットについてより詳しくは |xml-omni-datafile| を参照。
Vim のウェブサイト(|www|)でもいくつかのデータファイルをダウンロードできる。

Note: 変数 b:html_omni_flavor に任意の XML データのファイル名を設定できる。こ
れによってPHPオムニ補完(|ft-php-omni|)と任意の XML ダイアレクトを組み合わせる
ことができる(その XML ダイアレクト用のデータファイルが必要)。この変数を設定し
ない場合は XHTML 1.0 Strict が使用される。


JAVASCRIPT					       *ft-javascript-omni*

JavaScript のほとんどの要素と DOM 要素を補完できる。

補完:

- 変数
- 関数名。関数の引数も表示できる
- 関数の引数
- 変数の型を識別し、変数のプロパティを補完する
- DOM オブジェクトと文脈に依存したプロパティを補完する
- 言語のキーワード

JavaScript オムニ補完は、単独の JavaScript ファイル(&ft==javascript)、(X)HTML
の <script> タグの中、イベント属性の値の中で動作する(外部ファイルの読み込みも
含む)。

DOM 互換性

現時点(2006 年初頭)では主流のブラウザが2つある。MS Internet Explorer と
Mozilla Firefox である。これら2つのアプリケーションは市場の 90% 以上を占めてい
る。理論的には標準は W3C (http://www.w3c.org) によって決められるが、これらのブ
ラウザは必ずしもそれに従っていない。

		IE	FF	W3C  オムニ補完 ~
		+/-	+/-	+    +		     ~
		+	+	-    +		     ~
		+	-	-    -		     ~
		-	+	-    -		     ~

ブラウザの実装状態に関わらず、ある要素が標準で定められていれば、オムニ補完プラ
グインはその要素を候補リストに加える。主流のエンジンが両方ともある要素を実装し
ていれば、たとえそれが標準で定められていなくても候補リストに加える。それ以外の
要素は候補リストに加えない。


PHP							*ft-php-omni*
PHP コードの補完を行うには tags ファイルが必要である。外部ファイルに書かれた情
報の補完と、クラスを意識した補完のためである。Exuberant ctags 5.5.4以降を使う
こと。Exuberant ctags は次のサイトで入手できる:
http://ctags.sourceforge.net/


オムニ補完で以下のものが補完できる:

- $ の後の変数名
  - 変数がオブジェクトとして宣言されており、"->" がつく場合、tags ファイルがあ
    ればクラス名が表示される。
  - "->" の後ではそのクラスの関数名と変数名だけが候補に現れる。クラスの位置と
    内容を特定するためには tags ファイルが必要になる。PHP は強い型付けの言語で
    はないため、クラス宣言に @var タグをつけるとよい : >

	/* @var $myVar myClass */
	$myVar->
<
    しかし @var タグをつけても、myClass の内容を認識するには tags ファイルが必
    要になる。

- 追加情報つきの関数名
  - 組み込み関数の場合には、とりうる引数のリストと、| の後に関数の戻り値の型情
    報が表示される。
  - ユーザー定義関数の場合には、引数と、その関数の定義を含むファイル名が表示さ
    れる(それがカレントファイルでない場合)

- 定数名
  - "new" 宣言の後にクラス名

Note: 最初に補完を行うとき、必要なデータがすべてメモリにロードされる。これに数
秒かかる場合があるが、次回からの補完は気になるほどではなくなるだろう。

補完スクリプトは、カーソルが<?php ?>の中にあるかどうかを検出する。もしカーソル
がこのタグの外側にあれば、自動的に HMTL/CSS/JavaScript 補完に切り替わる。Note: 
元の HTML とは異なり、タグの補完が文脈依存ではなくなる。

RUBY							*ft-ruby-omni*

Ruby コードの補完を行うには、vim が |+ruby| 付きでコンパイルされている必要があ
る。

Ruby のオムニ補完は、補完候補を提供するために必要に応じてバッファをパースする。
補完候補は 'require' で読み込まれたモジュールと、カレントバッファ内で定義され
たモジュールから引き出される。

CTRL-X CTRL-O による補完は、次のように文脈に依存する:

	  文脈				   提供される補完 ~

1. クラス定義の外側			クラス、定数、グローバル変数

2. クラス定義の内側			そのクラスで定義されたメソッド、定数

3. '.', '::', ':' の後			参照されているオブジェクトに適用可能な
					メソッド

4. ':', ':foo' の後			シンボル名(:foo の場合は 'foo' で始ま
					るもの)

Note:
 - 補完を行うためにコードをロードする(評価する)機能がある。これはつまり、コー
   ドが実行されることになり、問題となるかもしれない。現在、この機能はデフォル
   トで無効になっており、有効にするには次を .vimrc に加える: >
     let g:rubycomplete_buffer_loading = 1
<- 上記の文脈 1 において、クラスのリストを補完結果に加えるためにバッファ全体を
   パースすることがありうる。デフォルトではこの機能は無効になっており、有効に
   するには次を .vimrc に加える: >
     let g:rubycomplete_classes_in_global = 1
<- 上記の文脈 2 において、無名クラスには対応していない。
 - 上記の文脈 3 において、Vim はオブジェクトが対応しているメソッドを決定しよう
   と試みる。
 - Rails プロジェクトのファイルでは Rails 環境を検出し、読み込む機能がある。
   デフォルトではこの機能は無効になっており、有効にするには次を .vimrc に加え
   る: >
     let g:rubycomplete_rails = 1
<


SYNTAX							*ft-syntax-omni*

Vim には 500 近くの言語を強調表示する機能がある。この強調表示機能の一部として、
言語で定められたキーワードを認識する機能がある。多くのファイルタイプには既に専
用の補完スクリプトが存在するが、そうでないファイルタイプのために構文強調機能を
利用して基本的な補完機能を提供する syntaxcomplete というプラグインがある。この
プラグインは、Vim がテキストを色付けするために持っている情報を利用して補完リス
トを作成する。syntaxcomplete はどんなファイルタイプに対しても利用可能で、言語
に応じた最小限の補完を提供する。

syntaxcomplete を有効にするにはこのコマンドを実行する: >
	setlocal omnifunc=syntaxcomplete#Complete

これを自動的に行うようにするには、以下を ~/.vimrc に書く(":filetype" コマンド
の後で): >
    if has("autocmd") && exists("+omnifunc")
	autocmd Filetype *
		    \	if &omnifunc == "" |
		    \		setlocal omnifunc=syntaxcomplete#Complete |
		    \	endif
    endif

これによって、ファイルタイプ専用のプラグインが存在しないときだけ
syntaxcomplete プラグインで補完するようになる。

ファイルタイプの中には幅広い範囲の構文アイテムを持つものもある。
syntaxcomplete プラグインでは、構文グループのうちどれを補完に含めるかをカスタ
マイズできる。ファイルタイプ PHP を例として見てみよう。

index.php という名前のファイルを開き、次のコマンドを実行してみる: >
	:syntax list

まず最初にたくさんの異なる構文グループがあることに気づくだろう。PHP 言語は
HTML, JavaScript など他の言語の要素を含むことがある。この場合、syntaxcomplete
プラグインはファイルタイプ名 "php" で始まる構文グループだけを含める。例えば、
次の構文グループはデフォルトで含まれる: phpEnvVar, phpIntVar, phpFunctions。

PHP 言語は構文強調で色付けできる要素がとてもたくさんある。これはつまり、非常に
多数の要素がオムニ補完リストに現れることを意味する。人によってはこれがわずらわ
しいと感じたり、一部だけにしか関心がないかもしれない。

このリストから余分なものを除くには 2 つの方法がある。ある構文グループを表示さ
せたくない場合は、次を .vimrc に加えるとよい: >
	let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'

カンマ区切りで任意個数の構文グループを指定できる。この変数の基本的な形式は次の
とおり: >
	let g:omni_syntax_group_exclude_{filetype} = 'comma,separated,list'

完全性のために、逆もできるようになっている。~/.vimrc で次の変数を定義すると、
構文グループ phpFunctions と phpMethods に含まれる要素だけがリストに現れるよう
になる: >
	let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'

この変数名の末尾のファイルタイプを変えればいくらでもこの変数を定義できる。

syntaxcomplete プラグインは、構文アイテムの単語境界の認識にオプション
'iskeyword' を使用する。例として、Scheme 言語の補完では "-" が単語に含まれる
(call-with-output-file など)。ファイルタイプによってはこれでは期待する補完がで
きないかもしれない。g:omni_syntax_use_iskeyword に 0 を代入すれば
syntaxcomplete プラグインは単語文字の区切りを使わなくなる: >
    let g:omni_syntax_use_iskeyword = 0


プラグイン開発者のために OmniSyntaxList 関数が公開されている。この関数は構文ア
イテムのリストを得るために使うことができる。例えば SQL ファイルを開いていると
きに (:e syntax.sql) ":syntax list" コマンドを実行してグループと構文アイテムを
確認してみる。例: >
    syntax list 

次のような出力が表示される: >
    sqlOperator    xxx some prior all like and any escape exists in is not 
                       or intersect minus between distinct
                       links to Operator
    sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier 
                       date money long tinyint unsigned xml text smalldate 
                       double datetime nchar smallint numeric time bit char 
                       varbinary binary smallmoney
                       image float integer timestamp real decimal

二つの構文グループ sqlOperator と sqlType がある。構文アイテムのリストを得るた
めに OmniSyntaxList をいくつかの方法で呼び出すことができる。構文グループを限定
せずにすべての構文アイテムを得るには次のようにする: >
    echo OmniSyntaxList( [] )

sqlOperator 構文グループの構文アイテムの得るには次のようにする: >
    echo OmniSyntaxList( ['sqlOperator'] )

sqlOperator 構文グループと sqlType 構文グループの両方の構文アイテムをすべて得
るには次のようにする: >
    echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )

プラグインから呼び出すときは、結果を List に代入して使うのが一般的だろう: >
    let myKeywords = []
    let myKeywords = OmniSyntaxList( ['sqlKeyword'] )



SQL							*ft-sql-omni*

SQL の補完にはステートメント、関数、キーワードが含まれる。また、データベースか
ら直接情報を取得し、テーブル、プロシージャ、ビュー、カラムリストを動的に補完す
ることができる。より詳しい説明とチュートリアルについては |omni-sql-completion|
を参照。

SQL 補完プラグインは他の補完プラグインと組み合わせて使うことができる。例えば、
PHP にはPHP 用の補完スクリプトがあるが、PHP はよくデータベースにアクセスする動
的なウェブサイトを生成するのに使われるため、SQL 補完プラグインも有効にするとよ
いかもしれない。そうすれば PHP のコードと SQL のコードを両方補完できるようにな
る。


XML							*ft-xml-omni*

Vim 7 には XML ファイルにおける文脈に応じた補完メカニズムがある。この補完メカ
ニズムは特別なファイル |xml-omni-datafile| に依存し、|:XMLns| と |:XMLent| と
いう 2 つのコマンドがある。この補完の機能は以下の通り:

- "<" の後ろでは文脈に応じ、タグ名を補完する。
- タグの内側では適切な属性を補完する。
- 属性の取りうる値が有限個である場合はそれらの補完を支援する。
- 実体名を補完する(|xml-omni-datafile| 内で定義されたものとカレントファイルの
  "<!ENTITY" 宣言にあるもの)
- "</" の後ろで CTRL-X CTRL-O とすると最後に開いたタグを閉じる。

XML データファイルのフォーマット			*xml-omni-datafile*

XML データファイルは 'runtimepath' の中のディレクトリ "autoload/xml" に保存さ
れる。標準でディレクトリ "$VIMRUNTIME/autoload/xml" にデータファイルのサンプル
が入っている。これらのファイルにはコマンドで指定できる意味のある名前がついてい
る。XML データファイルは衝突が起きないように一意な名前をつけるべきである。例え
ば、xhtml10s.vim という名前は XHTML 1.0 Strict 用のデータファイルであることを
意味している。

各サンプルファイルには g:xmldata_xhtml10s のような名前の変数が含まれている。こ
の変数の値は2つの部分からなる:

1. "g:xmldata_" 一般的なプリフィックス。全データファイルで共通。
2. "xhtml10s"   ファイル名であり、記述された XML ダイアレクトの名前。この名前
   がコマンド |:XMLns| の引数として使われる。

2. は正確にファイル名と同じでなければならない。

この変数は辞書 |Dictionary| である。キーはタグ名で、値は2個の要素を持つリスト
である。リストの最初の要素はまたリストであり、有効な子ノードの名前を持つ。2番
目の要素は辞書 |Dictionary| であり、属性名がキーで、その属性の取りうる値が値で
ある。例: >

    let g:xmldata_crippled = {
    \ "vimxmlentities": ["amp", "lt", "gt", "apos", "quot"],
    \ 'vimxmlroot': ['tag1'],
    \ 'tag1':
    \ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],
    \ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],
    \ 'childoftag1a':
    \ [ [], {'attrofchild': ['attrofchild']}],
    \ 'childoftag1b':
    \ [ ['childoftag1a'], {'attrofchild': []}],
    \ "vimxmltaginfo": {
    \ 'tag1': ['Menu info', 'Long information visible in preview window']},
    \ 'vimxmlattrinfo': {
    \ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}

この例を保存するファイルは "autoload/xml/crippled.vim" となり、以下のような
ファイルを書くために使われる: >

    <tag1 attroftag1b="valueofattr1">
        <childoftag1a attrofchild>
                &amp; &lt;
        </childoftag1a>
        <childoftag1b attrofchild="5">
            <childoftag1a>
                &gt; &apos; &quot;
            </childoftag1a>
        </childoftag1b>
    </tag1>

この例には4個の特別な要素が含まれている:

1. "vimxmlentities" - 特別なキー。対応する値は、この XML ダイアレクトの実体を
   要素に持つリスト。
2. 属性の取りうる値を定めるリストの長さが 1 であり、その要素が属性名と等しい場
   合、この要素は boolean とみなされ、'attrname="' でなく 'attrname' が補完さ
   れる。
3. "vimxmltaginfo" - 特別なキー。対応する値は、タグ名をキー、長さ 2 のリストを
   値として持つ辞書。追加のメニュー情報と長い説明を保持する。
4. "vimxmlattrinfo" - 特別なキー。対応する値は、属性名をキー、長さ 2 のリスト
   を値として持つ辞書。追加のメニュー情報と長い説明を保持する。

Note: XML データファイル中のタグ名は名前空間を含んではならない。例として
xsl.vim を参照。
Note: 全データと関数はグローバル変数/関数として公開されており、個人的な編集関
数用にも使える。


DTD -> Vim							*dtd2vim*

DTD をパースし、XML オムニ補完用の XML データファイルを作成するスクリプト
|dtd2vim| が |www| 上にある。

    dtd2vim: http://www.vim.org/scripts/script.php?script_id=1462

詳しい使い方はスクリプトの先頭を参照。
このスクリプトを使うには perl と

    perlSGML: http://savannah.nongnu.org/projects/perlsgml

が必要。


コマンド

:XMLns {name} [{namespace}]					*:XMLns*

XML オムニ補完を行うには、使うデータファイルと名前空間を指定しなければならない。
データファイルを読み込み、データを適切な名前空間に結びつけるにはコマンド
|:XMLns| を使う。第 1 引数(必須)でデータの名前を指定する(xhtml10s, xsl)。
第 2 引数で名前空間コードを指定する(h, xsl)。第 2 引数を省略して実行した場合は
名前空間宣言なしでダイアレクトが使われる。例として .xsl ファイルで XML 補完を
するには次のようにする: >

	:XMLns xhtml10s
	:XMLns xsl xsl


:XMLent {name}							*:XMLent*

既定ではデフォルト名前空間のデータファイルからエンティティが補完される。コマン
ド XMLent はデフォルト名前空間が存在しない場合に使う: >

	:XMLent xhtml10s

使用例

この状態で(上記のコマンドを実行した後。カーソルが | の位置にあるとする): >

	<|

XML オムニ補完すると適切な XHTML タグが補完される。また、次の状態: >

	<xsl:|

で補完すると適切な XSL タグが補完される。


|autoload| によりロードされるスクリプト xmlcomplete.vim の中で
xmlcomplete#GetLastOpenTag() が定義されており、この関数を使うと XML ファイル内
で最後に開いたタグの名前が得られる(b:unaryTagsStack が定義されていなければなら
ない)。

	:echo xmlcomplete#GetLastOpenTag("b:unaryTagsStack")



==============================================================================
8. 挿入モードのコマンド					*inserting*

下のコマンドはバッファに新しいテキストを挿入するのに使うことができる。それらは
全て取り消すことができるし、"." コマンドで繰り返すことができる。

							*a*
a			カーソルの後ろにテキストを[count]回追加する。
			'virtualedit' がセットされていないなら、カーソルが空行
			の最初のカラムにあるときはそこに挿入する。

							*A*
A			行末にテキストを[count]回追加する。

<insert>	or				*i* *insert* *<Insert>*
i			カーソルの前にテキストを[count]回挿入する。
			挿入モード中のCTRL-O |i_CTRL-O| で使うときはカウントは
			サポートされていない。

							*I*
I			行の先頭の非空白文字の前にテキストを[count]回挿入す
			る。
			'cpoptions' にフラグ 'H' が入っている場合、空白のみを
			含む行では最後の空白文字の1文字前から挿入を開始する。

							*gI*
gI			カラム1からテキストを[count]回挿入する。{Vi にはない}

							*gi*
gi			カレントバッファの最後に入力がされた場所にテキストを
			入力する。
			これは|'^|マークを使う。マークが行末を越えているとき
			に "'^i" と動作が異なる。
			行が挿入、削除されていると入力位置は調整されるが、文
			字単位の変更は考慮されない。
			|:keepjumps|コマンドが使われると|'^|マークは変更されな
			い。
			{Vi にはない}

							*o*
o			カーソルのある行の下に新しい行を作り、そこにテキストを
			[count]回繰り返し挿入する。{Vi:空行を[count]行挿入す
			る}
			'cpoptions' にフラグ '#' が入っている場合、カウント指
			定は無視される。

							*O*
O			カーソルのある行の上に新しい行を作り、そこにテキストを
			[count]回繰り返し挿入する。{Vi:空行を[count]行挿入す
			る}
			'cpoptions' にフラグ '#' が入っている場合、カウント指
			定は無視される。

これらのコマンドはテキストの挿入を開始するのに使われる。挿入モードは<Esc>で止
めることができる。挿入モードでのその他の特殊な文字は|mode-ins-repl|を参照。
[count]の効果は挿入モードから抜けた時に現れる。

'autoindent' が設定されている時には、新しい行のインデントに、前の行と同じもの
が使用される。'smartindent' か 'cindent' が設定されている時には、行のインデン
トはCプログラム(ソースコード)のスタイルに、自動的に調整される。

'textwidth' は、行の最大幅(文字数)を設定することができる。文字を追加している時
に行が長くなりすぎると、自動的に改行が挿入される。


==============================================================================
9. Exの挿入コマンド					*inserting-ex*

							*:a* *:append*
:{range}a[ppend][!]	指定された行の下に何行分かのテキストを挿入する。
			{range}が省略された場合、テキストは現在行の後から挿入
			される。
			[!] をつけるとその実行中のみ 'autoindent' をトグルする。

							*:i* *:in* *:insert*
:{range}i[nsert][!]	指定された行の上に何行分かのテキストを挿入する。
			{range}が省略された場合、テキストは現在行の前から挿入
			される。
			[!] をつけるとその実行中のみ 'autoindent' をトグルする。

これら2つのコマンドは、"." だけを含んだ行を入力するまで、挿入すべきテキストを
待ちつづける。バックスラッシュで始まる行には警戒すべし。|line-continuation|参
照。

Ex モード (|-e| 参照) では行末にバックスラッシュを置くことで NUL 文字を挿入で
きる。行末にバックスラッシュを挿入したいときはバックスラッシュを二重にするこ
と。バックスラッシュが行末にある場合は実際に挿入される数は半分になる。

NOTE: これらのコマンドは |:global| または |:vglobal| と組み合わせて使うことは
できない。":append" と ":insert" は ":if" と ":endif"、":for" と ":endfor"、
":while" と ":endwhile" の間では機能しない。

							*:start* *:startinsert*
:star[tinsert][!]	このコマンドの実行直後に挿入モードを開始する。ノーマル
			モードで "i" をタイプしたように働く。!が含まれていた時
			には、行に追加する "A" のように働く。そうでなければ現
			在の位置から挿入が始まる。関数やスクリプトの中でこのコ
			マンドを使用したときには、関数やスクリプトが終了してか
			ら挿入が始まることに注意。
			|:normal| からこのコマンドを呼び出すと機能しない。
			{Vi にはない}
			{|+ex_extra| 機能を無効にしてコンパイルした場合は利用
			できない}

							*:stopi* *:stopinsert*
:stopi[nsert]		できるだけ早く挿入モードを中止する。挿入モードで
			<Esc>を押したように機能する。
			オートコマンドで使うことができる。例: >
				:au BufEnter scratch stopinsert
<
					*replacing-ex* *:startreplace*
:startr[eplace][!]	このコマンドを実行した直後に置換モードに入る。ノーマル
			モードにおける "R" とちょうど同じ。"!" をつけると "$R"
			とタイプしたのと同じになる(つまり行末から置換モードを
			開始する)。"!" をつけないとカーソル位置から置換モード
			を開始する。
			Note 関数やスクリプトの中からこのコマンドを実行すると、
			その関数・スクリプトが終了した後ではじめて置換モード
			になることに注意。
			{Vi にはない}
			{|+ex_extra| 機能つきでコンパイルしたときのみ有効}

							*:startgreplace*
:startg[replace][!]	|:startreplace| と同様だが、|gR| のようなビジュアル置
			換モードになる。
			{Vi にはない}
			{|+ex_extra| 機能つきでコンパイルしたときのみ有効}

==============================================================================
10. ファイルを挿入する					*inserting-file*

							*:r* *:re* *:read*
:r[ead] [++opt] [name]	カーソルの後ろに、ファイル[name] (省略した場合:現在の
			ファイル)を挿入する。
			[++opt] として指定できる値については |++opt| を参照。

:{range}r[ead] [++opt] [name]
			指定した行の下に、ファイル[name](省略した場合:現在の
			ファイル)を挿入。
			[++opt] として指定できる値については |++opt| を参照。

							*:r!* *:read!*
:[range]r[ead] [++opt] !{cmd}
			カーソルまたは指定行の後ろに、{cmd}を実行したその標準
			出力の内容を挿入。コマンドの出力を蓄え、バッファに読み
			込むために、テンポラリファイルが使用される。コマンドの
			出力を保存するために 'shellredir' が使用されるので、標
			準エラー出力も含めるか含めないか指定することができる。
			{cmd}は ":!{cmd}" と同じように実行されるので、'!' だけ
			を指定した場合には、以前に実行された|:!|コマンドに置き
			換えられる。
			[++opt] として指定できる値については |++opt| を参照。

これらのコマンドは、ファイルの内容、もしくはコマンドの出力をバッファへ挿入す
る。これらは取り消す(UNDO)ことができる。これらは "." コマンドで繰り返すことは
できない。これらは行単位で行われる操作で、挿入はカーソルの直後のラインからか、
指定したラインの直後から行われる。一番最初のラインより上(ファイルの先頭)に挿入
するには ":0r {name}" というコマンドを使う。

":read" コマンドの後には、新しいラインの左で、最初の空白でない文字にカーソルが
移動する。もしExモードでなければ、カーソルは新しい行の最後の左側に移動する(残
念だがViとの互換性のため)。

":r" にファイル名が与えられた場合、それが代替バッファのファイルになる。これは
例えば代わりにそのファイルを編集したい時に使うことができる: "e! #"。
'cpoptions' オプションから 'a' フラグを削除することで、オフに切り替えることが
できる。

":read" には特別な [++opt] 引数が1つある。++edit である。これは実際にファイル
を開いたときと同じようにファイルを挿入したい場合に便利である。空のバッファで次
のコマンドを実行してみよ: >
	:read ++edit filename
こうすると 'fileformat', 'fileencoding', 'bomb' などのオプションがそのファイル
に対して検出された値になる。ただし、(:e filename とした場合と異なり)バッファの
先頭に余計な空行が1行入ってしまう。

							*file-read*
'fileformat' オプションがファイルの<EOL>の流儀を決定する:
'fileformat'    文字		   名前				~
  "dos"		<CR><NL> or <NL>   DOS format
  "unix"	<NL>		   Unix format
  "mac"		<CR>		   Mac format
以前には 'textmode' が使用された。それは現在では廃れている。

'fileformat' が "dos" の時には、<NL>の前の<CR>は無視され、ファイルの終端にある
CTRL-Zもまた無視される。

'fileformat' が "mac" の時には、ファイル内の<NL>は内部的に<CR>によって表現され
る。これは<NL>を表現するために使用される<NUL>との混同を避けるためである。
|CR-used-for-NL|参照。

'fileformats' オプションが空でなかったら、Vimは<EOL>のタイプを識別しようと試み
る(|file-formats|参照)。しかしながら、'fileformat' オプションは変更されない。
検出されたフォーマットはファイルの読み込みの際にだけ使用される。
'fileencodings' についても同様。

MS-DOS、Win32そしてOS/2以外のシステムでは、DOSフォーマットのファイルを読み込ん
だときにはそれを知らせるために、"[dos format]" というメッセージが表示される。
マッキントッシュ、MS-DOS、Win32そしてOS/2においては、ファイルがUnixフォーマッ
トであった場合に、"[unix format]" というメッセージが表示される。
マッキントッシュ以外のシステムでは、ファイルがマックフォーマットであった場合
に、"[Mac format]" というメッセージが表示される。

":r !" をどう使うかの例: >
	:r !uuencode binfile binfile
このコマンドは "binfile" を読み込みuuencode化して、それを現在のバッファに読み
込む。e-mailを編集していて、バイナリファイルを含めたい時に便利である。

							*read-messages*
ファイルを読み込むときVimはその情報を表示する。いくつかのものについての説明
をあげる。他のものは見ればわかる。ロングとショートのどちらを使うかは
'shortmess' オプションに依存する。

	ロング		ショート	意味 ~
	[readonly]	{RO}		ファイルは書き込み制限されている
	[fifo/socket]			ストリームを使っている
	[fifo]				FIFOストリームを使っている
	[socket]			ソケットストリームを使っている
	[CR missing]			"dos" ファイルフォーマットで読み込ん
					でいてCRのないNLを見つけた
	[NL found]			"mac" ファイルフォーマットで読み込ん
					でいてNLを見つけた(unixフォーマット
					なのだろう)
	[long lines split]		少なくとも一つの行が二つに分割された
	[NOT converted]			'fileencoding' から 'encoding' の変換
					が失敗した
	[converted]			'fileencoding' から 'encoding' の変換
					を実施した。
	[crypted]			暗号が解除された
	[READ ERRORS]			ファイルを全て読み込めなかった

{訳注: 以下日本語メッセージの場合:
	ロング		ショート	意味 ~
	[読込専用]	[読専]		ファイルは書き込み制限されている
	[FIFO/ソケット]			ストリームを使っている
	[FIFO]				FIFOストリームを使っている
	[ソケット]			ソケットストリームを使っている
	[CR無]				"dos" ファイルフォーマットで読み込ん
					でいてCRのないNLを見つけた
	[NL有]				"mac" ファイルフォーマットで読み込ん
					でいてNLを見つけた(unixフォーマット
					なのだろう)
	[長行分割]			少なくとも一つの行が二つに分割された
	[未変換]			'fileencoding' から 'encoding' の変換
					が失敗した
	[変換済]			'fileencoding' から 'encoding' の変換
					を実施した。
	[暗号化]			暗号が解除された
	[読込エラー]			ファイルを全ては読み込めなかった
}


 vim:tw=78:ts=8:ft=help:norl:
