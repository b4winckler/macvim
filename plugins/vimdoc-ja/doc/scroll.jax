*scroll.txt*    For Vim バージョン 7.4.  Last change: 2006 Aug 27


		VIMリファレンスマニュアル    by Bram Moolenaar


スクロール						*scrolling*

これらのコマンドはウィンドウの内容を移動する。カーソルがウィンドウの外に移動し
ようとすると、カーソルはウィンドウに留まるように振舞う ('scrolloff' のスクリー
ン行をカーソルの周囲に確保する)。1ページとはウィンドウの行数から2引いた行数と
定義する。これらのコマンドを覚えるのは少し厄介かもしれない。ウィンドウをバッ
ファのうち貴方が見ている一部分と捉えて、ウィンドウの動きをバッファ内での上下の
移動に関連付けてコマンドを覚えると良いだろう。例えばバッファの中でウィンドウが
上に動くと、ウィンドウのテキストはスクリーンの下の方へ移動していくことになる。

手始めにユーザーマニュアルの|03.7|を読むこと。

1. 下方スクロール		|scroll-down|
2. 上方スクロール		|scroll-up|
3. カーソル相関スクロール	|scroll-cursor|
4. 水平スクロール		|scroll-horizontal|
5. 同期スクロール		|scroll-binding|
6. マウスホイールスクロール	|scroll-mouse-wheel|

==============================================================================
1. 下方スクロール					*scroll-down*

以下のコマンドは編集ウィンドウ(バッファ内の貴方が見ている一部分)を下に移動する
(つまりテキストバッファのより下にある行を見ることができる):

							*CTRL-E*
CTRL-E			バッファの下へ[count]行ウィンドウをスクロールする。
			覚え方: Extra lines {訳注: Extra=割増}

							*CTRL-D*
CTRL-D			ウィンドウをバッファ内で下にスクロールする。スクロール
			する行数は 'scroll' オプションで指定される(省略した場
			合: スクリーンの半分の行数)。[count]が指定された場合、
			'scroll' オプションに[count]が設定されてからスクロール
			する。カーソルもファイル内で同じ行数だけ下へ移動する
			(もし可能ならば; 行が折り返されている場合やファイルの
			終端に達した時は違ってくる)。カーソルがバッファの最終
			行にある時は何も起こらずビープ音が鳴る。'startofline'
			オプションも参照。
			{Vi と異なる点: ファイルの物理行数スクロールさせる代わ
			りに、Vimでは 'scroll' 行分スクリーンの論理行でスクロー
			ルする; これは行が折り返されている時に違いを生む}

<S-Down>	or				*<S-Down>* *<kPageDown>*
<PageDown>	or				*<PageDown>* *CTRL-F*
CTRL-F			ウィンドウをバッファ内で[count]ページ前方(下方)にスク
			ロールする。'startofline' オプションも参照。
			ウィンドウが1つだけのときはオプション 'window' の値が
			使われる。

							*z+*
z+			[count]が無い時: 現在のウィンドウの最下行を最上行にし
			て再描画する。カーソルはその行の、最初の非空白文字に合
			わせられる。
			[count]が有る時: ちょうど "z<CR>" と同じ。

==============================================================================
2. 上方スクロール					*scroll-up*

以下のコマンドは編集ウィンドウ(バッファ内の貴方が見ている一部分)を上に移動する
(つまりテキストバッファのより上にある行を見ることができる):

							*CTRL-Y*
CTRL-Y			バッファの上へ[count]行ウィンドウをスクロールする。
			Note: MS-Windowsのキーバインディングを使っているときは
			CTRL-Yはredoにマッピングされている。

							*CTRL-U*
CTRL-U			ウィンドウをバッファ内で上にスクロールする。スクロー
			ルする行数は 'scroll' オプションで指定される(省略した
			場合: スクリーンの半分の行数)。[count]が指定された場
			合、'scroll' オプションに[count]が設定されてからスク
			ロールする。カーソルもファイル内で同じ行数だけ上へ移動
			する(もし可能ならば; 行が折り返されている場合やファイ
			ルの先頭に達した時は違ってくる)。カーソルがバッファの
			先頭行にある時は何も起こらずビープ音が鳴る。
			'startofline' オプションも参照。
			{Vi と異なる点: ファイルの物理行数スクロールさせる代わ
			りに、Vimでは 'scroll' 行分スクリーンの論理行でスクロー
			ルする; これは行が折り返されている時に違いを生む}

<S-Up>		or					*<S-Up>* *<kPageUp>*
<PageUp>	or					*<PageUp>* *CTRL-B*
CTRL-B			ウィンドウをバッファ内で[count]ページ後方(上方)にスク
			ロールする。'startofline' オプションも参照。
			ウィンドウが1つだけのときはオプション 'window' の値が
			使われる。

							*z^*
z^			[count]が無い時: 現在のウィンドウの最上行を最下行にし
			て再描画する。カーソルはその行の、最初の非空白文字に合
			わせられる。
			[count]が有る時: まず[count]行がウィンドウの最下行に
			なるようにスクロールし、次にウィンドウの最上行になっ
			た行を最下行にして再描画する。カーソルはその行の最初
			の非空白文字に合わせられる。

==============================================================================
3. カーソル相関スクロール				*scroll-cursor*

下記のコマンドはカーソルの位置は変えずに編集ウィンドウ(バッファの見えている一
部)の位置を変える:

							*z<CR>*
z<CR>			[count]行(省略時はカーソルのある行)をウィンドウの最上
			行にして再描画する。カーソルは行内の最初の非空白文字に
			置かれる。

							*zt*
zt			"z<CR>" と同様だが、カーソルは同じカラムに留める。
			{Vi にはない}

							*zN<CR>*
z{height}<CR>		ウィンドウを高さ{height}行に変更して再描画する。スク
			リーンの更新が非常に遅い時に、高さを減らすと有効であ
			る。物理的なスクリーンの高さよりも高くすることはできな
			い。

							*z.*
z.			[count]行(省略時はカーソルのある行)をウィンドウの中心
			にして再描画する。カーソルは行内の最初の非空白文字に置
			かれる。

							*zz*
zz			"z." と同様だが、カーソルは同じコラムに留める。注意:
			caps-lockが有効になっていると、このコマンドは "ZZ" に
			なり、バッファを書き出し終了してしまう。{Vi にはない}

							*z-*
z-			[count]行(省略時はカーソルのある行)をウィンドウの最下
			行にして再描画する。カーソルは行内の最初の非空白文字に
			置かれる。

							*zb*
zb			"z-" と同様だが、カーソルは同じコラムに留める。
			{Vi にはない}

==============================================================================
4. 水平スクロール					*scroll-horizontal*

次の4つのコマンドはスクリーンに応じてカーソルが移動する。カーソルのある文字が
スクリーンが動いたために消えると、カーソルはスクリーン上の一番近い文字に移動す
る。'sidescroll' の値は使用されない。

z<Right>    or						*zl* *z<Right>*
zl			スクリーンを[count]文字右へ移動する。従ってテキストは
			[count]文字左へスクロールする。これは 'wrap' がオフの
			時にだけ働く。 {Vi にはない}

z<Left>      or						*zh* *z<Left>*
zh			スクリーンを[count]文字左へ移動する。従ってテキストは
			[count]文字右へスクロールする。これは 'wrap' がオフの
			時にだけ働く。 {Vi にはない}

							*zL*
zL			スクリーンの幅の半分右へスクロールする。従ってテキスト
			はスクリーンの幅の半分左へスクロールする。これは 'wrap'
			がオフの時にだけ働く。 {Vi にはない}

							*zH*
zH			スクリーンの幅の半分左へスクロールする。従ってテキスト
			はスクリーンの幅の半分右へスクロールする。これは 'wrap'
			がオフの時にだけ働く。 {Vi にはない}

次の2つのコマンドではテキスト上でカーソルは移動せず、スクリーンのテキストだけ
がスクロールする。

							*zs*
zs			カーソルのある位置がスクリーンの始まり(左側)に来るよう
			にテキストを水平にスクロールする。これは 'wrap' がオフ
			の時にだけ働く。 {Vi にはない}

							*ze*
ze			カーソルのある位置がスクリーンの終わり(右側)に来るよう
			にテキストを水平にスクロールする。これは 'wrap' がオフ
			の時にだけ働く。 {Vi にはない}

==============================================================================
5. 同期スクロール					*scroll-binding*

時折、2つかそれ以上のウィンドウを結びつけて、1つがスクロールしたら他のウィンド
ウもスクロールして欲しいと思うことがある。Vimではウィンドウごとに 'scrollbind'
オプションを設定することでこのような振る舞いをさせることが可能である。
'scrollbind' が設定されたあるウィンドウがスクロールした場合、他の 'scrollbind'
が設定されたウィンドウが可能なら同じ量だけスクロールする。'scrollbind' の振る
舞いは 'scrollopt' オプションによって変更することができる。

スクロールバーを使っているとき、マウスでスクロールバーを操作しても他のウィンド
ウはスクロールされない。これは少しの間だけ同期スクロールを使わないでスクロール
したい時に使える。

ウィンドウに 'diff' オプションも設定されているとき、同期スクロールは位置を正確に
同期するために二つのバッファの差分を利用する。それ以外の場合は以下の方法が使わ
れる。

							*scrollbind-relative*
'scrollbind' された各々のウィンドウは "相対的なオフセット" --すなわち、現在の
ウィンドウの垂直スクロール位置とその他のウィンドウの垂直スクロール位置の間の差
分と考えることができる--を追跡する。'scrollbind' ウィンドウの1つがテキストの最
初もしくは最後を超えてスクロールしようとすると、そのウィンドウはそれ以上スク
ロールはしないが、どれだけ限界を超えて移動しようとしたかは記憶される。そのウィ
ンドウは同じ相対オフセットを維持するために、そのバッファの限界を超えてスクロー
ルを要求されたかに関わらず、この情報を保持し続ける。

しかしながら、そのバッファの限界を超えるような相対オフセットを持つウィンドウに
カーソルフォーカスが与えられると、その他の 'scrollbind' されたウィンドウは現在
のウィンドウの有効な相対オフセットの位置にジャンプすることになる。この振る舞い
は 'scrollopt' オプションから 'jump' フラグを削除することで変えることができる。

						*syncbind* *:syncbind* *:sync*
:syncbind		すべての 'scrollbind' ウィンドウが同じ相対オフセットを
			持つように強制する。すなわち 'scrollbind' ウィンドウが
			そのバッファの先頭にスクロールされた時、その他の
			'scrollbind' ウィンドウもまたそれぞれのバッファの先
			頭に持っていかれる。

							*scrollbind-quickadj*
'scrollbind' フラグはウィンドウを垂直スクロールするキーボードコマンドを使う時
に意味があり、またカーソルフォーカスを持つウィンドウの垂直スクロールバーを使う
ときに意味がある。しかしながら、カーソルフォーカスを持たないウィンドウの垂直ス
クロールバーを使うときには、'scrollbind' は無視される。これを 'scrollbind' さ
れたウィンドウの相対オフセットを修正する時に利用できる。

==============================================================================
6. マウスホイールスクロール				*scroll-mouse-wheel*

マウスにスクロールホイールがあるときは、GUI の Vim でそれを使うことができる。
どのように動作するかはシステムに依存する。ホイールは xterm でも動作する
|xterm-mouse-wheel|。デフォルトでは垂直スクロールホイールのみサポートされてい
る。いくつかの GUI では水平スクロールホイールもサポートされている。

Win32 GUIではスクロールの動作はソースに埋め込まれている。それはちょうど現在の
ウィンドウのスクロールバーをドラッグした時のように働く。何行スクロールするかは
貴方のマウスドライバに依存する。スクロールの動作が入力フォーカスの問題を引き起
こすならば、|intellimouse-wheel-problems|を参照。

X11 GUI (Motif、Athena、GTK) ではホイールを回すと <ScrollWheelUp>、
<ScrollWheelDown>、<ScrollWheelLeft>、<ScrollWheelRight> などのキー入力が発生
する。例えば、スクロールホイールを上に回すと <ScrollWheelUp> キーが生成され、
ウィンドウが上にスクロールする (つまりテキストが下に移動する)。これらのキーの
デフォルトの動作は次の通り:
    <ScrollWheelUp>	    3 行上にスクロール		*<ScrollWheelUp>*
    <S-ScrollWheelUp>	    1 画面上にスクロール	*<S-ScrollWheelUp>*
    <C-ScrollWheelUp>	    1 画面上にスクロール	*<C-ScrollWheelUp>*
    <ScrollWheelDown>	    3 行下にスクロール		*<ScrollWheelDown>*
    <S-ScrollWheelDown>	    1 画面下にスクロール	*<S-ScrollWheelDown>*
    <C-ScrollWheelDown>	    1 画面下にスクロール	*<C-ScrollWheelDown>*
    <ScrollWheelLeft>	    6 列左にスクロール		*<ScrollWheelLeft>*
    <S-ScrollWheelLeft>	    1 画面左にスクロール	*<S-ScrollWheelLeft>*
    <C-ScrollWheelLeft>	    1 画面左にスクロール	*<C-ScrollWheelLeft>*
    <ScrollWheelRight>	    6 列右にスクロール		*<ScrollWheelRight>*
    <S-ScrollWheelRight>    1 画面右にスクロール	*<S-ScrollWheelRight>*
    <C-ScrollWheelRight>    1 画面右にスクロール	*<C-ScrollWheelRight>*
これはコマンドラインを編集する以外の、全てのモードで動作するだろう。

Note: 水平スクロールは 'nowrap' が設定されているときのみ機能する。また、
'guioptions' の "h" フラグが設定されていない場合は、スクロールするとカーソル行
が画面外になってしまうようなときに、表示されている範囲の一番長い行にカーソルが
移動する (水平スクロールバーの動作に似た感じ)。

キーマッピングによりデフォルトの振る舞いを変更することができる。例えば、ノーマ
ルモードでホイールによるスクロールを1行にしたり半画面にしたりできる: >
    map <MouseDown> <C-Y>
    map <S-MouseDown> <C-U>
    map <MouseUp> <C-E>
    map <S-MouseUp> <C-D>
AltやCtrlといった修飾も可能である。

これはもちろん、Vimがスクロールホイールのイベントを取得している時にだけ働く。
この機能が働くかどうかは "xev" プログラムを使用すればチェックできる。

XFree86を使っているときには、/etc/XF86Configに貴方のマウスの正しいエントリがな
ければならない。FreeBSDでは、このようなエントリがロジテックのスクロールマウス
用に必要である。 >
    Protocol     "MouseMan"
    Device       "/dev/psm0"
    ZAxisMapping 4 5
詳しくはXFree86のドキュメントを参照すること。

						*<MouseDown>* *<MouseUp>*
<MouseDown> と <MouseUp> は廃止された。<MouseDown> の代わりに <ScrollWheelUp>
を、<MouseUp> の代わりに <ScrollWheelDown> を使うこと。

							*xterm-mouse-wheel*
新しいxtermでマウスホイールを使うには、上で書かれているようにXserverでスクロー
ルホイールマウスが動作するようにするだけで良い。

古いxtermでマウスホイールを使うにはこうする:
1. 上に書かれているように、Xserverで使えるようにする。
2. xtermに変換を追加し、スクロールイベントをVimへエスケープシーケンスとして渡
   すようにする。
3. Vimにマッピングを追加し、エスケープシーケンスを <ScrollWheelDown> もしくは
   <ScrollWheelUp> キーとして解釈できるようにする。

次のような内容をあなたの~/.Xdefaults(もしくは別名の貴方のXリソースファイル)に
追加すれば変換ができる。 >

  XTerm*VT100.Translations:		#override \n\
		s<Btn4Down>: string("0x9b") string("[64~") \n\
		s<Btn5Down>: string("0x9b") string("[65~") \n\
		<Btn4Down>: string("0x9b") string("[62~") \n\
		<Btn5Down>: string("0x9b") string("[63~") \n\
		<Btn4Up>: \n\
		<Btn5Up>: 

以下のマッピングを vimrc ファイルに追加すること: >
	:map <M-Esc>[62~ <ScrollWheelUp>
	:map! <M-Esc>[62~ <ScrollWheelUp>
	:map <M-Esc>[63~ <ScrollWheelDown>
	:map! <M-Esc>[63~ <ScrollWheelDown>
	:map <M-Esc>[64~ <S-ScrollWheelUp>
	:map! <M-Esc>[64~ <S-ScrollWheelUp>
	:map <M-Esc>[65~ <S-ScrollWheelDown>
	:map! <M-Esc>[65~ <S-ScrollWheelDown>
<
 vim:tw=78:ts=8:ft=help:norl:
