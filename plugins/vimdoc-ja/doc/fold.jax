*fold.txt*      For Vim バージョン 7.4.  Last change: 2010 May 13


		VIMリファレンスマニュアル    by Bram Moolenaar


折畳(Folding)					*Folding* *folding* *folds*

ユーザーマニュアルの28章に折畳についての紹介がされている。|usr_28.txt|

1. 折畳方法		|fold-methods|
2. 折畳コマンド		|fold-commands|
3. 折畳オプション	|fold-options|
4. 折畳の振舞		|fold-behavior|

{Vi には折畳は無い}
{|+folding| 機能無しでコンパイルした場合には利用できない}

==============================================================================
1. 折畳方法					*fold-methods*

折畳を行う方法は 'foldmethod' オプションで設定できる。

'foldmethod' を "manual" 以外の値に設定すると、存在している折畳は全て削除され
新たな折畳が作成される。"manual" に切換えた時には既存の折畳は削除されない。こ
れを利用すればまず自動的に折畳を定義し、それから手動で変更することが可能であ
る。

折畳方法は6つの中から選択できる:
	manual		手動で折畳を定義する
	indent		インデントの数を折畳のレベル(深さ)とする
	expr		折畳を定義する式を指定する
	syntax		構文強調により折畳を定義する
	diff		変更されていないテキストを折畳対象とする
	marker		テキスト中の印で折畳を定義する


手動(MANUAL)					*fold-manual*

折畳領域を定義するためにコマンドを手動で利用する。これはテキスト中の折畳を行う
箇所をスクリプトにより解析するのに使うこともできる。

折畳のレベルは折畳の入れ子の深さとなる。ある行範囲の折畳レベルを増やすには、折
畳がある同じ範囲に対して再び折畳を設定する。

手動折畳はファイルを放棄すると失われる。折畳を保存するには|:mkview|コマンドを
使用する。後に復元するには|:loadview|を使用する。


インデント(INDENT)				*fold-indent*

折畳は各行のインデントにより自動的に定義される。

折畳レベルは各行のインデント量を、'shiftwidth' で割る(端数切捨て)ことで計算さ
れる。同じかより高い折畳レベルを持った一続きの範囲は1つの折畳を形成し、より高
いレベルを持った範囲はその中で入れ子の折畳となる。

折畳の入れ子は 'foldnestmax' によって制限される。

ある行ではインデントを無視して直ぐ上か下の行のうち、低いほうの折畳レベルが使用
される。無視されるのは完全な空行か、空白文字だけからなる行、および 'foldignore'
の文字で始まる行である。'foldignore' の文字の前に空白文字があっても無視される。
Cではプリプロセッサ行を無視するために "#" を使用する。

他の方法で無視する行を定義するには、'expr' の方法を使用する。'foldexpr' の中
で、ある行のインデントを取得するのに、関数|indent()|を使うことができる。


式(EXPR)					*fold-expr*

折畳は "indent" 方式のように、折畳レベルによって自動的に定義される。'foldexpr'
オプションの値は、各行についてこの折畳レベルを計算するためにスクリプトとして実
行される。例:
タブで始まる一連の行範囲を1つの折畳にまとめる: >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
折畳レベルを計算するのにVimスクリプトの関数を呼び出す: >
	:set foldexpr=MyFoldLevel(v:lnum)
空行で仕切られた「段落」を折畳とする: >
    :set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同じ事(「段落」を折畳に)をする別の表現: >
    :set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1

バックスラッシュ(日本では \ 記号)が ":set" の流儀で、通常とは異なるキャラクタ
(空白文字、バックスラッシュ、ダブルクォート、その他、詳細は|option-backslash|
参照)をエスケープしていることに注意。

式が評価される際の前提条件は以下の通り:
- その行について現在のバッファとウィンドウが常に存在している。
- 変数 "v:lnum" には評価対象となる行番号が設定されている。
- 式の結果(戻り値)は以下の形式で折畳レベルを示す:
  値			意味 ~
  0			対象行は折畳に含まれない
  1, 2, ..		対象行はこのレベルの折畳に含まれる
  -1			折畳レベルを未定義とし、対象行の直前か直後の行のうち低
			い方を、対象行のレベルとする。
  "="			直前の行と同じレベルを使用する
  "a1", "a2", ..	直前の行のレベルを+1, +2して設定する
  "s1", "s2", ..	直前の行のレベルを-1, -2して設定する
  "<1", "<2", ..	指定したレベルの折畳を対象行で終了する
  ">1", ">2", ..	指定したレベルの折畳を対象行から開始する

折畳は直前の行の折畳レベルより高い(低い)行から開始(終了)されるので、折畳の開始
(終了)マーク ">1" ("<1") は明示的に指定する必要は無い。

式に副作用があってはならない。バッファ内のテキストや、カーソルの位置や、検索パ
ターン、オプションその他。どれひとつ変更してはならない。
ただし、注意深く行えば、変更してもそれを復元しておけばよい。

式にエラーがあるか、結果が認識できない時には、何のエラーメッセージも表示せずに
折畳レベルは0に設定される。'debug' オプションに "msg" を設定すれば、エラーメッ
セージが表示されるようになるので、デバッグに利用できる。

NOTE: 各行について式評価が実行されるので、この折畳方式は非常に動作が遅くなる可
能性がある!

"=", "a", そして "s" は極力避けるようにする。なぜならVimはそれらが使われると、
折畳レベルが定義された行が見つかるまで戻って、幾度も検索を行わなければならない
からだ。これは動作が遅くなることがある。

フォールドレベルを調べるには|foldlevel()|を使うのが便利である。レベルがわから
ないときは-1を返すことに注意すること。フォールドがその行で終わっているときには
行頭のレベルを返す。

折畳が適切に更新されない場合がある。その場合は |zx| か |zX| を使って強制的に更
新すること。


構文(SYNTAX)					*fold-syntax*

折畳が "fold" 引数を持つ構文要素によって定義される。 |:syn-fold|

折畳レベルは入れ子によって定義される。入れ子の深さは 'foldnestmax' によって制
限される。

シンタックスの同期の設定に注意すること。これが正しく設定されていないとフォール
ドが間違ったハイライトで表示される。これは特に複数行にマッチするシンタックスで
問題になる。そのようなときには次のような力技がある: >
	:syn sync fromstart


差分(DIFF)					*fold-diff*

テキストの変更された箇所とその近辺以外が自動的に折畳として定義される。

この方法は現在のウィンドウに対して 'diff' オプションが設定されている時にだけ正
しく働き、変更点が表示される。そうでない場合バッファ全体が1つの大きな折畳とな
る。

コンテキスト(の行数)を指定するのに 'diffopt' を使うことができる。これにより変
更点の近辺の折畳に含まない行数を指定できる。下の例では8行表示するように設定し
ている: >
	:set diffopt=filler,context:8
省略した場合には6行が表示される。

'scrollbind' が設定されているとき、Vimは他のウィンドウと見た目が同じになるよう
にフォールドを開いた状態に保とうとする。

印(MARKER)					*fold-marker*

テキスト中の印により折畳の開始と終了地点を指定する。これにより明確に折畳を設定
することができる。また誤った行を含むことなく、折畳を削除・設定できる。通常
'foldtext' オプションは折畳の行に表示されるテキストとして、印の直前のテキスト
設定する。これにより折畳に名前を設定することが可能になる。

印には折畳レベルを含むことができ、また開始と終了で対になる文字を使うこともでき
る。必ずしも終了の印を加える必要はなく、また対がない印が無い場合の問題も避けら
れるので、レベルを含んだほうがより簡単である。例: >
	/* グローバル変数 {{{1 */
	int varA, varB;

	/* 関数 {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}

折畳は印 "{{{" で開始する。印の後ろの番号は折畳レベルを示す。現在の折畳レベル
と異なるレベルが印によって与えられた時に何が起こるかは、そのレベルの差に依存す
る:
1. 同じ折畳レベルの印が与えられた時には、前の折畳は終了し同じレベルの新たな折
   畳が開始する。
2. 高い折畳レベルの印を見つけた時には、入れ子の折畳が開始する。
3. 低い折畳レベルの印を見つけた時には、指定されたレベル以上の全部の折畳を終了
   し、指定されたレベルで新たな折畳が開始する。

番号は折畳レベルを示す。0を使うことはできない(レベル0の印は無視される)。特定の
レベルの折畳を終了させるため "}}}" 数字を付けて使うことができる。その印の直後
の行の折畳レベルは示されたレベルよりも1つだけ低くなる。Vimは指定されたレベルに
マッチする印を検索はしないことに注意(計算に時間がかかりすぎてしまうので)。
例: >

	{{{1
	ここからレベル1の折畳
	{{{3
	ここからレベル3の折畳
	}}}3
	ここからレベル2の折畳

折畳を定義するのに対になる "{{{" と "}}}" を使用することもできる。折畳レベルは
"{{{" 1つにつき1ずつ増加し、"}}}" 1つにつき1ずつ減少する。印同士の対応関係を維
持するように気をつけること! 例: >

	{{{
	ここからレベル1の折畳
	{{{
	ここからレベル2の折畳
	}}}
	ここからレベル1の折畳

番号付きの印と番号無しの印を混ぜて使用することもできる。大きな折畳には番号付き
の印を使用し、関数中の小さな折畳などには番号無しの印を使うと便利だろう。一例を
挙げれば、ファイルの "構造体定義" や "ローカル変数" それから "関数定義" のよう
な部分にはレベル1(番号付き)の折畳を使用する。そして一つ一つの定義や関数実装に
はレベル2の折畳を使用し、関数内部(例えばあるブロックなど)には番号無しの印を使
用する。こうしておけば関数の中で折畳を分割するような変更を行う時に、印にレベル
を付け直す必要はなくなる。

印は 'foldmarker' オプションにより変更できる。Vimユーザー間でファイルを交換で
きるようにするためには、このオプションのデフォルトである "{{{,}}}" は変更しな
いことが推奨される。ファイルによってそれがどうしても必要な時(例えば別のエディ
タで作成した折畳を示す異なる印を含んでいる時や、ファイル内容の制約によりデフォ
ルトの印が問題を起こすため、それを使うことができない場合)にだけ変えるように。

							*fold-create-marker*
印による折畳を作成するのに "zf" コマンドを使用することができる。Vimがユーザー
に代わって印を挿入する。Vimは 'foldmarker' で指定された開始の印と終了の印を追
加する。印は行末に追加される。'commentstring' が空でなければそれが使用される。
これは次のような時には正しく働かない:
- 既に番号付き折畳が含まれている。Vimはそれをどのように扱えば良いか知らない。
- 番号付き折畳の近くで、それらの印が邪魔になる場合。
- 行がコメントの中で、'commentstring' が空ではなく、かつ入れ子コメントを使用で
  きない場合。例えばC言語: /* {{{ */ を既に存在するコメントを消さずにその中に
  追加するようなこと。コメントの直前か直後に印を設定するか、もしくは手動で印を
  追加する必要がある。
一般的に、既に番号付き折畳が存在する場合には、Vimに印を作成させるのは良いアイ
デアではない。

							*fold-delete-marker*
印による折畳を削除するのに "zd" コマンドを使用することができる。Vimがユーザー
に代わって印を削除する。Vimは 'foldmarker' で指定された開始の印と終了の印を検
索する。印の周りにある 'commentstring' に適合するテキストは可能な限り削除され
る。
これは次のような時には正しく働かない:
- ある行に印が1つ以上含まれていて、そのうち少なくとも1つがレベルを指定している
  場合。折畳を削除することで期待される効果どうりになるかどうかはチェックされる
  ことなく、単に初めの折畳が1つ削除される。
- 番号付き印で、複数の折畳を同時に開始したり終了するために使用されている場合。

==============================================================================
2. 折畳コマンド					*fold-commands* *E490*

全ての折畳コマンドは "z" で始まっている。ヒント: "z" は紙片を折った様子を横か
らみた姿に見える。


折畳の作成と削除 ~
							*zf* *E350*
zf{motion}  or
{Visual}zf	折畳を作成する操作。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		"manual" の時には新しい折畳は閉じられる。
		'foldenable' がセット(有効化)される。
		|fold-create-marker|も参照。

							*zF*
zF		[count]行を折畳として作成する。"zf" と同じように動作する。

:{range}fo[ld]						*:fold* *:fo*
		{range}で示された範囲を折畳にする。"zf" と同様に動作する。

							*zd* *E351*
zd		カーソルの位置にある折畳を1つ削除する。カーソルが折畳になって
		いる行にある場合には、その折畳が削除される。入れ子になった折畳
		は1レベル分が削除される。ビジュアルモードでは選択された範囲の
		全ての折畳(partially)が削除される。注意: これは期待したよりも
		余計に折畳を削除し易く、またアンドゥもできないので注意が必要。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		|fold-delete-marker|も参照。

							*zD*
zD		カーソルの位置の折畳を再帰的に削除する。ビジュアルモードでは、
		選択された範囲内の入れ子も含め全ての折畳(partially)が削除され
		る。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		|fold-delete-marker|も参照。

							*zE* *E352*
zE		ウィンドウにある全ての折畳を削除する。
		'foldmethod' が "manual" か "marker" の時だけ動作する。
		|fold-delete-marker|も参照。


折畳を開く・閉じる ~

'foldminlines' よりも少ない行数の折畳は常に開いたように表示される。従って以下
のコマンドは小さな折畳に関しては異なった働きを持つ。

							*zo*
zo		カーソルの下の折畳を一段階開く。カウントが与えられた場合には、
		複数の深さの折畳が開かれる。ビジュアルモードでは、選択された範
		囲にある全ての折畳が1レベル開かれる。

							*zO*
zO		カーソルの下の折畳を再帰的に全て開く。カーソルのある行を含まな
		いフォールドは変更されない。
		ビジュアルモードでは、選択された範囲の全ての折畳が、部分的に選
		択されていただけでも全て完全に開かれる。

							*zc*
zc		カーソルの下の折畳を一段階閉じる。カウントが与えられた場合に
		は、複数の深さの折畳が閉じられる。ビジュアルモードでは、選択さ
		れた範囲にある全ての折畳が1レベル閉じられる。
		'foldenable' がセット(有効化)される。

							*zC*
zC		カーソルの下の折畳を再帰的に全て閉じる。カーソルのある行を含ま
		ないフォールドは変更されない。
		ビジュアルモードでは、選択された範囲の全ての折畳が、部分的に選
		択されていただけでも全て完全に閉じられる。'foldenable' がセッ
		ト(有効化)される。

							*za*
za		折畳が閉じていた場合: それを開く。折畳が入れ子になっている時に
		は、"za" を何度も使う必要がある。カウントが与えられた場合には、
		複数の閉じられた折畳が開かれる。
		折畳が開いていた場合: それを閉じ 'foldenable' をセットする。繰
		り返し使っても閉じた折畳が開くだけだから、これは1レベル開くだ
		けである。カウントが与えられた場合には、複数の折畳が閉じられる
		(これは "za" を複数回繰り返した場合の動作と同じではない)。

							*zA*
zA		折畳が閉じていた場合: 再帰的に開く。
		折畳が開いていた場合: 再帰的に閉じ 'foldenable' をセットする。

							*zv*
zv		カーソル行を表示する: カーソルのある行がちょうど表示されるレベ
		ルまで折畳を開く。

							*zx*
zx		折畳を更新する: 手動で行った折畳の開閉操作をアンドゥする:
		'foldlevel' を再適用し、"zv" を行う: カーソル行を表示する。
		折畳の計算を強制するのにも使える。これは 'foldexpr' を使ってい
		てバッファが変更されたにも関わらず折畳が適切に更新されないよう
		な場合に便利である。

							*zX*
zX		手動で行った折畳の開閉操作をアンドゥする: 'foldlevel' を再適用
		する。
		折畳の計算を強制するのにも使える (|zx| と同様)。

							*zm*
zm		折畳をより閉じる: 'foldlevel' を1減少させる。'foldlevel' が既
		に0ならば何も起こらない。
		'foldenable' がセット(有効化)される。

							*zM*
zM		全ての折畳を閉じる: 'foldlevel' に0を設定する。
		'foldenable' がセット(有効化)される。

							*zr*
zr		折畳をより開く: 'foldlevel' を1増加させる。

							*zR*
zR		全ての折畳を開く: 'foldlevel' に最大の折畳レベルを設定する。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		{range}の範囲の折畳を開く。[!]が付け加わると全ての折畳が開かれ
		る。{range}範囲内の全てのテキストを見るのに役立つ。[!]が無い時
		は1レベル分の折畳が開かれる。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		{range}の範囲の折畳を閉じる。[!]が付け加わると全ての折畳が閉じ
		られる。{range}範囲内の全てのテキストを隠すのに役立つ。[!]が無
		い時は1レベル分の折畳が閉じられる。

							*zn*
zn		折畳しない: 'foldenable' をリセットする。全ての折畳が開かれる。

							*zN*
zN		折畳する: 'foldenable' をセットする。全ての折畳が 'foldenable'
		がリセットされる以前と同様になる。

							*zi*
zi		'foldenable' を反転する。


折畳を超えて移動する ~
							*[z*
[z		現在の開いている折畳の先頭へ移動する。既に先頭にいるのならば、
		それを含む外側の折畳の先頭へ移動する。外側の折畳が無い場合は、
		コマンドは失敗する。
		カウントが与えられた場合には、[count]回繰り返される。

							*]z*
]z		現在の開いている折畳の末尾へ移動する。既に末尾にいるのならば、
		それを含む外側の折畳の末尾へ移動する。外側の折畳が無い場合は、
		コマンドは失敗する。
		カウントが与えられた場合には、[count]回繰り返される。

							*zj*
zj		カーソルより下方の折畳へ移動する。閉じられた折畳が1つの折畳と
		して数えられる。
		カウントが与えられた場合には、[count]回繰り返される。
		このコマンドは|operator|のように使うことができる。

							*zk*
zk		カーソルより上方の折畳へ移動する。閉じられた折畳が1つの折畳と
		して数えられる。
		カウントが与えられた場合には、[count]回繰り返される。
		このコマンドは|operator|のように使うことができる。


折畳に対してコマンドを実行する ~

:[range]foldd[oopen] {cmd}			*:foldd* *:folddoopen*
		閉じた折畳の中以外の全ての行に対して{cmd}を実行する。[range]が
		与えられた時は、その範囲だけが対象となる。
		コマンドが各行に対して実行される時にはカーソルはその対象となる
		行に置かれている。
		これは ":global" コマンドのように動作する: まず閉じられた折畳
		に入っていない全ての行がマークされる。それからマークされた全て
		の行に対して{cmd}が実行される。だから{cmd}が折畳に対して変更を
		加えても、コマンドの実行には影響が無い(もちろん行が消された時
		は除く)。
		例: >
			:folddoopen s/end/loop_end/ge
<		"e" フラグには "end" がマッチしなかった時にエラーメッセージが
		表示させない効果がある。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		閉じた折畳の中にある全ての行に対して{cmd}を実行する。
		その他は ":folddoopen" と同じ。

==============================================================================
3. 折畳オプション				*fold-options*

色							*fold-colors*

閉じられた折畳の色はFoldedグループによって設定される|hl-Folded|。折畳表示カラ
ムの色はFoldColumnグループによって設定される|hl-FoldColumn|。
色の設定例: >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white


折畳レベル						*fold-foldlevel*

'foldlevel' は数を設定するオプションである: 大きな数を設定するとより多くの折畳
が開かれる。
'foldlevel' が0の時には、全ての折畳が閉じられる。
'foldlevel' が正の時には、幾つかの折畳が閉じられる。
'foldlevel' が非常に大きい時は、全ての折畳が開かれる。
'foldlevel' は変更された時に適用される。その後に手動で折畳を開いたり閉じたりで
きる。
値を増やした時には、新しいレベルの値以上の折畳が開かれる。手動で開かれていた折
畳は閉じられない。
値を減らした時には、新しいレベルの値以上の折畳が閉じられる。手動で閉じられてい
た折畳は開かれない。


折畳テキスト						*fold-foldtext*

'foldtext' は式を指定する文字列オプションである。この式は閉じられた折畳を示す
テキストを得るために評価実行される。例: >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

これは折畳の最初の1行を、"/*" と "*/" を追加し "{{{" を削除して表示する。多め
のバックスラッシュ(\ 記号)はある文字が ":set" コマンドに解釈されてしまうのを避
けるために使用されている。これは以下のように関数を定義するとより簡単になる: >

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes . sub
    :endfunction

'foldtext' は|sandbox|環境下で実行評価される。現在のウィンドウはそのラインの属
するウィンドウへ設定される。エラーは無視される。

省略値は|foldtext()|である。これはほとんどのタイプの折畳に対して妥当なテキスト
を返す。それが気に入らないのならば、独自の式を 'foldtext' に設定することができ
る。その式中では以下の特別なVim変数を使用することができる:
	v:foldstart	折畳の先頭の行番号
	v:foldend	折畳の末尾の行番号
	v:folddashes	折畳レベルを表現したダッシュ(-)記号を含む文字列。
	v:foldlevel	折畳のレベル

結果の文字列中のタブ文字は1つの空白文字に置き換えられ、表示不可能な文字は表示
可能な文字に作り変えられる。

結果の文字列はウィンドウに合うように切り捨てられ、折り返されることはない。
テキストの後ろに余白があれば、'fillchars' で指定された文字で充たされる。

":set" コマンドが解釈してしまう文字: 空白、バックスラッシュ (\ 記号) そしてダ
ブルクォートを使う場合にはバックスラッシュが必要である。 |option-backslash|


折畳表示カラム						*fold-foldcolumn*

'foldcolumn' は、ウィンドウの端に確保される折畳を示すカラムの幅を指定する数。0
ならば、折畳表示カラムは確保されない。通常は4から5が一般的。使い物になる最小値
は2であるが、1にしてもいくらかの情報を提供する。最大値は12。

折畳表示カラムには、開いた折畳の先頭に '-' が続いて '|' が表示される。このカラ
ムは開いた折畳が終了した位置で終了する。入れ子になった折畳では、それを含む折畳
の1つ左側に表示される。

閉じた折畳は '+' で表示される。

全ての折畳を表示できないほど折畳表示カラムが狭いときには、入れ子のレベルが数字
で表示される。

折畳表示カラムをクリックすることで、マウスにより折畳を開閉することができる:
- 閉じた折畳を開くにはその行の '+' をクリックする。
- 開いた折畳を閉じるにはそれ以外の非空白文字をクリックする。


その他のオプション

'foldenable'  'fen':	無効に設定すると全ての折畳が開く。
'foldexpr'    'fde':	式("expr')による折畳で使用される。
'foldignore'  'fdi':	インデントによる折畳で使用される。
'foldmarker'  'fmr':	印による折畳で使用される印を定義する。
'foldmethod'  'fdm':	現在の折畳方法の名称。
'foldminlines' 'fml':	閉じた状態で表示されるべき折畳の、スクリーン上での最小
			行数
'foldnestmax' 'fdn':	インデント及び構文折畳での最大入れ子数
'foldopen'    'fdo':	閉じている折畳を開くコマンドの種類
'foldclose'   'fcl':	カーソルの下ではない折畳をいつ閉じるか。

==============================================================================
4. 折畳の振舞						*fold-behavior*

カーソルを上下に移動させたりスクロールさせると、カーソルは一連の折畳行の先頭へ
移動する。カーソルが既に折畳の行にあれば、カーソルは次の折畳ではない行か、閉じ
られた折畳へ移動する。

折畳の行にカーソルがある時には、カーソルは常に先頭のカラムに表示される。ルー
ラーは実際のカーソルの位置を示すが、行が折畳の場合には、そこに実際に表示するこ
とはできない。

移動コマンドは一連の折畳を空行として扱う。例えば、"w" コマンドは一旦先頭のカラ
ムで停止する。

挿入モードでは、カーソルのある行は決して折畳にならない。このため何を入力してい
るかわからなくなることはない!

オペレータを使用したときには、閉じた折畳は全体が含まれる。だから "dl" はカーソ
ルの下の閉じた折畳の全体を削除してしまう。

Exコマンドでは、開始位置と終了位置が折畳のそれに常に合わせられてしまう。
だから次のコマンド: >
	:s/foo/bar/g
カーソルを閉じた折畳に置いて実行すると、折畳内の全ての行にある "foo" が "bar"
へ置き換えられてしまう。
これは|:folddoopen|と|:folddoclosed|に対してはあてはまらない。

(同一セッション中で)以前に編集したバッファに対しては、最後の折畳設定が再び使用
される。手動折畳では以前に定義された折畳が復元される。全ての折畳方法で、手動で
開閉した折畳は復元される。同じウィンドウで同じバッファが編集される時は、以前の
編集時の値が使用される。そうでなければそのウィンドウで最後に編集されていたバッ
ファの値が使用される。

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
