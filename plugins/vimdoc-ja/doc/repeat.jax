*repeat.txt*    For Vim バージョン 7.3.  Last change: 2012 Mar 23


		VIMリファレンスマニュアル    by Bram Moolenaar


繰り返しコマンド、Vimスクリプトとデバッグ		*repeating*

繰り返しについてはユーザーマニュアルの26章|usr_26.txt|に紹介がある。

1. 単発繰り返し		|single-repeat|
2. 多重繰り返し		|multi-repeat|
3. 複雑な繰り返し	|complex-repeat|
4. Vimスクリプトを使う	|using-scripts|
5. スクリプトのデバッグ	|debug-scripts|
6. プロファイリング	|profiling|

==============================================================================
1. 単発繰り返し						*single-repeat*

							*.*
.			最後の変更を繰り返す。変更の回数は[count]で指定した回
			数で置き換えられる。'cpoptions' に 'y' フラグが含まれ
			てる時には、ヤンクコマンドも繰り返す。コマンドラインコ
			マンドは繰り返さない。

単純な変更は "." コマンドで繰り返すことができる。回数を指定しなければ、最後の
変更の回数が使用される。回数を指定した場合、最後のそれと置き換えられる。最後に
行なわれた変更が番号付きレジスタの指定を含んでいた場合、レジスタ番号は増加され
る。これをどのように使うかの例は|redo-register|を参照。ビジュアル選択を使用し
たコマンドを繰り返す時は、同じ「サイズ」の範囲が使用されることに注意。
|visual-repeat|を参照。

							*@:*
@:			最後のコマンドラインを[count]回繰り返す。
			{|+cmdline_hist|が無効にされていると使えない}


==============================================================================
2. 多重繰り返し						*multi-repeat*

					*:g* *:global* *E147* *E148*
:[range]g[lobal]/{pattern}/[cmd]
			[range]の範囲で{pattern}にマッチする行に対して、Exコマ
			ンド[cmd](省略した場合 ":p")を実行する。

:[range]g[lobal]!/{pattern}/[cmd]
			[range]の範囲で{pattern}にマッチしない行に対して、Exコ
			マンド[cmd](省略した場合 ":p")を実行する。

							*:v* *:vglobal*
:[range]v[global]/{pattern}/[cmd]
			:g! と同じ。

{patter} の両側の '/' の代わりにどんなシングルバイト文字でも使うことができる。
しかしアルファベット・数字・'\', '"', '|' は使えない。
これは、検索パターンや置換文字列に '/' が含まれる場合に便利である。

パターンの定義については |pattern|を参照。

globalコマンドの動作はまず第1に[range]の行をスキャンしマッチした行すべてに印を
つける(複数行にかかるパターンではマッチの最初の行だけが重要である)。
次のスキャンでマークされたすべての行の行番号が指定(前置)されて[cmd]が実行され
る。行が変更されたり削除された場合そのマークは消滅する。
省略した場合の[range]はバッファ全体(1,$)である。コマンドを中断するには "CTRL-C"
を使用する。ある行についてエラーメッセージが与えられると、そのラインに対するコ
マンドは中断されglobalコマンドはマッチした次の行の処理を続ける。

非Exコマンドを繰り返すには ":normal" コマンドを使用すれば良い: >
	:g/pat/normal {commands}
{commands}が完全なコマンドとして終了することを確認すること。そうでないとVimは
全部のマッチに1つ1つについて、コマンドの残りを期待して貴方の入力を待ち続けるだ
ろう。画面は更新されないので、いま何をしているのかわからないだろう。|:normal|
を参照。

undo/redoコマンドはglobalコマンドを一度にundo/redoする。以前の文脈マークだけが
一度設定される("''" でグローバルコマンド実行前にカーソルがあった場所に戻ること
が出来る)。

globalコマンドは最後に使用した検索パターンと、最後に使用した置換パターンの両方
を設定する (これはvi互換)。これにより全体に対して文字列置換を行うのが簡単にな
る:
	:g/pat/s//PAT/g
これは全ての "pat" を "PAT" に置き換える。同じことがこれでも可能:
	:%s/pat/PAT/g
こっちのほうが2文字短い!

Ex モード中で "global" を使い、そのコマンドに ":visual" を指定する場合はやや特
殊である。これを行うと、マッチする行へ移動してノーマルモードに入るので、|Q| を
押して Ex モードへ戻るまでコマンドを実行することができる。これがマッチする各行
に対して繰り返される。これを行っている間は ":global" を使うことはできない。中
止するには CTRL-C を2回押すこと。

スペースが必要な場合には、バックスラッシュの直後に書くのがベストである。行末に
スペースを書くと、視認が難しく、誤って削除されてしまうかもしれない。 >
	:syn match Comment
		\ "very long regexp"
		\ keepend

==============================================================================
3. 複雑な繰り返し					*complex-repeat*

							*q* *recording*
q{0-9a-zA-Z"}		タイプした文字をレジスタ{0-9a-zA-Z"}にレコーディングす
			る(大文字なら追記)。レジスタを実行中は 'q' コマンドは
			無効化される。マッピングや |:normal| の中でも機能しな
			い。{Vi: レコーディングはない}

q			レコーディングを終了する。(実装のメモ: レコーディング
			を終了する 'q' は、それがマッピングの結果であってもレ
			ジスタに記録されない) {Vi: レコーディングはない}

							*@*
@{0-9a-z".=*+}		レジスタ {0-9a-z".=*+} の内容を [count] 回実行する。
			Note: レジスタ '%' (現在のファイルの名前) と '#' (オル
			タネートファイルの名前) は使用できない。
			レジスタはマッピングと同様に実行される。つまり、
			'wildchar' と 'wildcharm' の違いが動作に影響する。
			"@=" を使用すると式を入力するためのプロンプトが表示さ
			れ、そこに入力した式の評価結果が実行される。
			|@:| も参照。  {Vi: 名前付きレジスタのみ}

							*@@* *E748*
@@			直前の @{0-9a-z":*} を [count] 回繰り返す。

:[addr]*{0-9a-z".=+}						*:@* *:star*
:[addr]@{0-9a-z".=*+}	レジスタ{0-9a-z".=*+}の内容をExコマンドとして実行する。
			まず最初にカーソルを[addr]行に設定する(省略した場合現
			在の行)。レジスタの最終行に<CR>が含まれない場合、
			'cpoptions' に 'e' フラグが含まれていれば自動的に追加
			される。
			":*" コマンドは 'cpoptions' に '*' フラグが含まれてい
			た場合にだけ認識されることに留意。これは
			'nocompatible' が使用されている時にはデフォルトにはな
			らない。
			":@=" には最後に評価された式が使用される。式の評価結果
			がExコマンドとして実行される。
			これらのコマンド内ではマッピングは行われない。
			{Vi: 幾つかのバージョンだけ} 将来: 指定された範囲の
			各々の行に対してレジスタの内容が実行されるだろう。

							*:@:*
:[addr]@:		最後のコマンドラインを繰り返す。まずカーソルを[addr]行
			に設定する(省略した場合現在の行)。 {Vi にはない}

							*:@@*
:[addr]@@		最後の :@{0-9a-z"} を繰り返す。まず最初にカーソルを
			[addr]行に設定する(省略した場合現在の行)。 {Vi: 幾つか
			のバージョンだけ}

==============================================================================
4. Vimスクリプトを使う					*using-scripts*

Vimスクリプトの書き方はユーザーマニュアルの41章|usr_41.txt|を参照してくださ
い。

					*:so* *:source* *load-vim-script*
:so[urce] {file}	Exコマンドを{file}から読込む。これは ":" で始まるコマ
			ンドを列挙したファイルである。
			{訳注: 実際に ":" を書く必要はない}
			自動コマンド |SourcePre| が発生する。

:so[urce]! {file}	Vimコマンドを{file}から読込む。ノーマルモードでファイ
			ルの内容をあなたがタイプしたのと同じように実行されな
			い。
			|:global|, |:argdo|, |:windo|, |:bufdo|で使ったとき、
			ループ中や他のコマンドが続けられたときは、コマンドの実
			行中は表示は更新されない。
			{Vi にはない}

							*:ru* *:runtime*
:ru[ntime][!] {file} ..
			'runtimepath' で示された各ディレクトリの{file}からExコ
			マンドを読み込む。ファイルがなくてもエラーにはならな
			い。例: >
				:runtime syntax/c.vim

<			{file}には空白で区切って複数のファイルを指定できる。指
			定された{file}は 'runtimepath' の最初のディレクトリ、
			次に二番目のディレクトリ、と検索される。{file}に空白を
			含めるにはバックスラッシュを使う(しかしファイル名に空
			白を含めるのは望ましくない。トラブルのもとである)。

			[!] を付けると見つかった全てのファイルを読み込む。付け
			なければ最初に見つかったファイルだけを読み込む。

			{file}がワイルドカードを含んでいるとそれは展開される。
			例: >
				:runtime! plugin/*.vim
<			これはVimが起動時にプラグインファイルを読み込むのに使っ
			ているものである。次のは似ているが: >
				:runtime plugin/*.vim
<			これは最初に見つかったファイルだけを読み込む。

			'verbose' が1以上ならファイルが見つからないときにメッ
			セージが表示される。
			'verbose' が2以上なら見つかった全てのファイルについて
			メッセージが表示される。
			{Vi にはない}

:scripte[ncoding] [encoding]		*:scripte* *:scriptencoding* *E167*
			スクリプトで使われている文字コードを宣言する。
			それ以降の行は必要なら [encoding]から 'encoding' オプ
			ションの文字コードに変換される。例: >
				scriptencoding iso-8859-5
				scriptencoding cp932
<
			[encoding]が空のときは変換はされない。これは文字コード
			の変換を限定するために使う: >
				scriptencoding euc-jp
				... 変換される ...
				scriptencoding
				... 変換されない ...

<			変換がシステムによって提供されない場合、エラーメッセー
			ジは表示されず変換もされない。

			"ucs-2" や "ucs-4" を使わないこと。スクリプトをその文
			字コードで書くことはできない (NULバイトが含まれてしま
			うため)。
			スクリプトの最初にutf-8のBOM (Byte Order Mark: バイト
			オーダーマーク) があるとVimはそれを認識する。
			":scriptencoding utf-8" と書く必要はない。

			Vimが|+multi_byte|付きでコンパイルされていない場合、こ
			のコマンドは無視される。
			{Vi にはない}

						*:scrip* *:scriptnames*
:scrip[tnames]		読み込まれているスクリプトを読み込まれた順番どおりに
			全て表示する。数字はスクリプトのID(識別子)|<SID>|に使
			われている。
			{Vi にはない} {|+eval|付きでコンパイルしないと使えない}

						*:fini* *:finish* *E168*
:fini[sh]		スクリプトの読み込みを停止する。スクリプトファイルでの
			み使える。これはファイルの残りを読み込ませないための手
			軽な方法である。|:try|を使った後で|:finally|を見つける
			前に使われると、まず ":finally" と|:endtry|の間のコマン
			ドが実行される。この手続きは入れ子になっている全ての
			":try" に対して適用される。入れ子の一番外側の ":endtry"
			に達するとスクリプトを停止する。
			{Vi にはない}

全てのコマンドとコマンドシーケンスは、名前付きレジスタに格納することで繰り返し
実行することができる。レジスタにコマンドを格納する方法は2つある:
- 記録コマンド "q" を使用する。実際にコマンドをタイプし、実行しながらそれをレ
  ジスタに格納する。今、何が起こっているかを確認できるので簡単である。間違いを
  したならば、レジスタの内容をいったんファイルへ書き出("p"ut)して、コマンドシー
  ケンスを編集して、それからそれを削除して再びレジスタに格納することができる。
  レジスタに追加することで継続してレコーディングすることができる(大文字を使用
  する)。
- コマンドシーケンスを削除かヤンクしてレジスタに入れる。

良く使うコマンドは ':map' コマンドでファンクションキーに割当てることができる:

別の方法としてコマンドをファイルに記述しておき、それを ':source!' コマンドで読
込んで実行するという方法もある。長いコマンドシーケンスにとっては便利である。
ファンクションキーに複雑なコマンドを割当てるために ':map' コマンドと組み合わせ
ることができる。

':source' コマンドはファイルから一行ずつExコマンドを読込む。キーボード入力が必
要になった場合にはタイプする必要が生じる。':source!' コマンドはスクリプトファ
イルから一字一句読込む。各々のキャラクタはユーザがタイプしたものとして解釈され
る。

例: ":!ls" コマンドを実行したとすると|hit-enter|プロンプトが表示される。"!ls"
を含むファイルを ':source' したならば、自分で<Enter>をタイプする必要があるだろ
う。しかし ':!ls' を含んだファイルを ':source!' したならば、<CR>が見つかるまで
そのファイルから続く文字が読込まれる。":!ls" がファイルの最終行でない限り、
<CR>を自分でタイプする必要はないだろう。

スクリプトファイルの中で ':source[!]' コマンドを使うことも可能なので、階層関係
のあるスクリプトファイルを作ることもできる。':source' コマンドは同時に開くこと
のできるファイル数(だいたい15)と同じだけネスト(入れ子に)することができる。
':source!' コマンドは15段までネストすることができる。

読込まれるファイルの中ではファイル名が必要なところに、"<sfile>" という文字列
(文字通りであってスペシャルキーではない)を使うことができる。この文字列は読込ま
れたファイルのファイル名に置き換えられる。例えば、".vimrc" ファイルと同じ場所
に "other.vimrc" というファイルがあれば、".vimrc" から次のコマンドでそれを読込
むことができる: >
	:source <sfile>:h/other.vimrc

スクリプトファイル内では端末依存のキーコードは端末非依存の2文字のコードで表現
される。これは異なる種類の端末でも同じ方法で依存キーコードを使用できることを意
味する。最初のキーコードの文字は0x80つまり128で、画面では "~@" と表される。2つ
目のキャラクタは|key-notation|の表にて見ることができる。これらのコードはどれも
CTRL-Vに続けて3つの10進コードを叩くことで入力できる。これはtermcapコード<t_xx>
に対しては使用できない。これらはマッピングの中だけで使うことができる。

						*:source_crnl* *W15*
MS-DOS, Win32 and OS/2: ":source" で読込まれるファイルは通常、行末に<CR><NL>を
持っている。これらは常に働く。もしも行末に<NL>を持つファイルを使っているならば
(例えばUNIXで作られたファイル)、'fileformats' が空でかつ先頭行が<CR>で終わって
なければ正しく認識される。しかしこれは先頭行が ":map <F1> :help^M" (^Mは<CR>)
みたいな内容だった場合には失敗する。ファイルの先頭行が<CR>で終わっていてその1
行限りの時、先頭行から<CR>が失われてしまうのでエラーメッセージが出るだろう。

Mac Classic: ":source" で読み込まれるファイルは通常、行末に<CR>を持っている。
これらは常に機能する。もしも行末に<NL>を持つファイルを使っているならば(例えば
UNIXで作られたファイル)、'fileformats' が空でかつ先頭行が<CR>で終わってなけれ
ば正しく認識される。先頭行に<CR>を持ち<NL>で改行しているファイルを使用しないよ
うに気を付けること。

その他のシステムでは、Vimは ":source" で読込まれたファイルの行末は<NL>であるこ
とを期待する。これは常に働く。もしも行末が<CR><NL>であるファイル(例えばMS-DOS
で作られたファイル)を使っているならば、全ての行が末尾に<CR>を持っていることに
なる。これは幾つかのコマンドにとって問題となるだろう(例、マッピング)。自動的に
行末記号を検出する機構はない。なぜなら<CR>で終了するマッピングの定義をファイル
の先頭に書くことは一般的で、自動検出用の仕組みを作るのが難しいからである。

							*line-continuation*
":source" で読込まれたExコマンドスクリプトのファイル内の長い行は、行継続記号
"\" (backslash) を次行の先頭に挿入することで分割できる。バックスラッシュの前に
空白を挿入することも可能で、これらは無視される。

例: 次の記述は >
	:set comments=sr:/*,mb:*,el:*/,
		     \://,
		     \b:#,
		     \:%,
		     \n:>,
		     \fb:-

次の1行と同じ意味として解釈される: >
	:set comments=sr:/*,mb:*,el:*/,://,b:#,:%,n:>,fb:-

バックスラッシュの前に先行する空白文字は全部無視される。しかしながらバックス
ラッシュのある行の1つ前の行末には、自由に空白文字を挿入することはできない; 付
加的な空白文字が許されるかどうかは、コマンドが分割される位置に依存する。

":append" と ":insert" コマンドには1つ問題がある: >
   :1append
   \asdf
   .
バックスラッシュは行継続シンボルに見えるが、コマンドの結果はこのようになる: >
   :1appendasdf
   .
これを避けるには、'cpoptions' に 'C' フラグを追加することだ: >
   :set cpo+=C
   :function Foo()
   :1append
   \asdf
   :.
   :set cpo-=C

Note 関数の中でその手のコマンドを実行するには、関数定義の際に 'C' フラグを追加
する必要があり、それが実行される際にではない。
   :set cpo+=C
   :function Foo()
   :1append
   \asdf
   .
   :endfunction
   :set cpo-=C

解説:
	多くのプログラムは行継続を、継続する行の末尾にバックスラッシュを置くこ
	とで表現する。その方法をVimで採用してしまうと、Viとの互換性に重大な欠
	陥ができてしまう。たとえばこのようなViのマッピングを考えるとわかりやす
	い: >
		:map xx  asdf\
<	従って一般的ではないが行頭のバックスラッシュを採用している。

==============================================================================
5. スクリプトのデバッグ					*debug-scripts*

スクリプトの動作を知るためのコードを追加することができるのは当り前として、Vim
はデバッグモードを提供している。これはスクリプトファイルやユーザーファンクショ
ンをステップ実行することやブレークポイントを仕掛けることを可能にする。

NOTE: デバッグモードは未完成である。デバッグはVimの動作に副作用をあたえる。全
てをデバッグするのには使えない。例えば画面がデバッグメッセージで散乱するときな
ど。
{Vi にはデバッグモードはない}

デバッグモードの代わりに 'verbose' オプションが使える。大きな値を設定するとVim
の動作についてより詳細なメッセージを得られる。


デバッグモードを開始する					*debug-mode*

デバッグモードを開始するにはこれらの方法のうちどれかを使う:
1. Vimを|-D|引数付きで起動する: >
	vim -D file.txt
<  最初にvimrcを読み込むところからデバッグを開始する。これはVimの起動時に何が
   起こっているのかを調査するのに便利である。副作用としてVimは初期化が完了する
   前に安全のためターミナルモードを切替える。
   (WindowsやMacintoshの)GUI専用バージョンではGUIウィンドウを開くとすぐにデバッ
   グが開始する。これを早めるにはvimrcファイルに ":gui" と書くこと。
								*:debug*
2. ":debug" を前に付けてコマンドを実行する。そのコマンドを実行する間だけデバッ
   グできる。特定のスクリプトファイルやユーザー関数をデバッグするのに便利であ
   る。オートコマンドから呼び出されるスクリプトや関数にも便利である。例: >
	:debug edit test.txt.gz

3. ブレークポイントをソースファイルやユーザーファンクションに設定する。コマン
   ドラインから次のようにできる: >
	vim -c "breakadd file */explorer.vim"
<  これはVimを起動して "explorer.vim" の最初の行を読み込むところで停止する。デ
   バッグモード中でもブレークポイントを設定できる。

デバッグモード中に実行されるコマンドはそれが実行される前に表示される。コメント
や空の行、実行されない行は飛ばされる。行が "|" を使って二つのコマンドを含んで
いた場合には分けて表示される。


デバッグモード
--------------

デバッグモードに入ると、通常のExコマンドが使える。例えば、変数の値を見るには: >
	echo idx
ユーザーファンクション内では、これはローカル変数の "idx" を表示する。"g:" を頭
に付けるとグローバル変数の値を表示する: >
	echo g:idx
全てのコマンドは実行中の関数やスクリプトの文脈として実行される。オプションを設
定することもできる。例えば何が起こっているのかを表示するために 'verbose' を設
定することができる。興味のある部分を実行する前に次のようにするといいだろう: >
	:set verbose=20

スクリーンの更新を必要とするコマンドは避けるべきである。なぜならデバッグモード
を抜けるまでその作用に気付き難いからである。例えば: >
	:help
これはとても不便である。

デバッグモードのためのコマンドラインヒストリが別に用意されている。

関数の行番号はその関数の始まりから数える。見ている行の番号を数えるのに苦労する
場合はその関数の書かれたファイルを別のVimで開き、その関数の始まりを探しだし、
"99j" を実行すること。"99" は実際の行番号に合わせて変えること。

さらに、以下のコマンドが使える:
							*>cont*
	cont		次のブレークポイントまで実行する。
							*>quit*
	quit		異常停止する。これはCTRL-Cを使うことに似ているが、全て
			を停止するわけではない。次のブレークポイントで停止す
			る。
							*>next*
	next		コマンドを実行しそれが終わるとデバッグモードに戻る。
			ユーザー関数やソースファイルの呼び出し時には呼び出し元
			の次の行に進む。
							*>step*
	step		コマンドを実行しそれが終わるとデバッグモードに戻る。
			ユーザー関数やソースファイルの呼び出し時には呼び出し先
			の行に進む。
							*>interrupt*
	interrupt	CTRL-C を使うことに似ているが、次のコマンドを実行する
			ためにデバッグモードに戻る場所が ">quit" と違う。例外
			割り込みについて|:finally|や|:catch|をテストするのに便
			利である。
							*>finish*
	finish		実行中のスクリプトやユーザー関数を終了し呼び出し元でデ
			バッグモードに戻る。

デバッグモードのコマンドについて:
- 補完はできない。通常のExコマンドのみ補完できる。
- 次の一文字に省略すことができる: "c", "n", "s" そして "f"。
- <CR>を押すと前回のものを繰り返す。関係ないコマンドを使うとリセットされる
  (どうすべきかがわかりにくいため)。
- 同じ名前のExコマンドを使うにはコロンを付けること:
  ":cont", ":next", ":finish" (省略時も)


ブレークポイントの定義
----------------------
							*:breaka* *:breakadd*
:breaka[dd] func [lnum] {name}
		関数にブレークポイントを設定する。例: >
			:breakadd func Explore
<		関数名が妥当かどうか検査しないので、関数定義の前にブレークポイ
		ントを定義できる。

:breaka[dd] file [lnum] {name}
		ソースファイルにブレークポイントを設定する。例: >
			:breakadd file 43 .vimrc

:breaka[dd] here
		カレントファイルのカレント行にブレークポイントを設定する。
		次を行うのと同様である: >
			:breakadd file <cursor-line> <current-file>
<		Note これはファイルを読み込むときに実行されるコマンドに対して
		だけ働く。そのファイル中で定義される関数に対しては働かない。

[lnum] はブレークポイントにする行番号である。Vimはその行かそれ以降で停止する。
省略時すると1行目になる。

							*:debug-name*
{name} はファイル名や関数名のパターンである。パターンはオートコマンドで使われ
るものと同じである。完全に一致しなければならない (パターンが "^" で始まって
"$" で終わるように)。"*" は全ての文字列に一致する。'ignorecase' は使われない
が、大文字と小文字を区別しないために "\c" を使うことができる|/\c|。関数名には()
を付けないように!

ソースファイル名のパターン検査はファイルのフルネームに対して行われる。例: >
	breakadd file explorer
パスが間違っているので一致しない。 >
	breakadd file *explorer.vim
".../plugin/explorer.vim" と ".../plugin/iexplorer.vim" に一致する。 >
	breakadd file */explorer.vim
".../plugin/explorer.vim" だけに一致する。

関数名のパターン検査は ":function" で表示される名前に対して行われる。ローカル
関数には "<SNR>99_" といったものが前に付くということである。

Note 関数はまず読み込まれ、後で実行される。読み込まれたときに "file" ブレーク
ポイントがチェックされ、実行されるときに "func" ブレークポイントがチェックされ
る。

ブレークポイントの削除
----------------------
						*:breakd* *:breakdel* *E161*
:breakd[el] {nr}
		ブレークポイント{nr}を削除する。|:breaklist|を使って番号を確認
		できる。

:breakd[el] *
		すべてのブレークポイントを削除する。

:breakd[el] func [lnum] {name}
		関数内のブレークポイントを削除する。

:breakd[el] file [lnum] {name}
		ソースファイル内のブレークポイントを削除する。

:breakd[el] here
		カレントファイルのカレント行のブレークポイントを削除する。


[lnum] が省略されると関数、またはファイルの最初のブレークポイントが削除される。
{name} は ":breakadd" で使った名前と完全に同じでなければならない。"explorer"
と "*explorer.vim"、"*explorer*" は違う。


ブレークポイントを列挙する
--------------------------
							*:breakl* *:breaklist*
:breakl[ist]
		全てのブレークポイントを列挙する。


その他
------

						*:debugg* *:debuggreedy*
:debugg[reedy]
		デバッグモードのコマンドをユーザーから直接得るのではなく標準入
		力から読み込む。スクリプトのテストのときに便利である。
		例: >
		  echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim

:0debugg[reedy]
		":debuggreedy" を取り消す。それ以降のデバッグモードコマンドを
		使わず、ユーザーから直接デバッグモードコマンドを受け取る。

==============================================================================
6. プロファイリング						*profile* *profiling*

プロファイリングとは、関数やスクリプトの実行にかかる時間を計測することである。
これを行うには |+profile| 機能が必要である。
この機能は "huge" 機能つきでコンパイルしたときだけ含まれる。
{Vi はプロファイリング機能を持っていない}

また、関数 |reltime()| を使っても時間を計測できる。この関数には |+reltime| 機
能だけが必要である。これは "huge" 以外でもしばしばついてくる。

:prof[ile] start {fname}			*:prof* *:profile* *E750*
		プロファイリングを開始し、終了時に出力を {fname} に出力する。
		{fname} がすでに存在するときは、警告なしに上書きされる。
		変数 |v:profiling| に 1 が代入される。

:prof[ile] continue
		":profile pause" の後にこれを実行すると、プロファイリングを再
		開する。

:prof[ile] func {pattern}
		パターン {pattern} にマッチする関数をプロファイリングする。
		{pattern} がどう使われるかは |:debug-name| を参照。

:prof[ile][!] file {pattern}
		パターン {pattern} にマッチするスクリプトファイルをプロファイ
		リングする。
		{pattern} がどう使われるかは |:debug-name| を参照。
		このコマンドはスクリプトそのものをプロファイリングするだけで、
		その中で定義されている関数のプロファイリングは行わない。
		[!] がつけられたときは、そのスクリプト中で定義されている全ての
		関数のプロファイリングも行う。しかしスクリプトがこのコマンドの
		後で読み込まれたときだけである。

:profd[el] ...						*:profd* *:profdel*
		指定された引数に対するプロファイリングを停止する。引数について
		は |:breakdel| を参照。

最初は常に ":profile start fname" コマンドで始めなければならない。結果のファイ
ルは Vim が終了するときに書き出される。次に出力の例を挙げる。説明のために行番
号が行頭についている:

  1 FUNCTION  Test2() ~
  2 Called 1 time ~
  3 Total time:   0.155251 ~
  4  Self time:   0.002006 ~
  5  ~
  6 count  total (s)   self (s) ~
  7	9	       0.000096   for i in range(8) ~
  8	8   0.153655   0.000410     call Test3() ~
  9	8	       0.000070   endfor ~
 10				  " Ask a question ~
 11	1	       0.001341   echo input("give me an answer: ") ~

ヘッダ (1行目から4行目) は関数全体にかかった時間を示している。"Total" はこの関
数を実行している間に経過した時間である。"Self" は "Total" のうち、次のことにか
かった時間を引いたものである:
- 他のユーザ定義関数
- スクリプトの読み込み
- 自動コマンドの実行
- 外部(シェル)プログラム
  
7行目から11行目は各実行行にかかった時間を示している。実行されない行はカウント
されない。それゆえ、コメント行は決してカウントされない。

Count の桁はその行が何回実行されたかを示す。7行目の "for" コマンドはそれ以下の
行と同様に何回も実行されることに注意すること。これは、ループの終わりを検出する
ためにこの行が何回も実行されるためである。

ユーザ入力待ちにかかった時間は一切カウントされない。それゆえ、input() のプロ
ンプトに反応するのにどれだけ時間がかかろうとも無関係である。

プロファイリングはどこで時間が費やされたかのよい指標を与えてくれるが、多くの
原因によりその結果がごまかされてしまう場合があるということを覚えておくように:

- システム関数 gettimeofday() に依存する時間計測の精度。たとえ時間がマイクロ秒
  で表示されていたとしても、1/100秒の精度しかないこともある。

- 実経過時間が計測される。他のプロセスがビジーであると、それが予測できない箇
  所で遅れを引き起こす可能性がある。
  
- 1行に複数のコマンドを書いていると、1つの時間しか得られない。ここのコマンド
  に対して時間を見るにはその行を分割すること。
  
- 各行の時間の総和をとると、たいてい関数全体の時間より小さくなる。各行の間
  にオーバーヘッドがある。

- Vim が終了する前に削除された関数はプロファイリング情報を生成しない。必要な
  ら変数 |v:profiling| をチェックすること: >
	:if !v:profiling
	:   delfunc MyFunc
	:endif
<
- マルチプロセッサシステム上では、スリープモードが作動したときや、省力のためプ
  ロセッサの周波数が下がったとき、プロファイリングが奇妙な結果を出すかもしれな
  い。

- 関数が再帰的に呼ばれた場合、"self" 時間は正しくない。
 

 vim:tw=78:ts=8:ft=help:norl:
