*pattern.txt*   For Vim バージョン 7.4.  Last change: 2014 Feb 08


		  VIMリファレンスマニュアル	  by Bram Moolenaar


パターンと検索コマンド					*pattern-searches*

最も基本的な説明はユーザーマニュアルの |03.9| にあります。
27章 |usr_27.txt| にも説明があります。

1. 検索コマンド			|search-commands|
2. パターンの定義		|search-pattern|
3. Magic			|/magic|
4. パターンの概要		|pattern-overview|
5. 量指定子			|pattern-multi-items|
6. 普通のアトム			|pattern-atoms|
7. 大文字と小文字を無視する	|/ignorecase|
8. 合成文字			|patterns-composing|
9. Perl のパターンとの比較	|perl-patterns|
10. マッチしたテキストを強調する|match-highlight|

==============================================================================
1. 検索コマンド					*search-commands*

							*/*
/{pattern}[/]<CR>	[count] 番目にマッチする {pattern} を前方検索します。
			|exclusive|(排他的)

/{pattern}/{offset}<CR> [count] 番目にマッチする {pattern} を前方検索し、
			|{offset}| 行だけ上/下に移動します。|linewise|(行指向)

							*/<CR>*
/<CR>			[count] 番目にマッチする最終検索パターン|last-pattern|
			を、最後に使われた|{offset}|を使って、前方検索します。

//{offset}<CR>		[count] 番目にマッチする最終検索パターン|last-pattern|
			を、新しい |{offset}| を使って前方検索します。
			{offset} を指定しなかった場合、 |{offset}| は使われま
			せん。

							*?*
?{pattern}[?]<CR>	[count] 番目にマッチする {pattern} を後方検索します。
			|exclusive|(排他的)

?{pattern}?{offset}<CR> [count] 番目にマッチする {pattern} を後方検索して
			|{offset}| 行だけ上/下に移動します。|linewise|(行指向)

							*?<CR>*
?<CR>			[count]番目にマッチする最終検索パターン|last-pattern|
			を、最後に使われた|{offset}|を使って、後方検索します。

??{offset}<CR>		[count]番目にマッチする最終検索パターン|last-pattern|
			を、新しい |{offset}| を使って後方検索します。
			{offset} を指定しなかった場合、 |{offset}| は使われま
			せん。


							*n*
n			最後の "/" か "?" を [count] 回繰り返します。
			|last-pattern| {Vi: カウントの前置を受け付けません}

							*N*
N			最後の "/" か "?" を逆方向に [count] 回繰り返します。
			|last-pattern| {Vi: カウントの前置を受け付けません}

							*star* *E348* *E349*
*			[count] 番目にマッチする単語を前方検索します。検索され
			る単語は、カーソルに最も近い単語です。次の順番で選択さ
			れます:
				1. カーソル位置のキーワード |'iskeyword'|
				2. 現在行の、カーソルの前方のキーワード
				3. カーソル位置の単語 (|WORD|)
				4. 現在行の、カーソルの前方の単語
			"/\<keyword\>" と検索するのと同じように、完全なキー
                        ワードのみ検索されます。|exclusive|(排他的)
			{Vi にはありません}
			'smartcase' ではなく 'ignorecase' の設定が使われます。

							*#*
#			"*" と同じですが、後方検索します。ポンド記号 (文字コー
			ド 163) でも動作します。"#" キーがバックスペースとして
			動作する場合は、 Vim を起動する前に "stty erase <BS>"
			としてみてください (<BS> は CTRL-Hもしくは本当のバック
			スペースです)。  {Vi にはありません}

							*gstar*
g*			"*" と似ていますが "\<" と "\>" を単語の周りに加えませ
			ん。つまり単語の一部にマッチするものを検索することもで
			きます。  {Vi にはありません}

							*g#*
g#			"#" と似ていますが "\<" と "\>" を単語の周りに加えませ
			ん。つまり単語の一部にマッチするものを検索することもで
			きます。  {Vi にはありません}

							*gd*
gd			ローカル宣言を検索します。カーソルがローカル変数の上に
			ある場合、その変数の宣言にジャンプします。はじめに、
			Vim は現在の関数の開始行を検索します ("[[" コマンドと
			同じ)。見つからなかった場合は、ファイルの 1 行目に移動
			します。見つかった場合は、その場所から空行を後方検索し
			ます。そして、"*" コマンドで検索するのと同じように、
			キーワードを検索します。このとき、コメントと判断した行
			は無視します('comments' オプション参照)。
			Note: Vim は文法を実際にチェックしているわけではなく、
			キーワードにマッチするものを検索しているだけですので、
			これがうまく動作するとは限りません。インクルードされて
			いるファイル内も検索したい場合は、|include-search| で
			列挙されているコマンドを使ってください。
			このコマンドを実行した後、コマンド|n|で次のマッチを前
			方検索できます。
			{Vi にはありません}

							*gD*
gD			グローバル宣言を検索します。ファイル内で定義されている
			グローバル変数の上にカーソルがある場合、その宣言にジャ
			ンプします。"gd" と同じですが、このコマンドは常に 1 行
			目からキーワードを検索します。
			{Vi にはありません}

							*1gd*
1gd			"gd" と同じですが、現在のカーソル位置より前の {} ブ
			ロック内を無視します。{Vi にはありません}

							*1gD*
1gD			"gD" と同じですが、現在のカーソル位置より前の {} ブ
			ロック内を無視します。{Vi にはありません}

							*CTRL-C*
CTRL-C			現在の(検索)コマンドを中止します。MS-DOSではCTRL-Break
			を使ってください |dos-CTRL-Break|。
			ノーマルモードでは、入力済みの、まだ実行されていないコ
			マンドをすべて中止します。

							*:noh* *:nohlsearch*
:noh[lsearch]		'hlsearch' オプションによる強調表示をやめます。検索コ
			マンドを使うか、'hlsearch' をオンに設定すると、再び強
			調表示されます。このコマンドはオートコマンド中は機能し
			ません。オートコマンドを実行する時に強調表示の状態を保
			存し、実行後に元に戻すからです。|autocmd-searchpat|
			ユーザー関数を呼び出したときも同様。

'incsearch' オプションがオンの場合、検索パターンを入力している途中に、その時点
でマッチしているものが強調表示されます。実際に、その場所にカーソルを移動させる
には <CR> を打って検索を終了する必要があります。検索を中止するには <Esc> キー
を使ってください。

'hlsearch' オプションがオンの場合、最後に使った検索パターンは強調表示されます。
|:nohlsearch| コマンドを使うと、一時的に強調表示をやめさせることができます。

マッチが見つからなかった場合はエラーが表示されます: *E486* Pattern not found
Note: |:global| コマンドではこの動作はノーマルメッセージと同じです (Vi 互換の
ため)。|:s| コマンドでは "e" フラグを指定することでエラーメッセージを抑制でき
ます |:s_flags|。

					*search-offset* *{offset}*
上記の検索コマンドは指定されたパターンを検索します。"/" と "?" ではさらにオフ
セットを指定できます。オフセットには、行オフセットと文字オフセットの 2 種類あ
ります。 {Vi には文字オフセットはありません}

オフセットを指定して、マッチした場所から相対的にカーソルを移動できます:
    [num]	[num]行下、1 桁目に移動
    +[num]	[num]行下、1 桁目に移動
    -[num]	[num]行上、1 桁目に移動
    e[+num]	[num]文字右に、マッチ部分の終わりの場所から移動
    e[-num]	[num]文字左に、マッチ部分の終わりの場所から移動
    s[+num]	[num]文字右に、マッチ部分の初めの場所(start)から移動
    s[-num]	[num]文字左に、マッチ部分の初めの場所(start)から移動
    b[+num]	[num] 上記 s[+num] と同じ (begin の b)
    b[-num]	[num] 上記 s[-num] と同じ (begin の b)
    ;{pattern}  さらに検索する。|//;|を参照。

'-' か '+' を指定して [num] を省略した場合は 1 が使われます。'e' を使ってオフ
セットを指定した場合、検索は包括的になります (カーソルが移動するであろう位置の
文字まで含めて操作の対象になります)。

例:

パターン		カーソルの位置 ~
/test/+1		"test" の 1 行下の 1 桁目
/test/e			"test" の最後
/test/s+2		"test" の 's'
/test/b-3		"test" の 3 文字前

これらのコマンドが演算コマンドに対して使われた場合、現在のカーソル位置から、検
索後のカーソル位置までが、操作の対象となります。ただし、行オフセットが指定され
た場合は、2 つのカーソル位置の間の行全体が操作の対象となります。

パターンを検索して置換する例: >
	/foo<CR>	"foo" を検索
	c//e<CR>	マッチした文字列を変更
	bar<Esc>	置換する文字を入力
	//<CR>		次のマッチへ移動
	c//e<CR>	マッチした文字列を変更
	beep<Esc>	今度は別の文字で置換
			...
<
							*//;* *E386*
非常に特殊なオフセットですが、';' に続けて検索コマンドを指定できます。例: >

   /test 1/;/test
   /test.*/+1;?ing?

一つ目の例は、はじめに次の "test 1" を検索し、それから "test" を検索します。

これは、2 つの検索コマンドを分けて実行するのと似ていますが、次の点が違います:
- 合わせて 1 つの検索コマンドなので、演算コマンドに対して使うことができます。
- "n"、"N" コマンドを使った場合、検索方向は最初の検索コマンドと同じです。
- エラーが起きた場合、カーソルはまったく動きません。

							*last-pattern*
最後に使われた検索パターン (最終検索パターン) とオフセットは記憶され、同じ検索
を繰り返すのに使うことができます。検索方向を変えたり、カウントを指定したりする
こともできます。Note: 記憶されるパターンは 2 つあります。1 つは「通常の」検索
コマンドのパターンです。もう 1 つは置換コマンド ":s" のパターンです。空のパ
ターンを指定すると直前に使用されたパターンが使われます。ただし、検索パターンが
まだ使用されてなかった場合は、可能であれば、直前の置換コマンドのパターンが使わ
れます。

'magic' オプションは最終検索パターンに影響しません。'magic' を変更しても、最終
検索パターンの解釈は変わりません。
'ignorecase' オプションは違います。'ignorecase' が変更された場合、最終検索パ
ターンは、違うテキストにマッチする可能性があります。

'hlsearch' オプションがオンの場合、最終検索パターンにマッチするテキストが強調
表示されます。

最終検索パターンを消去するには次のようにします: >
	:let @/ = ""
パターンに空文字列をセットしているのではありません。それだと全ての場所にマッチ
してしまいます。パターンは本当に消去され、Vim起動直後のように、何もない状態に
なります。

検索では通常、カーソル下のマッチはスキップされます。そのとき、すぐ隣の文字から
検索を開始するのか、スキップしたマッチの後ろから検索を開始するのかは、
'cpoptions' の 'c' フラグに依存します。|cpo-c|を参照。
	'c' フラグがある場合:   "/..." は 1 から 3 文字ずつ進みます。
	'c' フラグがない場合:   "/..." は 1 文字ずつ進みます。
検索は行頭から開始され、カーソル位置を過ぎたマッチを見付けるまでスキップされま
す。そのため、'c' フラグを含んでいる場合の動作は予想外かもしれません。
{訳注: aaaaaa
       カーソルが 2 桁目にある場合、/aaa は 4 桁目からの aaa にマッチする。
       これは、行頭から aaa aaa というマッチの区切りになり、
       カーソルを含んだ最初の aaa がスキップされるため。}

後方検索するときも、検索は行頭から始まり、上述のように 'cpoptions' の 'c' フラ
グが使われます。そして、カーソル位置より前でマッチする最後のマッチが使われます。

Vi では、":tag" コマンドでタグを検索すると、最終検索パターンは上書きされます。
Vim では、'cpoptions' に 't' フラグがある場合のみ、最終検索パターンが上書きさ
れます。どちらにしても、検索パターンは常に検索履歴に保存されます。

'wrapscan' オプションがオン (初期設定) の場合、検索がバッファの端に到達したと
きに、もう一方の端に移動して検索が継続されます。オフの場合は、後方検索ならバッ
ファの先頭、前方検索ならバッファの末尾でストップします。
パターンが見つからなかった場合、'wrapscan' がオンのときは、"pattern not found"
というメッセージが表示され、カーソルは動きません。オフのときは、後方検索なら
"search hit TOP without match"、前方検索なら "search hit BOTTOM without
match"、というメッセージが表示されます。
'wrapscan' がオンのときに検索がバッファの端から端へ継続した場合、後方検索なら
"search hit TOP, continuing at BOTTOM"、前方検索なら "search hit BOTTOM,
continuing at TOP" というメッセージが表示されます。このメッセージを表示しない
ようにするには、'shortmess' オプションに 's' フラグを設定します。メッセージは
'highlight' オプションの 'w' で強調表示されます (初期設定: standout)。

							*search-range*
"/" コマンドで検索するとき、\%>l を含めることで検索の範囲を指定できます。
例えば、199行目と300行目の間にある "limit" という単語を検索するには次のように
します: >
	/\%>199l\%<300llimit
|/\%>l|も参照。

他にも、":substitute" コマンドに 'c' フラグをつける方法で、擬似的な範囲内検索
ができます。例: >
   :.,300s/Pattern//gc
この例では、カーソル位置から 300 行目までの間で "Pattern" が検索されます。マッ
チした場所で、動作を指示するためのキーを入力必要があります。検索を停止するには
'q' を、次のマッチを検索するには 'n' を入力します。

"*", "#", "g*", "g#" コマンドはカーソルに近い単語を次の順番で検索します。最初
に見つかったものが使われます:
- カーソル位置のキーワード
- 同じ行の、カーソルの右側のキーワード
- カーソル位置の単語
- 同じ行の、カーソルの右側の単語
キーワードは、'iskeyword' で定義されている文字だけを含む文字列です。
単語 (|WORD|) は、空白文字 (<Tab> や <Space>) を含まない文字列です。
Note: 10本の指を使ってタイプしているなら、このコマンドを覚えるのは簡単です:
"#" は左手の中指で押します (左上に向かって検索します)。
"*" は右手の中指で押します (右下に向かって検索します)。
{訳注: これは英語キーボードでの話}

==============================================================================
2. パターンの定義			*search-pattern* *pattern* *[pattern]*
					*regular-expression* *regexp* *Pattern*
					*E76* *E383* *E476*

初心者の方はユーザーマニュアルの27章 |usr_27.txt| を読んでください。

						*/bar* */\bar* */pattern*
1. パターンは、"\|" で分けられた 1 つ以上のブランチからなります。ブランチがど
   れか 1 つでもマッチすればマッチします。例えば、"foo\|beep" は "foo" と
   "beep" にマッチします。複数のブランチがマッチした場合は、最初にマッチしたも
   のが使われます。

   pattern ::=	    branch
		or  branch \| branch
		or  branch \| branch \| branch
		etc.

						*/branch* */\&*
2. ブランチは、"\&" で分けられた1つ以上の連接からなります。全ての連接が同じ
   場所でマッチした場合に限り、最後の連接がマッチします。例:
	"foobeep\&..." は "foobeep" の "foo" にマッチします。
	".*Peter\&.*Bob" は "Peter" と "Bob" が両方ある行でマッチします。

   branch ::=	    concat
		or  concat \& concat
		or  concat \& concat \& concat
		etc.

						*/concat*
3. 連接は、連続した 1 つ以上のピースからなります。ピースがすべて、順番どおり
   マッチした場合にマッチします。たとえば、"f[0-9]b" は最初に "f" にマッチし、
   次に 1 桁の数字、そして "b" にマッチします。

   concat  ::=	    piece
		or  piece piece
		or  piece piece piece
		etc.

						*/piece*
4. ピースはアトムです。アトムが何回マッチするかを指示する、量指定子を後ろに置
   くことができます。たとえば "a*" はいくつの "a" でもマッチします。
   ""、"a"、"aa" など。|/multi|を参照。

   piece   ::=	    atom
		or  atom  multi

						*/atom*
5. アトムはパターンアイテムを構成する要素です。ほとんどのアトムは 1 文字にマッ
   チします。多くの場合、アトムは普通の文字か文字クラスです。カッコを使ってパ
   ターンからアトムを作れます。"\z(\)" は構文強調専用です。

   atom    ::=	    ordinary-atom		|/ordinary-atom|
		or  \( pattern \)		|/\(|
		or  \%( pattern \)		|/\%(|
		or  \z( pattern \)		|/\z(|


				*/\%#=* *two-engines* *NFA*
Vim は二つの正規表現エンジンを持っています:
1. 古い、バックトラッキングエンジン。すべての機能をサポート。
2. 新しい、NFA エンジン。いくつかのパターンで動作が速い。すべての機能はサポー
   トされない。

Vim は自動的に適切なエンジンを選択します。何か問題が発生したか、あるいは明示的
にエンジンを選択したいか、あるいはその他の理由で、エンジンを指定したい場合はパ
ターンの先頭で次のように指定します:

	\%#=0	強制的に自動選択にする。'regexpengine' が 0 以外のときだけ意味
	        がある。
	\%#=1	強制的に古いエンジンを使う。
	\%#=2	強制的に NFA エンジンを使う。

'regexpengine' オプションでもデフォルトのエンジンを選択できます。

			 *E864* *E868* *E874* *E875* *E876* *E877* *E878*
NFA エンジンが選択され、未実装の機能が使用され、パターンがマッチしなかった場合
に発生します。Vim のデバッグ用です。

==============================================================================
3. Magic							*/magic*

パターンの中でリテラルとして扱われる文字は、テキストの同じ文字とマッチします。
しかし、バックスラッシュが前置されると、特別な意味を持つようになります。

バックスラッシュを前置しなくても特別な意味を持つ文字があります。そのような文字
をリテラル文字としてマッチさせるには、バックスラッシュを前置する必要がありま
す。

ある文字がリテラルとして処理されるかどうかは、オプション 'magic' と、以下で説
明するアイテムに依存します。
							*/\m* */\M*
"\m" を使うと、それ以降のパターンは 'magic' がオンの状態で処理されます。
オプション 'magic' の設定よりも優先されます。
"\M" を使うと、それ以降のパターンは 'nomagic' の状態で処理されます。
							*/\v* */\V*
"\v" を使うと、それ以降の、'0'-'9'、'a'-'z'、'A'-'Z'、'_'、以外のすべての
ASCII 文字は特別な意味を持ちます。 "very magic"

"\V" を使うと、それ以降はバックスラッシュだけが特別な意味を持ちます。
"very nomagic"

例:
after:	  \v	   \m	    \M	     \V		マッチするもの ~
		'magic' 'nomagic'
	  $	   $	    $	     \$		行末
	  .	   .	    \.	     \.		何か 1 文字
	  *	   *	    \*	     \*		直前のアトムの繰り返し
	  ()	   \(\)     \(\)     \(\)	グループ化してアトムにする
	  |	   \|	    \|	     \|		選択の区切り
	  \a	   \a	    \a	     \a		英字
	  \\	   \\	    \\	     \\		リテラルのバックスラッシュ
	  \.	   \.	    .	     .		リテラルのドット
	  \{	   {	    {	     {		リテラルの '{'
	  a	   a	    a	     a		リテラルの 'a'

{\m、\M、\v、\V、はVimだけの機能です}

オプション 'magic' は初期設定のままにしておいてください。環境の違いによるトラ
ブルを回避できます。パターンが 'magic' の設定に影響されないようにするには、パ
ターンの先頭に "\m" か "\M" を置きます。


==============================================================================
4. パターンの概要					*pattern-overview*
						*E865* *E866* *E867* *E869*

量指定子の概要。					*/multi* *E61* *E62*
詳しい説明や使用例は、リンク先を参照してください。		*E64* *E871*

	  量指定子 ~
     'magic' 'nomagic'	アトムがいくつマッチするか ~
|/star|	*	\*	0 以上		最長一致
|/\+|	\+	\+	1 以上		最長一致 (*)
|/\=|	\=	\=	0 か 1		最長一致 (*)
|/\?|	\?	\?	0 か 1		最長一致 (*)

|/\{|	\{n,m}	\{n,m}	n 以上 m 以下	最長一致 (*)
	\{n}	\{n}	n		正確に指定した数だけ (*)
	\{n,}	\{n,}	n 以上		最長一致 (*)
	\{,m}	\{,m}	0 以上 m 以下	最長一致 (*)
	\{}	\{}	0 以上		最長一致 (*と同じ) (*)

|/\{-|	\{-n,m}	\{-n,m}	n 以上 m 以下	最短一致 (*)
	\{-n}	\{-n}	n		正確に指定した数だけ (*)
	\{-n,}	\{-n,}	n 以上		最短一致 (*)
	\{-,m}	\{-,m}	0 以上 m 以下	最短一致 (*)
	\{-}	\{-}	0 以上		最短一致 (*)

							*E59*
|/\@>|	\@>	\@>	1	強欲な量指定子 (*)
|/\@=|	\@=	\@=	なし	幅ゼロの肯定先読み |/zero-width| (*)
|/\@!|	\@!	\@!	なし	幅ゼロの否定先読み |/zero-width| (*)
|/\@<=|	\@<=	\@<=	なし	幅ゼロの肯定後読み |/zero-width| (*)
|/\@<!|	\@<!	\@<!	なし	幅ゼロの否定後読み |/zero-width| (*)

(*) {Vi にはありません}


普通のアトムの概要					*/ordinary-atom*
詳しい説明や使用例は、リンク先を参照してください。

      アトム ~
      magic   nomagic	マッチするもの ~
|/^|	^	^	行頭 (パターンの先頭にある場合だけ) |/zero-width|
|/\^|	\^	\^	リテラル文字 '^'
|/\_^|	\_^	\_^	行頭 (どこでも使える) |/zero-width|
|/$|	$	$	行末 (パターンの末尾にある場合だけ) |/zero-width|
|/\$|	\$	\$	リテラル文字 '$'
|/\_$|	\_$	\_$	行末 (どこでも使える) |/zero-width|
|/.|	.	\.	何か 1 文字 (改行以外)
|/\_.|	\_.	\_.	何か 1 文字 (改行含む)
|/\<|	\<	\<	単語の先頭 |/zero-width|
|/\>|	\>	\>	単語の末尾 |/zero-width|
|/\zs|	\zs	\zs	なし。マッチの開始地点を設定します
|/\ze|	\ze	\ze	なし。マッチの終了地点を設定します
|/\%^|	\%^	\%^	ファイルの先頭 |/zero-width|		*E71*
|/\%$|	\%$	\%$	ファイルの末尾 |/zero-width|
|/\%V|	\%V	\%V	選択範囲内 |/zero-width|
|/\%#|	\%#	\%#	カーソル位置 |/zero-width|
|/\%'m|	\%'m	\%'m	マーク m の位置 |/zero-width|
|/\%l|	\%23l	\%23l	23行目 |/zero-width|
|/\%c|	\%23c	\%23c	23列目 |/zero-width|
|/\%v|	\%23v	\%23v	23列目 (表示単位) |/zero-width|

文字クラス {Vi にはありません}:				*/character-classes*
|/\i|	\i	\i	識別子文字 (オプション 'isident' を参照)
|/\I|	\I	\I	"\i" と同じですが、数字は除外します
|/\k|	\k	\k	キーワード文字 (オプション 'iskeyword' を参照)
|/\K|	\K	\K	"\k" と同じですが、数字は除外します
|/\f|	\f	\f	ファイル名の文字 (オプション 'isfname' を参照)
|/\F|	\F	\F	"\f" と同じですが、数字は除外します
|/\p|	\p	\p	印字可能文字 (オプション 'isprint' を参照)
|/\P|	\P	\P	"\p" と同じですが、数字は除外します
|/\s|	\s	\s	空白文字: <Space> と <Tab>
|/\S|	\S	\S	空白文字以外。\s の反対です
|/\d|	\d	\d	数字				[0-9]
|/\D|	\D	\D	数字以外			[^0-9]
|/\x|	\x	\x	16 進数字			[0-9A-Fa-f]
|/\X|	\X	\X	16 進数字以外			[^0-9A-Fa-f]
|/\o|	\o	\o	8 進数字			[0-7]
|/\O|	\O	\O	8 進数字以外			[^0-7]
|/\w|	\w	\w	単語を構成する文字		[0-9A-Za-z_]
|/\W|	\W	\W	単語を構成する文字以外		[^0-9A-Za-z_]
|/\h|	\h	\h	単語の先頭の文字		[A-Za-z_]
|/\H|	\H	\H	単語の先頭の文字以外		[^A-Za-z_]
|/\a|	\a	\a	英字				[A-Za-z]
|/\A|	\A	\A	英字以外			[^A-Za-z]
|/\l|	\l	\l	小文字英字			[a-z]
|/\L|	\L	\L	小文字英字以外			[^a-z]
|/\u|	\u	\u	大文字英字			[A-Z]
|/\U|	\U	\U	大文字英字以外			[^A-Z]
|/\_|	\_x	\_x	x は上記の文字クラスのどれかです。文字クラスと改行が
			マッチします。
(文字クラスここまで)

|/\e|	\e	\e	<Esc>
|/\t|	\t	\t	<Tab>
|/\r|	\r	\r	<CR>
|/\b|	\b	\b	<BS>
|/\n|	\n	\n	改行
|/~|	~	\~	最後に置換された文字列
|/\1|	\1	\1	最初の \(\) と同じ文字列 {Vi にはありません}
|/\2|	\2	\2	"\1" と同じですが、2 番目の \(\) を使います
	   ...
|/\9|	\9	\9	"\1" と同じですが、9 番目の \(\) を使います
								*E68*
|/\z1|	\z1	\z1	構文強調専用。|:syn-ext-match|を参照
	   ...
|/\z1|	\z9	\z9	構文強調専用。|:syn-ext-match|を参照

	x	x	特別な意味のない文字は、その文字自身とマッチします

|/[]|	[]	\[]	[] で囲んだ文字のうちどれか
|/\%[]|	\%[]	\%[]	任意にマッチするアトム列

|/\c|	\c	\c	大文字小文字を無視します。'ignorecase' は使用されない
|/\C|	\C	\C	大文字小文字を区別します。'ignorecase' は使用されない
|/\Z|	\Z	\Z	Unicodeの合成文字かどうかを無視します。
			ヘブライ語やアラビア語で母音を検索するときに便利です。

|/\m|	\m	\m	以降のパターン文字を 'magic' がオンの状態で処理します
|/\M|	\M	\M	以降のパターン文字を 'magic' がオフの状態で処理します
|/\v|	\v	\v	以降のパターン文字を "very magic" で処理します
|/\V|	\V	\V	以降のパターン文字を "very nomagic" で処理します
|/\%#=|   \%#=1   \%#=1   正規表現エンジンを選択する |/zero-width|

|/\%d|	\%d	\%d	10進数指定の特定の文字 (例 \%d123)
|/\%x|	\%x	\%x	16進数指定の特定の文字 (例 \%x2a)
|/\%o|	\%o	\%o	8進数指定の特定の文字  (例 \%o040)
|/\%u|	\%u	\%u	特定のマルチバイト文字 (例 \%u20ac)
|/\%U|	\%U	\%U	特定の広範囲のマルチバイト文字 (例 \%U12345678)

例			マッチするもの ~
\<\I\i*		or
\<\h\w*
\<[a-zA-Z_][a-zA-Z0-9_]*
			識別子 (例えば C 言語の識別子)

\(\.$\|\. \)		<EOL> かスペースの直前のピリオド

[.!?][])"']*\($\|[ ]\)	文末。")" コマンドが認識する文末と同じ定義です。

cat\Z			"cat" と "càt" ("a" + 0x0300) にマッチする。
			見た目は似ていますが、"càt" (0x00e0)にはマッチしませ
			ん。


==============================================================================
5. 量指定子 (Multi items)				*pattern-multi-items*

アトムがどのように、何回マッチするかを指示するものを、量指定子 (multi) と呼び
ます。概要は |/multi| を参照してください。

						*/star* */\star* *E56*
*	('magic' がオフのときは \* )
	アトムの 0 回以上の繰り返し。最長一致。
	Example  'nomagic'	マッチするもの ~
	a*	   a\*		""、"a"、"aa"、"aaa"、など。
	.*	   \.\*		改行以外の全て (空文字列も)
	\_.*	   \_.\*	バッファの末尾までの全て
	\_.*END	   \_.\*END	一番最後の "END" までの全て

	例外: パターンの最初と "^" の直後の "*" は、リテラルの "*" にマッチし
	ます。

	"\_." の繰り返しには注意してください。たくさんのテキストがマッチして、
	そして、時間が掛かります。たとえば、"\_.*END" は、カーソルの位置から 1
	番最後の "END" までのすべてのテキストがマッチします。"*" は最長一致な
	ので、まずファイルの末尾までスキップして、それから 1 文字ずつ後退しな
	がら "END" を探します。

							*/\+* *E57*
\+	アトムの 1 回以上の繰り返し。最長一致。 {Vi にはありません}
	Example		マッチするもの ~
	^.\+$		空行以外の行
	\s\+		1 文字以上の空白

							*/\=*
\=	0 回または 1 回のアトム。最長一致。 {Vi にはありません}
	Example		マッチするもの ~
	foo\=		"fo" と "foo"

							*/\?*
\?	\= と同じ。"?" コマンドによる後方検索では使えません。
	{Vi にはありません}

					*/\{* *E58* *E60* *E554* *E870*
\{n,m}	アトムの n 以上 m 以下の繰り返し。最長一致
\{n}	アトムの n 回         の繰り返し
\{n,}	アトムの n 回以上     の繰り返し。最長一致
\{,m}	アトムの 0 以上 m 以下の繰り返し。最長一致
\{}	アトムの 0 回以上     の繰り返し。最長一致 (*と同じ)
							*/\{-*
\{-n,m}	アトムの n 以上 m 以下の繰り返し。最短一致
\{-n}	アトムの n 回         の繰り返し
\{-n,}	アトムの n 回以上     の繰り返し。最短一致
\{-,m}	アトムの 0 以上 m 以下の繰り返し。最短一致
\{-}	アトムの 0 回以上     の繰り返し。最短一致
	{すべてViにはない機能です}

	n と m には 10 進数正数、またはゼロを指定できます。

								*non-greedy*
	"{" の直後に "-" がある場合は、最短一致のアルゴリズムが使われます (下
	記の例を参照)。特に、"\{-}" は "*" と同じですが、最短一致のアルゴリズ
	ムが使われます。しかし、早い位置でマッチするものが、短いマッチよりも優
	先されます。たとえば、"a\{-}b" は "xaaab" の "aaab" にマッチします。

	Example			マッチするもの ~
	ab\{2,3}c		"abbc" または "abbbc"
	a\{5}			"aaaaa"
	ab\{2,}c		"abbc", "abbbc", "abbbbc", etc.
	ab\{,3}c		"ac", "abc", "abbc" or "abbbc"
	a[bc]\{3}d		"abbbd"、"abbcd"、"acbcd"、"acccd"、など
	a\(bc\)\{1,2}d		"abcd" または "abcbcd"
	a[bc]\{-}[cd]		"abcd" の "abc"
	a[bc]*[cd]		"abcd" の "abcd"

	} にバックスラッシュを前置するかどうかは任意です: \{n,m\}

							*/\@=*
\@=	幅ゼロの肯定先読み。先行するアトムに幅ゼロでマッチします。
	{Vi にはありません}
	Perl の "(?=pattern)" と似ています。
	Example			マッチするもの ~
	foo\(bar\)\@=		"foobar" の "foo"
	foo\(bar\)\@=foo	何もマッチしない
							*/zero-width*
	"\@=" (や、"^"、"$"、"\<"、"\>"、など) を使った場合、その文字はマッチ
	に含まれません。これらのアイテムは、マッチすることができるかどうかの
	チェックだけに使われます。続くアイテムが同じ場所でマッチすることに注意
	してください。上記の最後の例は "foobarfoo" にはマッチしません。"bar"
	がマッチしたのと同じ場所で "foo" とマッチしようとするからです。

	Note: "\&" は "\@=" と同じような働きをします。"foo\&.." と
	"\(foo\)\@=.." は同じです。カッコを書かなくていいので "\&" の方が簡単
	です。


							*/\@!*
\@!	幅ゼロの否定先読み。 先行するアトムが現在の位置でマッチしない場合に、
	幅ゼロでマッチします。|/zero-width| {Vi にはありません}
	Perl の "(?!pattern)" と似ています。
	Example			マッチするもの ~
	foo\(bar\)\@!		後ろに "bar" のない "foo"
	a.\{-}p\@!		後ろに "p" のない "a"、"ap"、"app"、"appp" など
	if \(\(then\)\@!.\)*$	後ろに "then" のない "if "

	"\@!" を使うには注意が必要です。パターンにマッチしない場所、というのは
	そこらじゅうにあるからです。"a.*p\@!" は "a" から行末までマッチしま
	す。なぜなら、".*" が全ての文字にマッチし、"p" は行末にマッチしないか
	らです。"a.\{-}p\@!" は後ろに "p" のない文字列、"a"、"ap"、"app"、など
	にマッチします。なぜなら、"." が "p" にもマッチし、"p\@!" がその後ろに
	マッチする(つまり "p" がマッチしない) からです。

	直前がマッチしないことを調べるために "\@!" を使うことはできません。
	"\(foo\)\@!bar" は "foobar" の "bar" にマッチします。なぜなら、"foo"
	がマッチしなかった場所で、"bar" がマッチするからです。"foobar" がマッ
	チしないように、"\(foo\)\@!...bar" とすることもできますが、これは行頭
	の "bar" にはマッチしません。"\(foo\)\@<!bar" を使ってください。

	実用的な例: "bar" を含んでいない行から "foo" を探す: >
		/^\%(.*bar\)\@!.*\zsfoo
<	このパターンはまず、行の中で "bar" がマッチしないことを確認します。も
	しどこかで ".*bar" がマッチすると \@! によってこのパターンは否決されま
	す。それがマッチせず、そしてどこかで "foo" が見つかると、"\zs" によっ
	て "foo" の直前でマッチが開始したことにされます。

							*/\@<=*
\@<=	幅ゼロの肯定後読み。先行するアトムが、この後に続くパターンの直前にマッ
	チする場合に、幅ゼロでマッチします。|/zero-width|
	{Vi にはありません}
	Perl の "(?<=pattern)" と似ていますが、Vimでは可変長パターンも使えます。
	Example			マッチするもの ~
	\(an\_s\+\)\@<=file	"an" と空白文字 (改行含む) の後の "file"

	処理速度を気にするなら、この量指定子は避けたほうが無難です。代わりに
	"\zs" を使ってください |/\zs|。次のものは上記の例と同じものにマッチし
	ます:
		an\_s\+\zsfile
	あるいは少なくとも探索範囲を制限した方がいいでしょう。下記参照。

	"\@<=" と "\@<!" は直前の文字がマッチしているかどうかをチェックしま
	す。理論上は、マッチの現在位置よりも前ならどこでもマッチできます。しか
	し、処理時間を制限するために、マッチの現在行と、(もしあれば) 1 つ前の
	行だけが検索されます。ほとんどの場合はこれで十分ですし、遅くなり過ぎる
	こともありません。
	"\@<=" や "\@<!" の後にくるパターンは最初にチェックされます。そのため、
	先行するアトムの内側にある \(\) に対する "\1" のような参照は機能しませ
	ん。順番を逆にした場合は機能します:
	Example			マッチするもの ~
	\1\@<=,\([a-z]\+\)	"abc,abc" の ",abc"

\@123<=
	"\@<=" と同じですが 123 バイトまでしか探索しません。失敗すると分かって
	いて、その探索のせいで遅くなる状況を回避できます。例えば、"span" の前
	に "<" があるかどうかをチェックする場合:
		/<\@1<=span
	このパターンは "span" の前の 1 バイトだけを見て "<" を探します。この例
	ではなんにしても 1 バイト前だけが唯一マッチする場所です。
	行をまたいだ場合、探索範囲はその行末からの相対位置になります。つまり、
	探索開始位置の行の文字はカウントされません (ものごとをシンプルに保つた
	め)。
	数値のゼロは制限なしと同じです。

							*/\@<!*
\@<!	幅ゼロの否定後読み。先行するアトムが、この後に続くパターンの直前にマッ
	チしない場合に、幅ゼロでマッチします。現在行と 1 つ前の行だけがチェッ
	クされます。|/zero-width| {Vi にはありません}
	Perl の "(?<!pattern)" と似ていますが、Vimでは可変長パターンも使えます。
	対象のアトムは、続くアトムの直前までがマッチの範囲になるため、最後が
	".*" で終わっているアトムも機能します。
	警告: これは遅くなることがあります (マッチするかどうかを多くの場所で
	チェックする必要があるため)。可能であれば探索範囲に制限をかけてくださ
	い。下記参照。
	Example			マッチするもの ~
	\(foo\)\@<!bar		"foobar" 以外の "bar"
	\(\/\/.*\)\@<!in	"//" の後ろ以外の "in"

\@123<!
	"\@<!" と同じですが 123 バイトまでしか探索しません。失敗すると分かって
	いて、その探索のせいで遅くなる状況を回避できます。

							*/\@>*
\@>	強欲な量指定子。 {Vi にはありません}
	Perlの "(?>pattern)" と似ています。
	Example		マッチするもの ~
	\(a*\)\@>a	何もマッチしない ("a*" が全ての "a" を取るので、その後
			に "a" があることはありません)

	パターンがそのアトムだけであるかのようにマッチします。そして、パターン
	全体がマッチしなくても、そのアトムのマッチを短くして再トライしたりはし
	ません (バックトラックしません)。次の違いに注意してください。"a*b" と
	"a*ab" は両方とも "aaab" にマッチします。このとき、後者の "a*" は先頭
	の "aa" にマッチしています。"\(a*\)\@>ab" は "aaab" にマッチしません。
	なぜなら、"a*" が "aaa" にマッチする (最長一致する) ため、"ab" がマッ
	チできないからです。


==============================================================================
6.  普通のアトム					*pattern-atoms*

普通のアトムは次のものです:

							*/^*
^	パターンの先頭にある場合、行頭にマッチします。"\|"、"\("、"\%(" の直後
	でも構いません。他の場所にある場合は、リテラル文字の '^' にマッチしま
	す。|/zero-width|
	Example		マッチするもの ~
	^beep(		(おそらく) C 言語の関数 "beep" の開始。

							*/\^*
\^	リテラル文字の '^' にマッチします。パターンのどの場所でも使えます。

							*/\_^*
\_^	行頭にマッチします。|/zero-width|  パターンのどの場所でも使えます。
	Example		マッチするもの ~
	\_s*\_^foo	空白文字や空行の直後の、行頭の "foo"

							*/$*
$	パターンの末尾、または "\|"、"\)"、"\n" ('magic' on時) の前にある場
	合、行末 (<EOL>) にマッチします。他の場所にある場合は、リテラル文字の
	'$' にマッチします。|/zero-width|

							*/\$*
\$	リテラル文字の '$' にマッチします。パターンのどの場所でも使えます。

							*/\_$*
\_$	行末にマッチします。|/zero-width|  パターンのどの場所でも使えます。
	Note: "a\_$b" はどこにもマッチしません。"b" は行末とはマッチしないから
	です。代わりに、"a\nb" を使ってください |/\n|。
	Example		マッチするもの ~
	foo\_$\_s*	行末の "foo" と、それに続く空白や空行

.	('nomagic' なら \.)				*/.* */\.*
	改行以外のすべての文字がマッチします。

							*/\_.*
\_.	改行も含め、すべての文字がマッチします。
	注意: "\_.*" はバッファの末尾までのすべてのテキストがマッチします。

							*/\<*
\<	単語の先頭にマッチします。このアトムの次の文字は単語の 1 文字目です。
	どの文字が単語を構成するかは、オプション 'iskeyword' で設定します。
	|/zero-width|

							*/\>*
\>	単語の末尾にマッチします。このアトムの前の文字は単語の最後の文字です。
	どの文字が単語を構成するかは、オプション 'iskeyword' で設定します。
	|/zero-width|

							*/\zs*
\zs	どこにでもマッチして、マッチの開始地点を設定します。このアトムの次の文
	字は、マッチした文字列の 1 文字目です。|/zero-width|
	例: >
		/^\s*\zsif
<	これは、行頭からスペースを無視して、"if" にマッチします。
	複数回の繰り返しで使った場合は、最後にマッチしたものが使われます。
	例: >
		/\(.\{-}\zsFab\)\{3}
<	これは、3 番目に現れた "Fab" にマッチします。
	{Vi にはありません} {|+syntax|が有効な場合のみ利用できます}
							*/\ze*
\ze	どこにでもマッチして、マッチの末尾を設定します。このアトムの前の文字
	は、マッチした文字列の最後の文字です。|/zero-width|
	複数回の繰り返しで使った場合は、最後にマッチしたものが使われます。
	例: >
		/end\ze\(if\|for\)
<	これは、"endif" または "endfor" の "end" にマッチします。
	{Vi にはありません} {|+syntax|が有効な場合のみ利用できます}

						*/\%^* *start-of-file*
\%^	ファイルの先頭にマッチします。文字列 (|expr-string|) とマッチングする
	場合は、文字列の先頭にマッチします。{Vi にはありません}
	例: >
		/\%^\_.\{-}\zsVIM
<	これは、ファイルの最初にある "VIM" にマッチします。

						*/\%$* *end-of-file*
\%$	ファイルの末尾にマッチします。文字列 (|expr-string|) とマッチングする
	場合は、文字列の末尾にマッチします。{Vi にはありません}
	Note: 次のパターンでは、ファイルの最後の "VIM" を検索できません: >
		/VIM\_.\{-}\%$
<	これは、カーソル位置から次の "VIM" を検索します。"VIM" の後の
	"\_.\{-}\%$" が常にマッチするからです。ファイルの最後の "VIM" を検索す
	るには、次のようにします: >
		/VIM\ze\(\(VIM\)\@!\_.\)*\%$
<	"VIM" の後に "VIM" がないことを確実にするために|/\@!|を使っています。
	ファイルの末尾から後方検索する方が簡単です。

						*/\%V*
\%V	選択範囲内にマッチします。ビジュアルモードでないときは、|gv| で再選択
	できる範囲にマッチします。
	これはゼロ幅マッチ |/zero-width| です。パターンを選択範囲内でマッチさ
	せたい場合は、パターンの最初と最後にこれを指定してください。例: >
		/\%Vfoo.*bar\%V
<	カレントバッファでのみ機能します。

						*/\%#* *cursor-position*
\%#	カーソルの位置にマッチします。ウィンドウに表示されているバッファ内で
	マッチングする場合のみ機能します。{Vi にはありません}
	警告: パターンが使われた後で、カーソルを移動した場合、マッチの結果は正
	確ではなくなってしまいます。マッチの結果は自動的に更新されません。これ
	は特に、構文強調と 'hlsearch' に関係します。
	カーソルが移動しても、表示は自動的に更新されません。表示が更新されるの
	は、行を変更したため行全体が更新されたときや、|CTRL-L| コマンドを使っ
	てスクリーン全体を更新したときです。カーソル位置の単語を強調表示するに
	は次のようにします: >
		/\k*\%#\k*
<	'hlsearch' をオンにして、カーソルを移動し、テキストを変更してみて、表
	示が更新されるかどうか確認してください。

						*/\%'m* */\%<'m* */\%>'m*
\%'m	マーク m の位置にマッチします。
\%<'m	マーク m より前の位置にマッチします。
\%>'m	マーク m より後の位置にマッチします。
	例えば、マーク 's から 'e までを強調するには次のようにします: >
		/.\%>'s.*\%<'e..
<	Note: マーク 'e の位置をマッチに含めるには 'e の後に二つのドットが必要
	です。なぜなら、"\%<'e" はマーク 'e の前の文字にマッチし、そしてそれは
	ゼロ幅マッチ|/zero-width| なので、その文字は結果に含まれないからです。
	{Vi にはありません}
	警告: マークを検索した後にマークを移動した場合、その結果は正しくなくな
	ります。Vim は自動的にマッチの強調表示を更新したりしません。
	|/\%#| で検索した後にカーソルを動かした場合と似ています。

						*/\%l* */\%>l* */\%<l*
\%23l	指定した行にマッチします。
\%<23l	指定した行より上にマッチします。
\%>23l	指定した行より下にマッチします。
	この 3 つを使って、バッファの特定の行にマッチできます。"23" の所に行番
	号を指定してください。先頭の番号は 1 です。{Vi にはありません}
	警告: 行を挿入したり削除したりしても、マッチの結果は自動的に更新されま
	せん。そのため、このアトムを使った構文強調は、すぐに誤った表示になって
	しまいます。
	現在行を強調表示するには次のようにします: >
		:exe '/\%' . line(".") . 'l.*'
<	'hlsearch' をオンにして、カーソルを移動し、テキストを変更してみて、表
	示が更新されるかどうか確認してください。

						*/\%c* */\%>c* */\%<c*
\%23c	指定した列にマッチします。
\%<23c	指定した列より前にマッチします。
\%>23c	指定した列より後にマッチします。
	この 3 つを使って、バッファの特定の列にマッチできます。"23" の所に列番
	号を指定してください。先頭の番号は 1 です。実際には、何バイト目かを指
	定するので、マルチバイト文字を扱うときには、"列番号" という表現は正確
	ではありません。{Vi にはありません}
	警告: 行を挿入したり削除したりしても、マッチの結果は自動的に更新されま
	せん。そのため、このアトムを使った構文強調は、すぐに誤った表示になって
	しまいます。
	カーソル位置の列を強調表示するには次のようにします: >
		:exe '/\%' . col(".") . 'c'
<	'hlsearch' をオンにして、カーソルを移動し、テキストを変更してみて、表
	示が更新されるかどうか確認してください。
	44 バイト目を強調表示するには次のようにします: >
		/\%>43c.\%<46c
<	Note: "." が 44 バイト目にマッチした場合、"%<46c" は 45 列目にマッチし
	ます。
						*/\%v* */\%>v* */\%<v*
\%23v	指定した表示列にマッチします。
\%<23v	指定した表示列より前にマッチします。
\%>23v	指定した表示列より後にマッチします。
	この 3 つを使って、バッファの特定の表示列にマッチできます。文字列
	(|expr-string|) とマッチングするときは、カレントウィンドウの、
	'tabstop' などの設定が使われます。
	"23" の所に表示列番号を指定してください。先頭の番号は 1 です。
	Note: Tab 文字や全角文字などの、複数列で表示される文字の途中の列を指定
	した場合は、マッチしません {Vi にはありません}
	警告: 行を挿入したり削除したりしても、マッチの強調表示は自動的に更新さ
	れません。そのため、このアトムを使った構文強調は、すぐに誤った表示に
	なってしまいます。
	表示列の72桁目以降のすべての文字を強調表示するには次のようにします: >
		/\%>72v.*
<	'hlsearch' をオンにして、カーソルを移動し、テキストを変更してみて、表
	示が更新されるかどうか確認してください。
	17 列までのテキストにマッチさせるには次のようにします: >
		/.*\%17v
<	17 列目も含まれます。なぜならそこに "\%17v" がマッチするからです (たと
	えそれがゼロ幅マッチ (|/zero-width|) だとしても)。ドットを追加してその
	次の文字にマッチさせても結果は同じになります: >
		/.*\%17v.
<	次のコマンドも同様の動作ですが、17 列目に文字が存在しなくてもマッチし
	ます: >
		/.*\%<18v

文字クラス: {Vi にはありません}
\i	識別子文字 ('isident' 参照)			*/\i*
\I	"\i" と同じですが、数字は除外します		*/\I*
\k	キーワード文字 ('iskeyword' 参照)		*/\k*
\K	"\k" と同じですが、数字は除外します		*/\K*
\f	ファイル名の文字 ('isfname' 参照)		*/\f*
\F	"\f" と同じですが、数字は除外します		*/\F*
\p	印字可能文字 ('isprint' 参照)			*/\p*
\P	"\p" と同じですが、数字は除外します		*/\P*

NOTE: 上記のものはマルチバイト文字に対しても機能します。次のものは、示された範
囲の ASCII 文字だけがマッチします。

						*whitespace* *white-space*
\s	空白文字: <Space> と <Tab>			*/\s*
\S	空白文字以外。\s の反対です			*/\S*
\d	数字:				[0-9]		*/\d*
\D	数字以外:			[^0-9]		*/\D*
\x	16 進数字:			[0-9A-Fa-f]	*/\x*
\X	16 進数字以外:			[^0-9A-Fa-f]	*/\X*
\o	8 進数字:			[0-7]		*/\o*
\O	8 進数字以外:			[^0-7]		*/\O*
\w	単語を構成する文字:		[0-9A-Za-z_]	*/\w*
\W	単語を構成する文字以外:		[^0-9A-Za-z_]	*/\W*
\h	単語の先頭の文字:		[A-Za-z_]	*/\h*
\H	単語の先頭の文字以外:		[^A-Za-z_]	*/\H*
\a	英字:				[A-Za-z]	*/\a*
\A	英字以外:			[^A-Za-z]	*/\A*
\l	小文字英字:			[a-z]		*/\l*
\L	小文字英字以外:			[^a-z]		*/\L*
\u	大文字英字:			[A-Z]		*/\u*
\U	大文字英字以外:			[^A-Z]		*/\U*

	NOTE: これらのアトムは |/[]| を使うよりも高速です。

	NOTE: 'ignorecase'、"\c"、"\C" は、文字クラスには影響しません。

			*/\_* *E63* */\_i* */\_I* */\_k* */\_K* */\_f* */\_F*
			*/\_p* */\_P* */\_s* */\_S* */\_d* */\_D* */\_x* */\_X*
			*/\_o* */\_O* */\_w* */\_W* */\_h* */\_H* */\_a* */\_A*
			*/\_l* */\_L* */\_u* */\_U*
\_x	x は上記の文字クラスのどれかです。文字クラスと改行がマッチします。
(文字クラスここまで)

\e	<Esc> にマッチします				*/\e*
\t	<Tab> にマッチします				*/\t*
\r	<CR> にマッチします				*/\r*
\b	<BS> にマッチします				*/\b*
\n	改行にマッチします				*/\n*
	バッファのテキストではなく、文字列 (|expr-string|) とマッチングすると
	きは、リテラルの改行文字がマッチします。

~	最後に置換された文字列とマッチします		*/~* */\~*

\(\)	パターンをカッコでまとめます			*/\(* */\(\)* */\)*
	たとえば、"\(^a\)" は行頭の 'a' にマッチします。
	*E51* *E54* *E55* *E872* *E873*

\1      \( と \) に囲まれた最初の部分正規表現が		*/\1* *E65*
	マッチした文字列と同じ文字列にマッチします。{Vi にない機能です}
	たとえば、"\([a-z]\).\1" は "ata"、"ehe"、"tot"、などにマッチします。
\2      "\1" と同じですが、2 番目の部分正規表現を使います	*/\2*
   ...								*/\3*
\9      "\1" と同じですが、9 番目の部分正規表現を使います	*/\9*
	Note: 部分正規表現の番号は、最初の "\(" から数えて、左から右へ、順番に
	番号が付けられます。マッチする順番ではありません。

\%(\)	パターンをカッコでまとめます			*/\%(\)* */\%(* *E53*
	\(\) と同じですが、部分正規表現としてカウントされません。たくさんのグ
	ループを作ることができますし、処理が少し高速です。
	{Vi にはありません}

x	特別な意味のない文字は、その文字自身とマッチします

							*/\* */\\*
\x	バックスラッシュと文字の組合せで、現在、特別な意味を持っていない文字
	は、将来の拡張のために予約されています。

[]	('nomagic' のときは \[])	*/[]* */\[]* */\_[]* */collection*
\_[]
	コレクションです。複数の文字を角カッコで囲みます。コレクションに含まれ
	る任意の 1 文字とマッチします。
	Example		マッチするもの ~
	[xyz]		'x'、'y'、'z' のどれか
	[a-zA-Z]$	行末の英字
	\c[a-z]$	同上
	[А-яЁё]		ロシア語アルファベット (utf-8 と cp1251)

								*/[\n]*
	"\_" を付けた場合、コレクションは改行も含みます。コレクションに "\n"
	を含めた場合と同じですが、"\_" を付けた場合は、コレクションの先頭が
	"^" の場合でも改行にマッチします。つまり、"\_[^ab]" は "a" や "b" 以外
	の文字と改行にマッチします。
	これは Vi 互換です。"\_" や "\n" を使わなければ、改行にはマッチしませ
	ん。

								*E769*
	']' がない場合、Vim はエラーを表示せず、コレクションが使われているので
	はないと判断します。'[' を検索するときに便利です。しかし、Vim 内部での
	検索では E769 のエラーがでます。

	コレクション文字列の先頭が "^" の場合、 コレクションに含まれている文字
	以外の文字がマッチします。"[^xyz]" は 'x'、'y'、'z' 以外の文字にマッチ
	します。
	- 2 つの文字で '-' を挟んで、ASCII 文字の範囲を指定できます。たとえ
	  ば、"[0-9]" はすべての数字にマッチします。非ASCII 文字も指定できます
	  が 2 つの文字の値の差が 256 を超えてはなりません。
	- 文字クラス表現を使って、その文字クラスが含んでいる文字を取り込むこと
	  ができます。次の文字クラスがサポートされています。
			  名前		含んでいるもの ~
*[:alnum:]*		  [:alnum:]     英数字
*[:alpha:]*		  [:alpha:]     英字
*[:blank:]*		  [:blank:]     スペースと Tab 文字
*[:cntrl:]*		  [:cntrl:]     コントロール文字
*[:digit:]*		  [:digit:]     10 進数字
*[:graph:]*		  [:graph:]     スペース以外の印字可能文字
*[:lower:]*		  [:lower:]     小文字英字 ('ignorecase' がオンのとき
					はすべての英字)
*[:print:]*		  [:print:]     スペースを含む印字可能文字
*[:punct:]*		  [:punct:]     句読点
*[:space:]*		  [:space:]     空白文字 (スペース、Tab、改ページ文字)
*[:upper:]*		  [:upper:]     大文字英字 ('ignorecase' がオンのとき
					はすべての英字)
*[:xdigit:]*		  [:xdigit:]    16 進数字
*[:return:]*		  [:return:]	<CR> 文字
*[:tab:]*		  [:tab:]	<Tab> 文字
*[:escape:]*		  [:escape:]	<Esc> 文字
*[:backspace:]*		  [:backspace:]	<BS> 文字
	  角カッコで囲んだ文字クラス表現を、コレクションの角カッコ内に書きま
	  す。たとえば、"[-./[:alnum:]_~]\+" は、UNIX のファイル名として妥当な
	  パターンです。このパターンは、'-'、'.'、'/'、英数字、'_'、'~'、のど
	  の文字の組合せでも、1 文字以上の文字列にマッチします。
	  これらのものは、8 ビット文字のみマッチします。
							*/[[=* *[==]*
	- 等価クラス。これはその文字とほぼ同じ文字にマッチします。例えば、アク
	  セントを無視するなど。これは Unicode、latin1、latin9 でのみ機能しま
	  す。次のように書きます:
		[=a=]
							*/[[.* *[..]*
	- 照合要素。現在は中に一文字だけ指定できます:
		[.a.]
							  */\]*
	- リテラル文字の ']'、'^'、'-'、'\' をコレクションに含めるには、バック
	  スラッシュを前置して、"[xyz\]]"、"[\^xyz]"、"[xy\-z]"、"[xyz\\]" と
	  書きます。
	  (Note: POSIX ではこのようなバックスラッシュの使い方はサポートされて
	  いません。)
	  ']' は、コレクションの先頭、または '^' の直後にそのまま書いて、
	  "[]xyz]" や "[^]xyz]" とすることができます。
	  {Vi にはありません}
	  '-' も、先頭や末尾にそのまま書いて、"[-xyz]"、"[^-xyz]"、"[xyz-]"、
	  とすることができます。'\' も指定文字 "^]-\bdertnoUux" 以外の文字の前
	  ならそのまま書けます。"[\xyz]" は、'\'、'x'、'y'、'z'、の文字にマッ
	  チします。しかし、常に "\\" と書くようにした方がいいでしょう。'\' と
	  何かの文字の組合せは将来的に拡張に使われる可能性があります。
	  末尾の ] を省略してもエラーにはなりません。"[]" は "[]]" と同じ意味
	  になり ']' 文字にマッチします。
	- 'cpoptions' が 'l' フラグを含んでいない場合、次のものが特別に解釈さ
	  れます。{Vi にはありません}:
		\e	<Esc>
		\t	<Tab>
		\r	<CR>	(改行文字ではありません)
		\b	<BS>
		\n	改行。|/[\n]| 参照。
		\d123	10進数の文字番号
		\o40	8 進数の文字番号 (最大値 0377)
		\x20	16進数の文字番号 (最大値 0xff)
		\u20AC	16進数のマルチバイト文字番号 (最大値 0xffff)
		\U1234	16進数のマルチバイト文字番号 (最大値 0xffffffff)
	  NOTE: 他のバックスラッシュによる特殊文字の表記は、[] の中では機能し
	  ません。
	- コレクションを使ったマッチングは遅くなることがあります。 コレクショ
	  ンの文字と、テキストの文字を、それぞれ 1 文字ずつ比較する必要がある
	  からです。同じ意味のアトムが他にある場合は、それを使ってください。た
	  とえば、"\d" は "[0-9]" よりも速く、同じ文字にマッチします。

						*/\%[]* *E69* *E70* *E369*
\%[]	任意にマッチするアトム列です。これは常にマッチします。アトム単位で最長
	一致し、最初にアトムがマッチしなかったところでストップします。例: >
		/r\%[ead]
<	これは、"r"、"re"、"rea"、"read" にマッチします。1 番長いマッチが使わ
	れます。Ex コマンドの "function" は、"fu" が必須で、"nction" は省略可
	能ですが、次の例は、そのようなものにマッチします: >
		/\<fu\%[nction]\>
<	"full" の "fu" にマッチするようなことがないように、単語末尾のアトム
	"\>" が使われています。使う機会はあまりないかもしれませんが、普通の文
	字以外のアトムを使って、さらに複雑なものも表現できます。例: >
		/\<r\%[[eo]ad]\>
<	これは、"r"、"re"、"ro"、"rea"、"roa"、"read"、"road" にマッチします。
	[] の中では \(\)、\%(\)、\z(\) は使えません。\%[] はネストできません。
	"[" を含めるには "[[]" を、"]" を含めるには "[]]" を使ってください。
	例: >
		/index\%[[[]0[]]]
<	これは "index"、"index["、"index[0"、"index[0]" にマッチします。
	{|+syntax| が有効な場合のみ利用可能}

				*/\%d* */\%x* */\%o* */\%u* */\%U* *E678*

\%d123	10進数で指定した文字にマッチします。このアトムの後ろには数字以外の文字
	を置いてください。
\%o40	8 進数で指定した文字にマッチします (最大値 0377)。040 より小さい値を指
	定するとき、このアトムの後ろには8進数字以外の文字か、数字以外の文字を
	置いてください。
\%x2a	16進数で指定した文字にマッチします。2桁まで。
\%u20AC	16進数で指定した文字にマッチします。4桁まで。
\%U1234abcd	16進数で指定した文字にマッチします。8桁まで。

==============================================================================
7. 大文字と小文字を無視する					*/ignorecase*

オプション 'ignorecase' がオンの場合、普通の英字の大文字と小文字の違いは無視さ
れます。'smartcase' がオンの場合、パターンが大文字を含んでいないときだけ、大文
字と小文字が無視されます。
							*/\c* */\C*
"\c" はパターン中のどこにでも置くことができ、パターン全体が、'ignorecase' をオ
ンにした状態で処理されます。実際の 'ignorecase' と 'smartcase' の設定は無視さ
れます。"\C" は "\c" の反対の意味で、大文字と小文字は必ず区別されます。
{Vim だけが \c と \C をサポートしています}
Note: 'ignorecase'、"\c"、"\C" は、文字クラスには作用しません。

例:
      パターン	'ignorecase'  'smartcase'	マッチするもの ~
	foo	  off		-		foo
	foo	  on		-		foo Foo FOO
	Foo	  on		off		foo Foo FOO
	Foo	  on		on		    Foo
	\cfoo	  -		-		foo Foo FOO
	foo\C	  -		-		foo

技術的な説明:					*NL-used-for-Nul*
ファイル中の <Nul> 文字は、<NL> 文字としてメモリに保存され、ディスプレイには
"^@" と表示されます。これは、ファイルを読み書きする時に変換されます。検索パ
ターンに <Nul> をマッチさせるには、CTRL-@ か "CTRL-V 000" を入力します。この動
作はそれほど違和感がないはずです。検索パターンの <Nul> 文字は内部で <NL> に変
換されています。CTRL-V CTRL-J をタイプした場合も <NL> が入力されるので、ファイ
ル中の <Nul> を検索するのに使えますが、この動作は不自然に感じるかもしれませ
ん。{Vi はファイル中の <Nul> 文字を扱えません}

						*CR-used-for-NL*
'fileformat' が "mac" の場合、ファイル中の <NL> は内部では <CR> で保存され、テ
キストの中では "^J" として表示されます。他では、<NL> と <Nul> の場合と同じよう
に扱われます。

スクリプトでは、パターン中の <NL> は、文字列中の <NL> とマッチします。"\n"
(バックスラッシュと n) は <NL> とはマッチしません。バッファ中のテキストとの
マッチの場合のみ、"\n" は改行とマッチします。

						*pattern-multi-byte*
マルチバイト文字を使ったパターンは、たいていは、ユーザーが期待したとおりに機能
します。しかし、不正なバイトでトラブルが起こることもあります。不正なバイトを含
むパターンはおそらく、決してマッチしません。

==============================================================================
8. 合成文字						*patterns-composing*

							*/\Z*
パターンに "\Z" が含まれている場合、合成文字は無視されます。そのため、どの合成
文字が、いくつ結合されていても、基底文字とマッチするだけでマッチします。
'encoding' が "utf-8" の場合だけ使用します。
例外: パターンが一つか複数の合成文字で開始している場合は、それらはマッチしま
す。

合成文字と合成されないアイテムの直後に合成文字がある場合、その合成文字を含んで
いるすべての文字がマッチします。
{訳注: x が合成文字として /x/  /\(x\)/  /\zsx/ など}

ドットと合成文字を使うと、どの文字に合成されていても、その合成文字にマッチしま
す。
{訳注: x が合成文字として /.x/ と書く}

合成文字の順番は関係ありません。また、指定した以上の合成文字がテキストにあって
も、それはマッチします。ただし、パターンで指定したすべての合成文字がテキストに
含まれている必要があります。

例えば B が基底文字で x と y が合成文字として:
	パターン	テキスト	マッチ ~
	Bxy		Bxy		yes (完全マッチ)
	Bxy		Byx		yes (順番違い)
	Bxy		By		no (x がない)
	Bxy		Bx		no (y がない)
	Bx		Bx		yes (完全マッチ)
	Bx		By		no (x がない)
	Bx		Bxy		yes (余計な y は無視される)
	Bx		Byx		yes (余計な y は無視される)

==============================================================================
9. Perl のパターンとの比較				*perl-patterns*

Vim と Perl の正規表現は、とても似ていて、同じ事ができます。違いは表記だけで
す。違いの要約を示します:

効果				Vim の表記	Perl の表記 ~
----------------------------------------------------------------
大文字と小文字を区別しない	\c		(?i)
大文字と小文字を区別する	\C		(?-i)
後方参照しないグループ		\%(atom\)	(?:atom)
最短一致の量指定子		\{-n,m}		*?, +?, ??, {}?
幅ゼロの肯定先読み		atom\@=		(?=atom)
幅ゼロの否定先読み		atom\@!		(?!atom)
幅ゼロの肯定後読み		atom\@<=	(?<=atom)
幅ゼロの否定後読み		atom\@<!	(?<!atom)
強欲な量指定子			atom\@>		(?>atom)

Vim と Perl では文字列中の改行の扱いが少し違います:

Perl では、'^' と '$' はテキストの最先頭と最末尾にマッチしますが、'm' フラグを
使うと、テキストの中間の改行にもマッチするようになります。's' フラグを使うと、
'.' が改行にもマッチするようなります。'm' と 's' のフラグは、上記の(?i) フラグ
のように、パターン中で設定することもできます。

Vim では、'^' と '$' は常に中間の改行にもマッチします。最先頭と最末尾にはそれ
ぞれ、'\%^' と '\%$' がマッチします。Perl の 's' フラグに対応するのは '\_' 修
飾子です。'.' や文字クラスの前に '\_' を付けると、改行にもマッチするようになり
ます。

次のものは Perl だけの機能です:
- 正規表現中で任意のコードを実行する: (?{perl code})
- 条件式: (?(condition)true-expr|false-expr)

次のものは Vim だけの機能です:
- パターンのマジックを変更する:  \v \V \m \M
   (バックスラッシュだらけになるのを防げます)
- 任意にマッチするアトム列:  \%[atoms]
- \&   ("\&" と "\|" は、"and" と "or" の関係です。複数のブランチを同じ場所で
  マッチさせることができます)
- 行や列を指定してマッチングする:  \%5l \%5c \%5v
- 正規表現にマッチしたものとして返される範囲を設定する:  \zs \ze

==============================================================================
10. マッチしたテキストを強調する				*match-highlight*

							*:mat* *:match*
:mat[ch] {group} /{pattern}/
		カレントウィンドウ内で強調表示するパターンを定義します。強調に
		は {group} が使われます。例: >
			:highlight MyGroup ctermbg=green guibg=green
			:match MyGroup /TODO/
<		{pattern} の区切りには // 以外の文字を使うことができます。'"'
		や '|' などの特別な文字を使うときは注意してください。

		{group} は、コマンドを実行する前に定義しておく必要があります。

		{group} の強調は、'hlsearch' や構文強調 ('syntax' 参照) の強調
		よりも優先されます。

		Note: 'hlsearch' の強調はすべてのウィンドウに適用されますが、
		":match" はカレントウィンドウだけです。ウィンドウのバッファを
		切り替えても、強調表示は維持されます。

		'ignorecase' の設定は使われません。大文字と小文字は区別されま
		す。大文字と小文字の違いを無視するには、|/\c| を使います。

		'redrawtime' を設定すると、検索に費やす時間を制限できます。

		改行にマッチしているときに、Vim がディスプレイの一部だけを再描
		画すると、予期しない結果になることがありますが、それは、Vim が
		再描画した行からマッチの検索を開始するからです。

		|matcharg()| は |:match| コマンドで使用されたパターンと強調グ
		ループを返します。|getmatches()| は |matchadd()| と |:match|
		で定義されたマッチのパターンと強調グループのリストを返します。

		|:match| コマンドではマッチを三つまで定義できます (|:match|、
		|:2match|、|:3match|)。|matchadd()| にはこのような制限はありま
		せん。加えて、優先順位を設定することもできます。

		:match コマンドによって設定された強調グループとパターンを得る
		には |matcharg()| を使います。

		次の例は、表示桁で 72 列目以降の文字をすべて強調表示します: >
			:highlight rightMargin term=bold ctermfg=blue guifg=blue
			:match rightMargin /.\%>72v/
<		表示桁で 7 列目の文字をすべて強調表示するには次のようにします: >
			:highlight col8 ctermbg=grey guibg=grey
			:match col8 /\%<8v.\%>7v/
<		Note: TAB のような文字は、1 桁を超えて表示されます。

:mat[ch]
:mat[ch] none
		以前に定義したマッチパターンを消去します。


:2mat[ch] {group} /{pattern}/					*:2match*
:2mat[ch]
:2mat[ch] none
:3mat[ch] {group} /{pattern}/					*:3match*
:3mat[ch]
:3mat[ch] none
		上述の |:match| と同じですが、別々のマッチを設定します。そのた
		め、同時に三つのマッチを表示できます。同じ場所でマッチした場合
		は、数値の低いものが優先されます。
		":3match" コマンドは |matchparen| プラグインで使用されていま
		す。あなたが手動でマッチを設定するときは ":match" を使ってくだ
		さい。他のプラグインでは ":2match" を使ってください。

{訳注: 訳語:
         concat 連接
         multi >量指定子< 量指定詞 数量子 数量詞
         ordinary atom 普通のアトム
         a sequence of optionally matched atoms 任意にマッチするアトム列
         last search pattern 最終検索パターン}
 vim:tw=78:ts=8:ft=help:norl:
