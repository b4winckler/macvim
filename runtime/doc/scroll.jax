*scroll.txt*    For Vim バージョン 7.3.  Last change: 2006 Aug 27


		VIMリファレンスマニュアル    by Bram Moolenaar


スクロール						*scrolling*

これらのコマンドはウィンドウの内容を移動する。カーソルがウィンドウの外に移動し
ようとすると、カーソルはウィンドウに留まるように振舞う('scrolloff'のスクリーン
行をカーソルの周囲に確保する)。1ページとはウィンドウの行数から2引いた行数と定
義する。これらのコマンドを覚えるのは少し厄介かもしれない。ウィンドウをバッファ
のうち貴方が見ている一部分と捉えて、ウィンドウの動きをバッファ内での上下の移動
に関連付けてコマンドを覚えると良いだろう。例えばバッファの中でウィンドウが上に
動くと、ウィンドウのテキストはスクリーンの下の方へ移動していくことになる。

手始めにユーザーマニュアルの|03.7|を読んでください。

1. 下方スクロール		|scroll-down|
2. 上方スクロール		|scroll-up|
3. カーソル相関スクロール	|scroll-cursor|
4. 水平スクロール		|scroll-horizontal|
5. 同期スクロール		|scroll-binding|
6. マウスホイールスクロール	|scroll-mouse-wheel|

==============================================================================
1. 下方スクロール					*scroll-down*

以下のコマンドは編集ウィンドウ(バッファ内の貴方が見ている一部分)を下に移動する
(つまりテキストバッファのより下にある行を見ることができる):

							*CTRL-E*
CTRL-E			バッファの下へ[count]行ウィンドウをスクロールする。
			覚え方: Extra lines (訳注: Extra=割増)

							*CTRL-D*
CTRL-D			ウィンドウをバッファ内で下にスクロールする。スクロール
			する行数は'scroll'オプションで指定される(省略した場合:
			スクリーンの半分の行数)。[count]が指定された場合、
			'scroll'オプションに[count]が設定されてからスクロール
			する。カーソルもファイル内で同じ行数だけ下へ移動する
			(もし可能ならば; 行が折り返されている場合やファイルの
			終端に達した時は違ってくる)。カーソルがバッファの最終
			行にある時は何も起こらずビープ音が鳴る。'startofline'
			オプションも参照。
			{Vi と異なる点: ファイルの物理行数スクロールさせる代わ
			りに、Vimでは'scroll'行分スクリーンの論理行でスクロー
			ルする; これは行が折り返されている時に違いを生む}

<S-Down>	or				*<S-Down>* *<kPageDown>*
<PageDown>	or				*<PageDown>* *CTRL-F*
CTRL-F			ウィンドウをバッファ内で[count]ページ前方(下方)にスク
			ロールする。'startofline'オプションも参照。
			ウィンドウが1つだけのときはオプション'window'の値が使
			われる。

							*z+*
z+			[count]が無い時: 現在のウィンドウの最下行を最上行にし
			て再描画する。カーソルはその行の、最初の非空白文字に合
			わせられる。
			[count]が有る時: ちょうど"z<CR>"と同じ。

==============================================================================
2. 上方スクロール					*scroll-up*

以下のコマンドは編集ウィンドウ(バッファ内の貴方が見ている一部分)を上に移動する
(つまりテキストバッファのより上にある行を見ることができる):

							*CTRL-Y*
CTRL-Y			バッファの上へ[count]行ウィンドウをスクロールする。
			Note: MS-Windowsのキーバインディングを使っているときは
			CTRL-Yはredoにマッピングされています。

							*CTRL-U*
CTRL-U			ウィンドウをバッファ内で上にスクロールする。スクロー
			ルする行数は'scroll'オプションで指定される(省略した場
			合: スクリーンの半分の行数)。[count]が指定された場合、
			'scroll'オプションに[count]が設定されてからスクロール
			する。カーソルもファイル内で同じ行数だけ上へ移動する
			(もし可能ならば; 行が折り返されている場合やファイルの
			先頭に達した時は違ってくる)。カーソルがバッファの先頭
			行にある時は何も起こらずビープ音が鳴る。'startofline'
			オプションも参照。
			{Vi と異なる点: ファイルの物理行数スクロールさせる代わ
			りに、Vimでは'scroll'行分スクリーンの論理行でスクロー
			ルする; これは行が折り返されている時に違いを生む}

<S-Up>		or					*<S-Up>* *<kPageUp>*
<PageUp>	or					*<PageUp>* *CTRL-B*
CTRL-B			ウィンドウをバッファ内で[count]ページ後方(上方)にスク
			ロールする。'startofline'オプションも参照。
			ウィンドウが1つだけのときはオプション'window'の値が使
			われる。

							*z^*
z^			[count]が無い時: 現在のウィンドウの最上行を最下行にし
			て再描画する。カーソルはその行の、最初の非空白文字に合
			わせられる。
			[count]が有る時: まず[count]行がウィンドウの最下行に
			なるようにスクロールし、次にウィンドウの最上行になっ
			た行を最下行にして再描画する。カーソルはその行の最初
			の非空白文字に合わせられる。

==============================================================================
3. カーソル相関スクロール				*scroll-cursor*

下記のコマンドはカーソルの位置は変えずに編集ウィンドウ(バッファの見えている一
部)の位置を変える:

							*z<CR>*
z<CR>			[count]行(省略時はカーソルのある行)をウィンドウの最上
			行にして再描画する。カーソルは行内の最初の非空白文字に
			置かれる。

							*zt*
zt			"z<CR>"と同様だが、カーソルは同じカラムに留める。
			{Vi にはない}

							*zN<CR>*
z{height}<CR>		ウィンドウを高さ{height}行に変更して再描画する。スク
			リーンの更新が非常に遅い時に、高さを減らすと有効であ
			る。物理的なスクリーンの高さよりも高くすることはできな
			い。

							*z.*
z.			[count]行(省略時はカーソルのある行)をウィンドウの中心
			にして再描画する。カーソルは行内の最初の非空白文字に置
			かれる。

							*zz*
zz			"z."と同様だが、カーソルは同じコラムに留める。注意:
			caps-lockが有効になっていると、このコマンドは"ZZ"にな
			り、バッファを書き出し終了してしまう。{Vi にはない}

							*z-*
z-			[count]行(省略時はカーソルのある行)をウィンドウの最下
			行にして再描画する。カーソルは行内の最初の非空白文字に
			置かれる。

							*zb*
zb			"z-"と同様だが、カーソルは同じコラムに留める。
			{Vi にはない}

==============================================================================
4. 水平スクロール					*scroll-horizontal*

次の4つのコマンドはスクリーンに応じてカーソルが移動する。カーソルのある文字が
スクリーンが動いたために消えると、カーソルはスクリーン上の一番近い文字に移動す
る。'sidescroll'の値は使用されない。

z<Right>    or						*zl* *z<Right>*
zl			スクリーンを[count]文字右へ移動する。従ってテキストは
			[count]文字左へスクロールする。これは'wrap'がオフの時
			にだけ働く。 {Vi にはない}

z<Left>      or						*zh* *z<Left>*
zh			スクリーンを[count]文字左へ移動する。従ってテキストは
			[count]文字右へスクロールする。これは'wrap'がオフの時
			にだけ働く。 {Vi にはない}

							*zL*
zL			スクリーンの幅の半分右へスクロールする。従ってテキスト
			はスクリーンの幅の半分左へスクロールする。これは'wrap'
			がオフの時にだけ働く。 {Vi にはない}

							*zH*
zH			スクリーンの幅の半分左へスクロールする。従ってテキスト
			はスクリーンの幅の半分右へスクロールする。これは'wrap'
			がオフの時にだけ働く。 {Vi にはない}

次の2つのコマンドではテキスト上でカーソルは移動せず、スクリーンのテキストだけ
がスクロールする。

							*zs*
zs			カーソルのある位置がスクリーンの始まり(左側)に来るよう
			にテキストを水平にスクロールする。これは'wrap'がオフの
			時にだけ働く。 {Vi にはない}

							*ze*
ze			カーソルのある位置がスクリーンの終わり(右側)に来るよう
			にテキストを水平にスクロールする。これは'wrap'がオフの
			時にだけ働く。 {Vi にはない}

==============================================================================
5. 同期スクロール					*scroll-binding*

時折、2つかそれ以上のウィンドウを結びつけて、1つがスクロールしたら他のウィンド
ウもスクロールして欲しいと思うことがある。Vimではウィンドウごとに'scrollbind'
オプションを設定することでこのような振る舞いをさせることが可能である。
'scrollbind'が設定されたあるウィンドウがスクロールした場合、他の'scrollbind'が
設定されたウィンドウが可能なら同じ量だけスクロールする。'scrollbind'の振る舞い
は'scrollopt'オプションによって変更することができる。

スクロールバーを使っているとき、マウスでスクロールバーを操作しても他のウインド
ウはスクロールされない。これは少しの間だけ同期スクロールを使わないでスクロールし
たい時に使える。

ウインドウに'diff'オプションも設定されているとき、同期スクロールは二つのバッフ
ァの差分を考慮してスクロールする。以下の機能が使われなければこれはうまく機能す
る。

							*scrollbind-relative*
'scrollbind'された各々のウィンドウは"相対的なオフセット"の量を監視し、それは現
在のウィンドウの垂直スクロール位置とその他のウィンドウの垂直スクロール位置の間
の違いと考えることができる。'scrollbind'ウィンドウの1つがテキストの最初もしく
は最後を超えてスクロールしようとすると、ウィンドウはもはやスクロールせず、しか
しどれだけ臨界を超えて移動しようとしたかは記憶される。ウィンドウはこの情報を持
ち続けて同じオフセットを管理できるように、そのバッファの限界を超えてスクロール
を要求されたかにはかまわない。
(訳注: 意味は理解できない)

しかしながら、そのバッファの限界を超えるような相対オフセットを持つウィンドウに
カーソルフォーカスが与えられると、その他の'scrollbind'されたウィンドウは現在の
ウィンドウの有効な相対オフセットの位置にジャンプすることになる。この振る舞いは
'scrollopt'オプションから'jump'フラグを削除することで変えることができる。

						*syncbind* *:syncbind* *:sync*
:syncbind		すべての'scrollbind'ウィンドウが同じ相対オフセットを持
			つように強制する。すなわち'scrollbind'ウィンドウがその
			バッファの先頭にスクロールされた時、その他の
			'scrollbind'ウィンドウもまたそれぞれのバッファの先頭に
			持っていかれる。

							*scrollbind-quickadj*
'scrollbind'フラグはウィンドウを垂直スクロールするキーボードコマンドを使う時に
意味があり、またカーソルフォーカスを持つウィンドウの垂直スクロールバーを使うと
きに意味がある。しかしながら、カーソルフォーカスを持たないウィンドウの垂直スク
ロールバーを使うときには、'scrollbind'は無視される。これを'scrollbind'された
ウィンドウの相対オフセットを修正する時に利用できる。

==============================================================================
6. マウスホイールスクロール				*scroll-mouse-wheel*

マウスにスクロールホイールがあるときは、GUI の Vim でそれを使うことができる。
どのように動作するかはシステムに依存する。ホイールは xterm でも動作する
|xterm-mouse-wheel|。デフォルトでは垂直スクロールホイールのみサポートされてい
る。いくつかの GUI では水平スクロールホイールもサポートされている。

Win32 GUIではスクロールの動作はソースに埋め込まれている。それはちょうど現在の
ウィンドウのスクロールバーをドラッグした時のように働く。何行スクロールするかは
貴方のマウスドライバに依存する。スクロールの動作が入力フォーカスの問題を引き起
こすならば、|intellimouse-wheel-problems|を参照。

X11 GUI (Motif、Athena、GTK) ではホイールを回すと <ScrollWheelUp>、
<ScrollWheelDown>、<ScrollWheelLeft>、<ScrollWheelRight> などのキー入力が発生
する。例えば、スクロールホイールを上に回すと <ScrollWheelUp> キーが生成され、
ウィンドウが上にスクロールする (つまりテキストが下に移動する)。これらのキーの
デフォルトの動作は次の通り:
    <ScrollWheelUp>	    3 行上にスクロール		*<ScrollWheelUp>*
    <S-ScrollWheelUp>	    1 画面上にスクロール	*<S-ScrollWheelUp>*
    <C-ScrollWheelUp>	    1 画面上にスクロール	*<C-ScrollWheelUp>*
    <ScrollWheelDown>	    3 行下にスクロール		*<ScrollWheelDown>*
    <S-ScrollWheelDown>	    1 画面下にスクロール	*<S-ScrollWheelDown>*
    <C-ScrollWheelDown>	    1 画面下にスクロール	*<C-ScrollWheelDown>*
    <ScrollWheelLeft>	    6 列左にスクロール		*<ScrollWheelLeft>*
    <S-ScrollWheelLeft>	    1 画面左にスクロール	*<S-ScrollWheelLeft>*
    <C-ScrollWheelLeft>	    1 画面左にスクロール	*<C-ScrollWheelLeft>*
    <ScrollWheelRight>	    6 列右にスクロール		*<ScrollWheelRight>*
    <S-ScrollWheelRight>    1 画面右にスクロール	*<S-ScrollWheelRight>*
    <C-ScrollWheelRight>    1 画面右にスクロール	*<C-ScrollWheelRight>*
これはコマンドラインを編集する以外の、全てのモードで動作するだろう。

Note: 水平スクロールは 'nowrap' が設定されているときのみ機能します。また、
'guioptions' の "h" フラグが設定されていない場合は、スクロールするとカーソル行
が画面外になってしまうようなときに、表示されている範囲の一番長い行にカーソルが
移動します (水平スクロールバーの動作に似た感じ)。

キーマッピングによりデフォルトの振る舞いを変更することができる。例えば、ノーマ
ルモードでホイールによるスクロールを1行にしたり半画面にしたりできる: >
    map <MouseDown> <C-Y>
    map <S-MouseDown> <C-U>
    map <MouseUp> <C-E>
    map <S-MouseUp> <C-D>
AltやCtrlといった修飾も可能である。

これはもちろん、Vimがスクロールホイールのイベントを取得している時にだけ働く。
この機能が働くかどうかは"xev"プログラムを使用すればチェックできる。

XFree86を使っているときには、/etc/XF86Configに貴方のマウスの正しいエントリがな
ければならない。FreeBSDでは、このようなエントリーがロジテックのスクロールマウ
ス用に必要である。 >
    Protocol     "MouseMan"
    Device       "/dev/psm0"
    ZAxisMapping 4 5
詳しくはXFree86のドキュメントを参照すること。

						*<MouseDown>* *<MouseUp>*
<MouseDown> と <MouseUp> は廃止されました。<MouseDown> の代わりに
<ScrollWheelUp> を、<MouseUp> の代わりに <ScrollWheelDown> を使ってください。

							*xterm-mouse-wheel*
新しいxtermでマウスホイールを使うには、上で書かれているようにXserverでスクロー
ルホイールマウスが動作するようにするだけで良い。

古いxtermでマウスホイールを使うにはこうする:
1. 上にかかれているように、Xserverで使えるようにする。
2. xtermに変換を追加し、スクロールイベントをVimへエスケープシーケンスとして渡
   すようにする。
3. Vimにマッピングを追加し、エスケープシーケンスを <ScrollWheelDown> もしくは
   <ScrollWheelUp> キーとして解釈できるようにする。

次のような内容をあなたの~/.Xdefaults(もしくは別名の貴方のXリソースファイル)に
追加すれば変換ができる。 >

  XTerm*VT100.Translations:		#override \n\
  		s<Btn4Down>: string("0x9b") string("[64~") \n\
  		s<Btn5Down>: string("0x9b") string("[65~") \n\
  		<Btn4Down>: string("0x9b") string("[62~") \n\
  		<Btn5Down>: string("0x9b") string("[63~") \n\
 		<Btn4Up>: \n\
 		<Btn5Up>:

以下のマッピングを vimrc ファイルに追加してください: >
	:map <M-Esc>[62~ <ScrollWheelUp>
	:map! <M-Esc>[62~ <ScrollWheelUp>
	:map <M-Esc>[63~ <ScrollWheelDown>
	:map! <M-Esc>[63~ <ScrollWheelDown>
	:map <M-Esc>[64~ <S-ScrollWheelUp>
	:map! <M-Esc>[64~ <S-ScrollWheelUp>
	:map <M-Esc>[65~ <S-ScrollWheelDown>
	:map! <M-Esc>[65~ <S-ScrollWheelDown>
<
 vim:tw=78:ts=8:ft=help:norl:
