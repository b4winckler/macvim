*usr_27.txt*	For Vim バージョン 7.3.  Last change: 2010 Mar 28

		     VIM USER MANUAL - by Bram Moolenaar

			    検索コマンドと正規表現


3 章で検索パターンについて簡単に説明しました |03.9|。Vim ではもっと複雑な検索
もできます。この章では、よく使われる検索パターンについて説明します。詳細な仕様
については |pattern| を参照してください。

|27.1|	大文字と小文字を区別しない
|27.2|	ファイルの端で折り返す
|27.3|	オフセット
|27.4|	繰り返しマッチ
|27.5|	選択肢
|27.6|	文字範囲
|27.7|	文字クラス
|27.8|	改行記号にマッチ
|27.9|	例

次章: |usr_28.txt|  折り畳み
前章: |usr_26.txt|  繰り返し
目次: |usr_toc.txt|

==============================================================================
*27.1*	大文字と小文字を区別しない

初期設定では大文字と小文字は区別されます。つまり "include" と "INCLUDE" と
"Include" は三つの別々の単語として扱われ、検索してもどれか一つにしかマッチしま
せん。
'ignorecase' オプションをオンにしてみましょう: >

	:set ignorecase

"include" を検索すると、"Include" にも "INCLUDE" にも "InClUDe" にもマッチしま
す。('hlsearch' オプションをオンにするとパターンにマッチした箇所を簡単に確認で
きます。)
次のコマンドでオプションをオフにできます: >

	:set noignorecase

しかしまだ設定は変更せずに、そのまま "INCLUDE" を検索してみます。"include" を
検索したときとまったく同じテキストがマッチします。次に 'smartcase' オプション
をオンに設定してみます: >

	:set ignorecase smartcase

パターンに大文字が含まれているときに限り、大文字と小文字が区別されるようになり
ます。これは、大文字を入力するのは大文字と小文字を区別したいときだけだろうとい
う考えに基づいています。スマートでしょ!
この二つのオプションを設定すると次のようにマッチします:

	パターン		マッチ	~
	word			word, Word, WORD, WoRd, etc.
	Word			Word
	WORD			WORD
	WoRd			WoRd


パターンの中で指定する
----------------------

ある特定のパターンの中でだけ大文字と小文字の無視したい場合は、パターンに "\c"
をつけます。大文字と小文字を区別したいときは "\C" を使います。"\c" と "\C" の
指定は 'ignorecase' と 'smartcase' の設定よりも優先されます。

	パターン		マッチ	~
	\Cword			word
	\CWord			Word
	\cword			word, Word, WORD, WoRd, etc.
	\cWord			word, Word, WORD, WoRd, etc.

"\c" と "\C" の大きな利点はそれがパターンに埋め込まれていることです。検索履歴
からパターンを再利用したときなどに、同じ検索結果を期待できます。'ignorecase'
や 'smartcase' の設定は影響しません。

	Note:
	検索パターンでの "\" の扱いは 'magic' オプションに依存します。この章で
	は 'magic' がオンに設定されていることを前提にしています。それが標準設
	定であり推奨設定です。'magic' を変更してしまうと今まで使えていた検索パ
	ターンが使えなくなってしまうかもしれません。

	Note:
	検索がなかなか終わらない場合は CTRL-C (Unix) または CTRL-Break (MS-DOS
	と MS-Windows) で処理を中断できます。

==============================================================================
*27.2*	ファイルの端で折り返す

前方検索を実行すると現在のカーソル位置から処理が開始し、指定された文字列が検索
されます。そしてファイルの末尾まで検索が進みます。ファイルの末尾まで検索しても
文字列が見つからない場合は、ファイルの先頭からカーソル位置に向かって検索が継続
します。
"n" コマンドを使って順々に検索を進めている場合もそのうち最初にヒットした場所に
戻ってきます。これに気が付かないと永遠に検索を続けることになってしまいます!
そのようなことがないように、次のようなメッセージが表示されます:

	下まで検索したので上に戻ります ~

"?" コマンドを使って逆方向に検索している場合は次のメッセージが表示されます:

	上まで検索したので下に戻ります ~

それでも気づかないことがあるかもしれません。'ruler' オプションをオンにすると確
認しやすくなります: >

	:set ruler

ウィンドウの右下隅 (ステータスラインがあるときはその中) にカーソルの位置が表示
されます。次のような表示です:

	101,29       84% ~

最初の数字はカーソルの行番号です。検索を開始した行番号を覚えておいて、検索が一
周してないか確認しましょう。


折り返さない
------------

検索を折り返さないようにするには次のコマンドを使います: >

	:set nowrapscan

検索がファイルの末尾に達するとエラーメッセージが表示されます:

	E385: 下まで検索したけれど該当箇所はありません: forever ~

すべての箇所を検索したい場合は "gg" でファイルの先頭に移動してからこのメッセー
ジが表示されるまで検索を繰り返してください。
"?" を使って逆方向に検索した場合は次のメッセージが表示されます:

	E384: 上まで検索したけれど該当箇所はありません: forever ~

==============================================================================
*27.3*	オフセット

通常、検索コマンドを実行すると、パターンにヒットした場所の先頭にカーソルが移動
します。オフセットを指定することで別の場所に移動することができます。前方検索コ
マンドの "/" の場合、パターンの後ろに "/" とオフセット値を指定します: >

	/default/2

"default" というパターンが検索され、見つかった場所から二行下の行頭にカーソルが
移動します。例えばこのコマンドで今読んでいる段落を検索すると、一行目に
"default" が見つかるので、カーソルはその二行した (つまりこの行) に移動すること
になります。

オフセットに数値を指定すると、マッチした行から指定した行数だけ移動した行の行頭
にカーソルが移動します。オフセット値には負の数も指定できます。正の数ならカーソ
ルが下に移動し、負の数なら上に移動します。


文字オフセット
--------------

"e" はマッチした文字列の末尾を示すオフセットです。マッチした文字列の末尾にカー
ソルが移動します。次のように使います: >

	/const/e

"const" の "t" にカーソルが移動します。
オフセットに数値を足すと、その場所からさらにカーソルを進めることができます。
次のコマンドではマッチした文字列の後ろにカーソルが移動します: >

	/const/e+1

正の数ならカーソルが右に動き、負の数なら左に動きます。例: >

	/const/e-1

"const" の "s" にカーソルが移動します。

オフセットに "b" を指定すると、マッチした文字列の先頭に移動できます。これはオ
フセット指定無しの動作と同じなので単体では使い道はありません。数値を足したり引
いたりしたい場合に使います。指定した数だけカーソルを前後に移動できます。例: >

	/const/b+2

マッチした文字列の先頭から二文字右にカーソルが移動します。つまり "n" の上です。


繰り返し
--------

直前に使った検索パターンを、別のオフセットを使って再検索したい場合は、パターン
指定を省略します: >

	/that
	//e

これは次の指定と同じです: >

	/that/e

同じオフセットを使って再検索したい場合は: >

	/

"n" と同じ動作になります。オフセット指定を無効にして再検索したい場合は次のよう
にします: >

	//


後方検索
--------

"?" コマンドでも同じようにオフセットを指定できますが、パターンとオフセットを区
切るのは "/" ではなく "?" になります: >

	?const?e-2

"b" と "e" の意味は同じです。"?" を使う場合でも方向は逆になりません。


検索開始位置
------------

検索は通常、現在のカーソル位置から開始します。オフセットを指定するとうまくいか
ないときがあります。例: >

	/const/-2

"const" を検索してその二行上に移動します。"n" を使って再検索すると、その場所か
ら検索が開始して同じ場所の "const" がヒットします。そして、再びオフセットが適
用されて元の場所に戻ってきます。まったく移動できません。
次の行に "const" があった場合はもっとおかしなことになります。検索を実行すると
次の行がヒットして、その二行上にカーソルが移動するので、カーソルが逆方向に移動
してしまうのです。

文字オフセットを使った場合はそうなりません。オフセット指定の分だけ検索開始位置
がずれるので、同じものが再びヒットすることはありません。

==============================================================================
*27.4*	繰り返しマッチ

ある文字を任意の数だけマッチさせたい場合は "*" を使います: >

	/a*

これは "a" でも "aa" でも "aaa" でもマッチします。0 回というのも任意の数に含ま
れるので "" (空文字列) もマッチします。
"*" は直前の文字に対してだけ適用されます。"ab*" なら "a"、"ab"、"abb"、"abbb"
などがマッチします。単語を繰り返したい場合は、その単語をグループにまとめなけれ
ばなりません。"\(" と "\)" で単語を囲んでください。次のように使います: >

	/\(ab\)*

"ab"、"abab"、"ababab"、"" などにマッチします。

空文字列にマッチさせたくない場合は "\+" を使います。直前の文字が一つ以上あると
きだけマッチするようになります: >

	/ab\+

"ab"、"abb"、"abbb" などにマッチします。"b" が後ろに付いていない "a" にはマッ
チしません。

0 または 1 つの文字にマッチさせたい場合は "\=" を使います。例: >

	/folders\=

"folder" と "folders" がマッチします。


回数指定
--------

特定の数だけ文字をマッチさせるには "\{n,m}" を使います。"n" と "m" に数字を指
定します。直前の文字が "n" から "m" の数だけ連続している場合にマッチします。
例: >

	/ab\{3,5}

"abbb"、"abbbb"、"abbbbb" にマッチします。
"n" を省略した場合は 0 が使われます。"m" が省略された場合は繰り返し回数は無制
限になります。",m" を省略した場合は、正確に "n" 回の繰り返しにマッチします。
例:

	pattern		match count ~
	\{,4}		0, 1, 2, 3 or 4
	\{3,}		3, 4, 5, etc.
	\{0,1}		0 or 1 (\= と同じ)
	\{0,}		0 以上 (* と同じ)
	\{1,}		1 以上 (\+ と同じ)
	\{3}		3


最短一致
--------

今まで説明した繰り返し指定は、可能な限りたくさんの文字列にマッチしようとしま
す。できるだけ少ない回数だけマッチさせるには "\{-n,m}" を使います。動作は
"\{n,m}" とほとんど同じですが、最短一致が使われます。
例: >

	/ab\{-1,3}

"abbbb" の中の "ab" だけがマッチします。一つの "b" にマッチするだけで条件を満
たすので、二つ目以降の "b" には絶対にマッチしません。後ろに他のパターンが続い
ているなら最小回数以上の文字にもマッチします。
"n" と "m" を省略した場合も同じルールが適用されます。両方の数字を省略して
"\{-}" とすることもできます。これは直前の文字が 0 回以上繰り返されている場合に
最小の数だけマッチします。単体で使った場合は常に 0 回にマッチします。他のパター
ンと組み合わせて使うと便利です。例: >

	/a.\{-}b

"axbxb" の中の "axb" にマッチします。次のパターンを使った場合は: >

	/a.*b

".*" は可能な限り多くの文字にマッチするので "axbxb" 全体がマッチします。

==============================================================================
*27.5*	選択肢

パターンの中で "or" (または) を指定するには "\|" を使います。例: >

	/foo\|bar

"foo" と "bar" のどちらかがマッチします。複数の選択肢を指定できます: >

	/one\|two\|three

"one"、"two"、"three" のどれかにマッチします。
複数回マッチさせるには、全体を "\(" と "\)" で囲みます: >

	/\(foo\|bar\)\+

"foo"、"foobar"、"foofoo"、"barfoobar" などにマッチします。
もう一つの例: >

	/end\(if\|while\|for\)

"endif"、"endwhile"、"endfor" にマッチします。

"\&" も似たような条件指定です。指定された選択肢がすべて同じ場所でマッチします。
マッチ結果としては最後の選択肢が使われます。例: >

	/forever\&...

"forever" の "for" にマッチします。"fortuin" にはマッチしません。

==============================================================================
*27.6*	文字範囲

"a"、"b"、"c" のどれかにマッチさせるには "/a\|b\|c" が使えます。しかし "a" か
ら "z" までの文字をマッチさせようとするとパターンが長くなってしまいます。簡単
な方法があります: >

	/[a-z]

[] は一つの文字にマッチします。マッチさせたい文字を [] の中に指定します。次の
ようにして文字を一つずつ指定することもできます: >

	/[0123456789abcdef]

指定された文字の中から一つがマッチします。文字が連続している場合は文字範囲を指
定できます。例えば "0-3" は "0123" という意味です。"w-z" は "wxyz" という意味
になります。上記の例は次のように短くできます: >

	/[0-9a-f]

文字 "-" 自体をマッチさせたい場合は [] の中の一番最初か最後に書いてください。
[] の中では以下の特殊文字が使えます (これらは [] の中でなくても使えます):

	\e	<Esc>
	\t	<Tab>
	\r	<CR>
	\b	<BS>

[] の中では他にも特殊な指定方法が使えます。詳細は |/[]| を参照してください。


文字範囲の補集合
----------------

マッチして欲しくない文字を指定したい場合は、文字範囲の先頭に "^" を指定します。
すると、指定した文字以外の文字がマッチするようになります。例: >

	/"[^"]*"
<
	 "	  ダブルクオート
	  [^"]	  ダブルクオート以外の文字が
	      *	  可能な限りたくさん
	       "  ダブルクオート

"foo" や "3!x" がマッチします (ダブルクオートもマッチに含まれる)。


定義済み文字範囲
----------------

一般的な文字範囲はあらかじめ定義されています。
例: >

	/\a

アルファベット文字が検索されます。これは "/[a-zA-Z]" と同じです。他にも次のよ
うなものがあります:

	item	matches			 equivalent ~
	\d	数字			 [0-9]
	\D	数字以外		 [^0-9]
	\x	16進数の数字		 [0-9a-fA-F]
	\X	16進数の数字以外	 [^0-9a-fA-F]
	\s	空白文字		 [ 	]     (<Tab>か<Space>)
	\S	空白文字以外		 [^ 	]     (<Tab>か<Space>以外)
	\l	小文字アルファベット	 [a-z]
	\L	小文字アルファベット以外 [^a-z]
	\u	大文字アルファベット	 [A-Z]
	\U	大文字アルファベット以外 [^A-Z]

	Note:
	定義済み文字範囲は普通の文字範囲よりも処理が高速です。
	これらのアイテムは [] の中では指定できません。つまり "[\d\l]" と書いた
	としても数字と小文字にはマッチしません。"\(\d\|\l\)" を使ってください。

定義済み文字範囲の一覧は |/\s| を参照してください。

==============================================================================
*27.7*	文字クラス

文字範囲は特定の文字のセットにマッチします。文字クラスも似たようなものですが、
検索パターンを変更せずに文字のセットを変更できるという違いがあります。
例えば、次のパターンを検索します: >

	/\f\+

"\f" はファイル名に使える文字を表します。つまりこのパターンはファイル名として
使える文字列にマッチします。
どの文字がファイル名として使えるかはシステムによって異なります。MS-Windows で
は "\" が使えますが Unix では使えません。これは 'isfname' オプションで指定され
ています。Unix の初期設定: >

	:set isfname
	isfname=@,48-57,/,.,-,_,+,,,#,$,%,~,=

他のシステムでは初期設定が変わります。ファイル名にマッチさせたいときに "\f" を
使えば、そのパターンはいろいろなシステムで使えます。

	Note:
	Unix では空白などのどんな文字でもファイル名に使えます。'isfname' にそ
	れらの文字を設定するのは理論的には正しいことです。しかしその場合、テキ
	ストの中からファイル名を切り出すのが困難になってしまいます。したがっ
	て、'isfname' の初期設定にはすべての文字は含まれていません。

次のような文字クラスがあります:

	item	matches				option ~
	\i	識別子に使える文字		'isident'
	\I	\iから数字を抜いたもの
	\k	キーワードとなる文字		'iskeyword'
	\K	\kから数字を抜いたもの
	\p	印刷可能文字			'isprint'
	\P	\pから数字を抜いたもの
	\f	ファイル名に使える文字		'isfname'
	\F	\fから数字を抜いたもの

==============================================================================
*27.8*	改行記号にマッチ

改行を含んだパターンを検索することができます。改行の位置は明示的に指定する必要
があります。今までに説明したパターンアイテムはどれも改行にマッチしません。
改行の場所を指定するには "\n" を使います: >

	/the\nword

行末が "the" で終わり、次の行の行頭が "word" になっている行がマッチします。
"the word" にもマッチさせたい場合は、スペースと改行の両方をマッチさせる必要が
あります。それには "\_s" を使います: >

	/the\_sword

間に空白をいくつでも挟めるようにするには: >

	/the\_s\+word

これは、行末が "the   " で終わり、次の行の行頭が "   word" で始まっているよう
な場所にもマッチします。

"\s" は空白にマッチします。"\_s" は空白と改行にマッチします。
同様に、"\a" はアルファベットにマッチし、"\_a" はアルファベットと改行にマッチ
します。他の文字クラスや文字範囲も同様に、"_" を付けることによって改行にもマッ
チするようになります。

他の多くのパターンアイテムも "\_" を付けることによって改行にマッチさせることが
できます。例えば、"\_." は改行を含めたすべての文字にマッチします。

	Note:
	"\_.*" はファイル末尾までのすべての文字がマッチします。検索コマンドの
	動作が遅くなるかもしれないので注意してください。

"\_[]" を使うと文字範囲にも改行を追加できます: >

	/"\_[^"]*"

ダブルクオートで囲まれたテキストが検索されます。間には改行も含むことができま
す。

==============================================================================
*27.9*	例

便利そうな検索パターンをいくつか説明します。今までに説明したパターンをどのよう
に使えばいいかを示します。


カリフォルニア州のナンバープレートを探す
----------------------------------------

"1MGU103" という番号を検索してみます。これは一つの数字、三つの大文字アルファ
ベット、三つの数字、から成っています。そのままパターンに置き換えてみます: >

	/\d\u\u\u\d\d\d

同じものが並んでいる部分は回数指定に置き換えることができます: >

	/\d\u\{3}\d\{3}

[] 指定を使うこともできます: >

	/[0-9][A-Z]\{3}[0-9]\{3}

あなたならどれを使いますか? どれでも覚えやすいものを使ってください。簡単に覚え
られる方法を使う方がそうでないものを頑張って覚えるよりずっと効率がよくなりま
す。最後の例は他より長くて実行速度も遅いので、どれでも覚えられるという場合は選
択肢から外してください。


識別子を見つける
----------------

C 言語 (などのほとんどの言語) では、識別子は英文字で始まってその後に英数字が続
きます。アンダースコアも使えるかもしれません。次のパターンでそのような文字を検
索できます: >

	/\<\h\w*\>

"\<" と "\>" は単語全体をマッチさせるための指定です。"\h" は "[A-Za-z_]" と同
じ意味で、"\w" は "[0-9A-Za-z_]" と同じ意味になります。

	Note:
	"\<" と "\>" の動作は 'iskeyword' オプションに依存します。例えば "-"
	が含まれている場合、上記パターンは "ident-" にマッチしません。次のパ
	ターンを使ってください: >

		/\w\@<!\h\w*\w\@!
<
	識別子の前後の文字が "\w" にマッチしないかどうかをチェックしています。
	|/\@<!| と |/\@!| 参照。

==============================================================================

次章: |usr_28.txt|  折り畳み

Copyright: see |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
