*repeat.txt*    For Vim バージョン 7.3.  Last change: 2009 Nov 04


		VIMリファレンスマニュアル    by Bram Moolenaar


繰り返しコマンド、Vimスクリプトとデバッグ		*repeating*

繰り返しについてはユーザーマニュアルの26章|usr_26.txt|に紹介があります。

1. 単発繰り返し		|single-repeat|
2. 多重繰り返し		|multi-repeat|
3. 複雑な繰り返し	|complex-repeat|
4. Vimスクリプトを使う	|using-scripts|
5. スクリプトのデバッグ	|debug-scripts|
6. プロファイリング	|profiling|

==============================================================================
1. 単発繰り返し						*single-repeat*

							*.*
.			最後の変更を繰り返す。変更の回数は[count]で指定した回
			数で置き換えられる。'cpoptions'に'y'フラグが含まれてる
			時には、ヤンクコマンドも繰り返す。コマンドラインコマン
			ドは繰り返さない。

単純な変更は"."コマンドで繰り返すことができる。回数を指定しなければ、最後の変
更の回数が使用される。回数を指定した場合、最後のそれと置き換えられる。最後に行
なわれた変更が番号付きレジスタの指定を含んでいた場合、レジスタ番号は増加され
る。これをどのように使うかの例は|redo-register|を参照。ビジュアル選択を使用し
たコマンドを繰り返す時は、同じ「サイズ」の範囲が使用されることに注意。
|visual-repeat|を参照。

							*@:*
@:			最後のコマンドラインを[count]回繰り返す。
			{|+cmdline_hist|が無効にされていると使えない}


==============================================================================
2. 多重繰り返し						*multi-repeat*

					*:g* *:global* *E147* *E148*
:[range]g[lobal]/{pattern}/[cmd]
			[range]の範囲で{pattern}にマッチする行に対して、Exコマ
			ンド[cmd](省略した場合":p")を実行する。

:[range]g[lobal]!/{pattern}/[cmd]
			[range]の範囲で{pattern}にマッチしない行に対して、Exコ
			マンド[cmd](省略した場合":p")を実行する。

							*:v* *:vglobal*
:[range]v[global]/{pattern}/[cmd]
			:g! と同じ。

{patter}の両側の '/' の代わりにどんなシングルバイト文字でも使うことができ
る。しかしアルファベット・数字・'\', '"', '|' は使えない。
これは、検索パターンや置換文字列に '/' が含まれる場合に便利である。

パターンの定義については |pattern|を参照。

globalコマンドの動作はまず第1に[range]の行をスキャンしマッチした行すべてに印を
つける(複数行にかかるパターンではマッチの最初の行だけが重要である)。
次のスキャンでマークされたすべての行の行番号が指定(前置)されて[cmd]が実行され
る。行が変更されたり削除された場合そのマークは消滅する。
省略した場合の[range]はバッファ全体(1,$)である。コマンドを中断するには"CTRL-C"
を使用する。ある行についてエラーメッセージが与えられると、そのラインに対するコ
マンドは中断されglobalコマンドはマッチした次の行の処理を続ける。

非Exコマンドを繰り返すには":normal"コマンドを使用すれば良い: >
	:g/pat/normal {commands}
{commands}が完全なコマンドとして終了することを確認すること。そうでないとVimは
全部のマッチに1つ1つについて、コマンドの残りを期待して貴方の入力を待ち続けるだ
ろう。画面は更新されないので、いま何をしているのかわからないだろう。|:normal|
を参照。

undo/redoコマンドはglobalコマンドを一度にundo/redoする。以前の文脈マークだけが
一度設定される("''"でグローバルコマンド実行前にカーソルがあった場所に戻ること
が出来る)。

globalコマンドは最後に使用した検索パターンと、最後に使用した置換パターンの両方
を設定する(これはvi互換)。これにより全体に対して文字列置換を行なうのが簡単にな
る:
	:g/pat/s//PAT/g
これは総ての"pat"を"PAT"に置き換える。同じことがこれでも可能:
	:%s/pat/PAT/g
こっちのほうが2文字短い!

Ex モード中で "global" を使い、そのコマンドに ":visual" を指定する場合はやや特
殊である。これを行うと、マッチする行へ移動してノーマルモードに入るので、|Q| を
押して Ex モードへ戻るまでコマンドを実行することができる。これがマッチする各行
に対して繰り返される。これを行っている間は ":global" を使うことはできない。中
止するには CTRL-C を2回押すこと。

スペースが必要な場合には、バックスラッシュの直後に書くのがベストである。行末に
スペースを書くと、視認が難しく、誤って削除されてしまうかもしれない。 >
	:syn match Comment
		\ "very long regexp"
		\ keepend

==============================================================================
3. 複雑な繰り返し					*complex-repeat*

							*q* *recording*
q{0-9a-zA-Z"}		タイプした文字をレジスタ{0-9a-zA-Z"}にレコーディングす
			る(大文字は追加する)。レジスタを実行中は'q'コマンドは
			無効になり、マッピングの中でも無効になる。{Vi: レコー
			ディングはない}

q			レコーディングを終了する。(実装のメモ: レコーディング
			を終了する'q'は、それがマッピングの結果であってもレジ
			スタに記録されない) {Vi: レコーディングはない}

							*@*
@{0-9a-z".=*}		レジスタ{0-9a-z".=*}の内容を[count]回実行する。レジス
			タ'%'(現在のファイルの名前)と'#' (オルタネートファイル
			の名前)は使用できないことに留意。"@="を使用するとプロ
			ンプトが表示されコマンドの評価式の入力モードになる。入
			力すると評価の結果が実行される。|@:|も参照。{Vi: 名前
			付きレジスタのみ}

							*@@* *E748*
@@			直前の@{0-9a-z":*}を[count]回繰り返す。

:[addr]*{0-9a-z".=}						*:@* *:star*
:[addr]@{0-9a-z".=*}	レジスタ{0-9a-z".=*}の内容をExコマンドとして実行する。
			まず最初にカーソルを[addr]行に設定する(省略した場合現
			在の行)。レジスタの最終行に<CR>が含まれない場合、
			'cpoptions'に'e'フラグが含まれていれば自動的に追加され
			る。
			":*"コマンドは'cpoptions'に'*'フラグが含まれていた場合
			にだけ認識されることに留意。これは'nocompatible'が使用
			されている時にはデフォルトにはならない。
			":@="には最後に評価された式が使用される。式の評価結果
			がExコマンドとして実行される。
			これらのコマンド内ではマッピングは行なわれない。
			{Vi: 幾つかのバージョンだけ} 将来: 指定された範囲の
			各々の行にたいしてレジスタの内容が実行されるだろう。

							*:@:*
:[addr]@:		最後のコマンドラインを繰り返す。まずカーソルを[addr]行
			に設定する(省略した場合現在の行)。 {Vi にはない}

							*:@@*
:[addr]@@		最後の:@{0-9a-z"}を繰り返す。まず最初にカーソルを
			[addr]行に設定する(省略した場合現在の行)。 {Vi: 幾つか
			のバージョンだけ}

==============================================================================
4. Vimスクリプトを使う					*using-scripts*

Vimスクリプトの書き方はユーザーマニュアルの41章|usr_41.txt|を参照してくださ
い。

					*:so* *:source* *load-vim-script*
:so[urce] {file}	Exコマンドを{file}から読込む。これは":"で始まるコマン
			ドを列挙したファイルです。
			(訳注:実際に":"を書く必要はない)
			自動コマンド |SourcePre| が発生する。

:so[urce]! {file}	Vimコマンドを{file}から読込む。ノーマルモードでファイ
			ルの内容をあなたがタイプしたのと同じように実行されま
			す。
			|:global|, |:argdo|, |:windo|, |:bufdo|で使ったとき、
			ループ中や他のコマンドが続けられたときは、コマンドの実
			行中は表示は更新されません。
			{Vi にはない}

							*:ru* *:runtime*
:ru[ntime][!] {file} ..
			'runtimepath'で示された各ディレクトリの{file}からEx
			コマンドを読み込みます。ファイルがなくてもエラーには
			なりません。例: >
				:runtime syntax/c.vim

<			{file}には空白で区切って複数のファイルを指定できます。
			指定された{file}は'runtimepath'の最初のディレクト
			リ、次に二番目のディレクトリ、と検索されます。{file}
			に空白を含めるにはバックスラッシュを使います(しかし
			ファイル名に空白を含めるのは望ましくありません。トラ
			ブルのもとです)。

			[!]を付けると見つかった全てのファイルを読み込みま
			す。付けなければ最初に見つかったファイルだけを読み込
			みます。

			{file}がワイルドカードを含んでいるとそれは展開されま
			す。例: >
				:runtime! plugin/*.vim
<			これはVimが起動時にプラグインファイルを読み込むのに
			使っているものです。次のは似ていますが: >
				:runtime plugin/*.vim
<			これは最初に見つかったファイルだけを読み込みます。

			'verbose'が1以上ならファイルが見つからないときにメッ
			セージが表示されます。
			'verbose'が2以上なら見つかった全てのファイルについて
			メッセージが表示されます。
			{Vi にはない}

:scripte[ncoding] [encoding]		*:scripte* *:scriptencoding* *E167*
			スクリプトで使われている文字コードを宣言します。
			それ以降の行は必要なら[encoding]から'encoding'オプ
			ションの文字コードに変換されます。例: >
				scriptencoding iso-8859-5
				scriptencoding cp932
<
			[encoding]が空のときは変換はされません。これは文字
			コードの変換を限定するために使います: >
				scriptencoding euc-jp
				... 変換される ...
				scriptencoding
				... 変換されない ...

<			変換がシステムによって提供されない場合、エラーメッ
			セージは表示されず変換もされません。

			"ucs-2"や"ucs-4"を使わないでください。スクリプトをそ
			の文字コードで書くことはできません(NULバイトが含まれ
			てしまうため)。
			スクリプトの最初にutf-8のBOM(Byte Order Mark : バイ
			トオーダーマーク)があるとVimはそれを認識します。
			":scriptencoding utf-8"と書く必要はありません。

			Vimが|+multi_byte|付きでコンパイルされていない場合、
			このコマンドは無視されます。
			{Vi にはない}

						*:scrip* *:scriptnames*
:scrip[tnames]		読み込まれているスクリプトを読み込まれた順番どおりに
			全て表示します。数字はスクリプトのID(識別子)|<SID>|
			に使われています。
			{Vi にはない} {|+eval|付きでコンパイルしないと使えな
			い}

						*:fini* *:finish* *E168*
:fini[sh]		スクリプトの読み込みを停止します。スクリプトファイル
			でのみ使えます。これはファイルの残りを読み込ませない
			ための手軽な方法です。|:try|を使った後で|:finally|を
			見つける前に使われると、まず":finally"と|:endtry|の
			間のコマンドが実行されます。この手続きは入れ子になっ
			ている全ての":try"に対して適用されます。入れ子の一番
			外側の":endtry"に達するとスクリプトを停止します。
			{Vi にはない}

総てのコマンドとコマンドシーケンスは、名前付きレジスタに格納することで繰り返し
実行することができる。レジスタにコマンドを格納する方法は2つある:
- 記録コマンド"q"を使用する。実際にコマンドをタイプし、実行しながらそれをレジ
  スタに格納する。今、何が起こっているかを確認できるので簡単である。間違いをし
  たならば、レジスタの内容をいったんファイルへ書き出("p"ut)して、コマンドシー
  ケンスを編集して、それからそれを削除して再びレジスタに格納することができる。
  レジスタに追加することで継続してレコーディングすることができる(大文字を使用
  する)。
- コマンドシーケンスを削除かヤンクしてレジスタに入れる。

良く使うコマンドは':map'コマンドでファンクションキーに割当てることができる:

別の方法としてコマンドをファイルに記述しておき、それを':source!'コマンドで読込
んで実行するという方法もある。長いコマンドシーケンスにとっては便利である。ファ
ンクションキーに複雑なコマンドを割当てるために':map'コマンドと組み合わせること
ができる。

':source'コマンドはファイルから一行ずつExコマンドを読込む。キーボード入力が必
要になった場合にはタイプする必要が生じる。':source!'コマンドはスクリプトファイ
ルから一字一句読込む。各々のキャラクタはユーザがタイプしたものとして解釈され
る。

例: ":!ls"コマンドを実行したとすると|hit-enter|プロンプトが表示される。"!ls"
を含むファイルを':source'したならば、自分で<Enter>をタイプする必要がある
だろう。しかし':!ls'を含んだファイルを':source!'したならば、<CR>が見つかるまで
そのファイルから続く文字が読込まれる。":!ls"がファイルの最終行でない限り、<CR>
を自分でタイプする必要はないだろう

スクリプトファイルの中で':source[!]'コマンドを使うことも可能なので、階層関係の
あるスクリプトファイルを作ることもできる。':source'コマンドは同時に開くことの
できるファイル数(だいたい15)と同じだけネスト(入れ子に)することができる。
':source!'コマンドは15段までネストすることができる。

読込まれるファイルの中ではファイル名が必要なところに、"<sfile>"という文字列(
文字 通りであってスペシャルキーではない)を使うことができる。この文字列は読込ま
れた ファイルのファイル名に置き換えられる。例えば、".vimrc"ファイルと同じ場所
に"other.vimrc"というファイルがあれば、".vimrc"から次のコマンドでそれを読込む
ことができる: >
	:source <sfile>:h/other.vimrc

スクリプトファイル内では端末依存のキーコードは端末非依存の2文字のコードで表現
される。これは異なる種類の端末でも同じ方法で依存キーコードを使用できることを意
味する。最初のキーコードの文字は0x80つまり128で、画面では"~@"と表される。2つ目
のキャラクタは|key-notation|の表にて見ることができる。これらのコードはどれも
CTRL-Vに続けて3つの10進コードを叩くことで入力できる。これはtermcapコード<t_xx>
に対しては使用できない。これらはマッピングの中だけで使うことができる。

						*:source_crnl* *W15*
MS-DOS, Win32 and OS/2: ":source"で読込まれるファイルは通常、行末に<CR><NL>を
持っている。これらは常に働く。もしも行末に<NL>を持つファイルを使っているならば
(例えばUNIXで作られたファイル)、'fileformats'が空でかつ先頭行が<CR>で終わって
なければ正しく認識される。しかしこれは先頭行が":map <F1> :help^M"(^Mは<CR>)み
たいな内容だった場合には失敗する。ファイルの先頭行が<CR>で終わっていてその1行
限りの時、先頭行から<CR>が失われてしまうのでエラーメッセージが出るだろう。

Mac Classic: ":source"で読み込まれるファイルは通常、行末に<CR>を持っている。
これらは常に機能する。もしも行末に<NL>を持つファイルを使っているならば(例えば
UNIXで作られたファイル)、'fileformats'が空でかつ先頭行が<CR>で終わってなければ
正しく認識される。先頭行に<CR>を持ち<NL>で改行しているファイルを使用しないよう
に気を付けてください。

その他のシステムでは、Vimは取込まれた(":source"ed)ファイルの行末は<NL>であるこ
とを期待する。これは常に働く。もしも行末が<CR><NL>であるファイル(例えばMS-DOS
で作られたファイル)を使っているならば、総ての行が末尾に<CR>を持っていることに
なる。これは幾つかのコマンドにとって問題となるだろう(例、マッピング)。自動的に
行末記号を検出する機構はない。なぜなら<CR>で終了するマッピングの定義をファイル
の先頭に書くことは一般的で、自動検出用の仕組みを作るのが難しいからである。

							*line-continuation*
読込まれた(":source"d")Exコマンドスクリプトのファイル内の長い行は、行継続記号
"\"(backslash)を次行の先頭に挿入することで分割できる。バックスラッシュの前に空
白を挿入することも可能で、これらは無視される。

例: 次の記述は >
	:set comments=sr:/*,mb:*,el:*/,
		     \://,
		     \b:#,
		     \:%,
		     \n:>,
		     \fb:-

次の1行と同じ意味として解釈される: >
	:set comments=sr:/*,mb:*,el:*/,://,b:#,:%,n:>,fb:-

バックスラッシュの前に先行する空白文字は全部無視される。しかしながらバックス
ラッシュのある行の1つ前の行末には、自由に空白文字を挿入することはできない; 付
加的な空白文字が許されるかどうかは、コマンドが分割される位置に依存する。

":append"と":insert"コマンドには1つ問題がある: >
   :1append
   \asdf
   .
バックスラッシュは行継続シンボルに見えるが、コマンドの結果はこのようになる: >
   :1appendasdf
   .
これを避けるには、'cpoptions'に'C'フラグを追加することだ: >
   :set cpo+=C
   :function Foo()
   :1append
   \asdf
   :.
   :set cpo-=C

Note 関数の中でその手のコマンドを実行するには、関数定義の際に'C'フラグを追加す
る必要があり、それが実行される際にではない。
   :set cpo+=C
   :function Foo()
   :1append
   \asdf
   .
   :endfunction
   :set cpo-=C

解説:
	多くのプログラムは行継続を、継続する行の末尾にバックスラッシュを置くこ
	とで表現する。その方法をVimで採用してしまうと、Viとの互換性に重大な欠
	陥ができてしまう。たとえばこのようなViのマッピングを考えるとわかりやす
	い: >
		:map xx  asdf\
<	従って一般的ではないが行頭のバックスラッシュを採用している。

==============================================================================
5. スクリプトのデバッグ					*debug-scripts*

スクリプトの動作を知るためのコードを追加することができるのは当り前として、
Vimはデバッグモードを提供しています。これはスクリプトファイルやユーザーファン
クションをステップ実行することやブレークポイントを仕掛けることを可能にします。

NOTE: デバッグモードは未完成です。デバッグはVimの動作に副作用をあたえます。全
てをデバッグするのには使えません。例えば画面がデバッグメッセージで散乱するとき
など。
{Vi にはデバッグモードはない}

デバッグモードの代わりに'verbose'オプションが使えます。大きな値を設定するとV
imの動作についてより詳細なメッセージを得られます。


デバッグモードを開始する					*debug-mode*

デバッグモードを開始するにはこれらの方法のうちどれかを使います:
1. Vimを|-D|引数付きで起動する: >
	vim -D file.txt
<  最初にvimrcを読み込むところからデバッグを開始します。これはVimの起動時に何
   が起こっているのかを調査するのに便利です。副作用としてVimは初期化が完了する
   前に安全のためターミナルモードを切替えます。
   (WindowsやMacintoshの)GUI専用バージョンではGUIウインドウを開くとすぐにデバ
   ッグが開始します。これを早めるにはvimrcファイルに":gui"と書いてください。
								*:debug*
2. ":debug"を前に付けてコマンドを実行します。そのコマンドを実行する間だけデバ
   ッグできます。特定のスクリプトファイルやユーザー関数をデバッグするのに便利
   です。オートコマンドから呼び出されるスクリプトや関数にも便利です。
   例: >
	:debug edit test.txt.gz

3. ブレークポイントをソースファイルやユーザーファンクションに設定します。コ
   マンドラインから次のようにできます: >
   	vim -c "breakadd file */explorer.vim"
<  これはVimを起動して"explorer.vim"の最初の行を読み込むところで停止します。
   デバッグモード中でもブレークポイントを設定できます。

デバッグモード中に実行されるコマンドはそれが実行される前に表示されます。コメン
トや空の行、実行されない行はとばされます。行が"|"を使って二つのコマンドを含ん
でいた場合には分けて表示されます。


デバッグモード
--------------

デバッグモードに入ると、通常のExコマンドが使えます。例えば、変数の値を見るに
は: >
	echo idx
ユーザーファンクション内では、これはローカル変数の"idx"を表示します。"g:"を頭
に付けるとグローバル変数の値を表示します: >
	echo g:idx
全てのコマンドは実行中の関数やスクリプトの文脈として実行されます。オプションを
設定することもできます。例えば何が起こっているのかを表示するために'verbose'を
設定することができます。興味のある部分を実行する前に次のようにするといいでしょ
う: >
	:set verbose=20

スクリーンの更新を必要とするコマンドは避けるべきです。なぜならデバッグモードを
抜けるまでその作用に気付き難いからです。例えば: >
	:help
これはとても不便です。

デバッグモードのためのコマンドラインヒストリが別に用意されています。

関数の行番号はその関数の始まりから数えます。見ている行の番号を数えるのに苦労す
る場合はその関数の書かれたファイルを別のVimで開き、その関数の始まりを探しだし
、"99j"を実行してください。"99"は実際の行番号に合わせて変えてください。

さらに、以下のコマンドが使えます:
							*>cont*
	cont		次のブレークポイントまで実行します。
							*>quit*
	quit		異常停止します。これはCTRL-Cを使うことに似ていますが、
			全てを停止するわけではありません。次のブレークポイント
			で停止します。
							*>next*
	next		コマンドを実行しそれが終わるとデバッグモードに戻りま
			す。ユーザー関数やソースファイルの呼び出し時には呼び
			出し元の次の行に進みます。
							*>step*
	step		コマンドを実行しそれが終わるとデバッグモードに戻りま
			す。ユーザー関数やソースファイルの呼び出し時には呼び
			出し先の行に進みます。
							*>interrupt*
	interrupt	CTRL-Cを使うことに似ていますが、次のコマンドを実行する
			ためにデバッグモードに戻る場所が">quit"と違います。例
			外割り込みについて|:finally|や|:catch|をテストするのに
			便利です。
							*>finish*
	finish		実行中のスクリプトやユーザー関数を終了し呼び出し元で
			デバッグモードに戻ります。

デバッグモードのコマンドについて:
- 補間はできません。通常のExコマンドのみ補間できます。
- 次の一文字に省略すことができます: "c", "n", "s" そして "f"。
- <CR>を押すと前回のものを繰り返します。関係ないコマンドを使うとリセットされま
  す(どうすべきかがわかりにくいため)。
- 同じ名前のExコマンドを使うにはコロンを付けてください:
  ":cont", ":next", ":finish" (省略時も)


ブレークポイントの定義
----------------------
							*:breaka* *:breakadd*
:breaka[dd] func [lnum] {name}
		関数にブレークポイントを設定します。例: >
			:breakadd func Explore
<		関数名が妥当かどうか検査しませので、関数定義の前にブレークポイ
		ントを定義できます。

:breaka[dd] file [lnum] {name}
		ソースファイルにブレークポイントを設定します。例: >
			:breakadd file 43 .vimrc

:breaka[dd] here
		カレントファイルのカレント行にブレークポイントを設定します。
		次を行うのと同様です: >
			:breakadd file <cursor-line> <current-file>
<		Note これはファイルを読み込むときに実行されるコマンドに対して
		だけ働きます。そのファイル中で定義される関数に対しては働きませ
		ん。

[lnum]はブレークポイントにする行番号です。Vimはその行かそれ以降で停止します。
省略時すると1行目になります。

							*:debug-name*
{name} はファイル名や関数名のパターンです。パターンはオートコマンドで使われる
ものと同じです。完全に一致しなければなりません(パターンが"^"で始まって"$"で終
わるように)。"*"は全ての文字列に一致します。'ignorecase'は使われませんが、大文
字と小文字を区別しないために"\c"を使うことができます|/\c|。関数名には()を付け
ないでください!

ソースファイル名のパターン検査はファイルのフルネームに対して行われます。例: >
	breakadd file explorer
パスが間違っているので一致しません。 >
	breakadd file *explorer.vim
".../plugin/explorer.vim"と".../plugin/iexplorer.vim"に一致します。 >
	breakadd file */explorer.vim
".../plugin/explorer.vim"だけに一致します。

関数名のパターン検査は";function"で表示される名前に対して行われます。ローカ
ル関数には"<SNR>99_"といったものが前に付くということです。

Note 関数はまず読み込まれ、後で実行されます。読み込まれたときに "file" ブレー
クポイントがチェックされ、実行されるときに "func" ブレークポイントがチェックさ
れます。

ブレークポイントの削除
----------------------
						*:breakd* *:breakdel* *E161*
:breakd[el] {nr}
		ブレークポイント{nr}を削除します。|:breaklist|を使って番号を
		確認してください。

:breakd[el] *
		すべてのブレークポイントを削除します。

:breakd[el] func [lnum] {name}
		関数内のブレークポイントを削除します。

:breakd[el] file [lnum] {name}
		ソースファイル内のブレークポイントを削除します。

:breakd[el] here
		カレントファイルのカレント行のブレークポイントを削除します。


[lnum]が省略されると関数、またはファイルの最初のブレークポイントが削除されま
す。
{name}は":breakadd"で使った名前と完全に同じでなければなりません。"eplorer"と
"*explorer.vim"、"*explorer*"は違います。


ブレークポイントを列挙する
--------------------------
							*:breakl* *:breaklist*
:breakl[ist]
		全てのブレークポイントを列挙します。


その他
------

						*:debugg* *:debuggreedy*
:debugg[reedy]
		デバッグモードのコマンドをユーザーから直接得るのではなく標準入
		力から読み込みます。スクリプトのテストのときに便利です。
		例: >
		  echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim

:0debugg[reedy]
		":debuggreedy"を取り消します。それ以降のデバッグモードコマンド
		を使わず、ユーザーから直接デバッグモードコマンドを受け取ります
		。

==============================================================================
6. プロファイリング						*profile* *profiling*

プロファイリングとは、関数やスクリプトの実行にかかる時間を計測することです。
これを行うには |+profile| 機能が必要です。
この機能は "huge" 機能つきでコンパイルしたときだけ含まれます。
{Vi はプロファイリング機能を持っていない}

また、関数 |reltime()| を使っても時間を計測できます。この関数には |+reltime|
機能だけが必要です。これは "huge" 以外でもしばしばついてきます。

:prof[ile] start {fname}			*:prof* *:profile* *E750*
		プロファイリングを開始し、終了時に出力を {fname} に出力します。
		{fname} がすでに存在するときは、警告なしに上書きされます。
		変数 |v:profiling| に 1 が代入されます。

:prof[ile] continue
		":profile pause" の後にこれを実行すると、プロファイリングを再
		開します。

:prof[ile] func {pattern}
		パターン {pattern} にマッチする関数をプロファイリングします。
		{pattern} がどう使われるかは |:debug-name| を参照。

:prof[ile][!] file {pattern}
		パターン {pattern} にマッチするスクリプトファイルをプロファイ
		リングします。
		{pattern} がどう使われるかは |:debug-name| を参照。
		このコマンドはスクリプトそのものをプロファイリングするだけで、
		その中で定義されている関数のプロファイリングは行いません。
		[!] がつけられたときは、そのスクリプト中で定義されている全ての
		関数のプロファイリングも行います。しかしスクリプトがこのコマン
		ドの後で読み込まれたときだけです。

:profd[el] ...						*:profd* *:profdel*
		指定された引数に対するプロファイリングを停止します。引数につい
		ては |:breakdel| を参照。

最初は常に ":profile start fname" コマンドで始めなければなりません。結果のファ
イルは Vim が終了するときに書き出されます。次に出力の例を挙げます。説明のため
に行番号が行頭についています:

  1 FUNCTION  Test2() ~
  2 Called 1 time ~
  3 Total time:   0.155251 ~
  4  Self time:   0.002006 ~
  5  ~
  6 count  total (s)   self (s) ~
  7	9	       0.000096   for i in range(8) ~
  8	8   0.153655   0.000410     call Test3() ~
  9	8	       0.000070   endfor ~
 10				  " Ask a question ~
 11	1	       0.001341   echo input("give me an answer: ") ~

ヘッダ(1行目から4行目)は関数全体にかかった時間を示しています。"Total" はこの関
数を実行している間に経過した時間です。"Self" は "Total" のうち、次のことにかか
った時間を引いたものです:
- 他のユーザ定義関数
- スクリプトの読み込み
- 自動コマンドの実行
- 外部(シェル)プログラム

7行目から11行目は各実行行にかかった時間を示しています。実行されない行はカウン
トされません。それゆえ、コメント行は決してカウントされません。

Count の桁はその行が何回実行されたかを示します。7行目の "for" コマンドはそれ以
下の行と同様に何回も実行されることに注意してください。これは、ループの終わりを
検出するためにこの行が何回も実行されるためです。

ユーザ入力待ちにかかった時間は一切カウントされません。それゆえ、input() のプロ
ンプトに反応するのにどれだけ時間がかかろうとも無関係です。

プロファイリングはどこで時間が費やされたかのよい指標を与えてくれますが、多くの
原因によりその結果がごまかされてしまう場合があるということを覚えておいてくださ
い:

- システム関数 gettimeofday() に依存する時間計測の精度。たとえ時間がマイクロ秒
  で表示されていたとしても、1/100秒の精度しかないこともあります。

- 実経過時間が計測されます。他のプロセスがビジーであると、それが予測できない箇
  所で遅れを引き起こす可能性があります。

- 1行に複数のコマンドを書いていると、1つの時間しか得られません。ここのコマンド
  に対して時間を見るにはその行を分割してください。

- 各行の時間の総和をとると、たいてい関数全体の時間より小さくなります。各行の間
  にオーバーヘッドがあります。

- Vim が終了する前に削除された関数はプロファイリング情報を生成しません。必要な
  ら変数 |v:profiling| をチェックしてください: >
	:if !v:profiling
	:   delfunc MyFunc
	:endif
<
- マルチプロセッサシステム上では、スリープモードが作動したときや、省力のためプ
  ロセッサの周波数が下がったとき、プロファイリングが奇妙な結果を出すかもしれま
  せん。

- 関数が再帰的に呼ばれた場合、"self" 時間は正しくでない。


 vim:tw=78:ts=8:ft=help:norl:
